[{"content":"2024.7.16 初始历经三个月的异地网恋💕 我们的开始仿佛是和那些青春期少男少女的网恋那般，相识于网络，历尽三个月的网恋,每天通过微信和抖音分享日常,深深地被对方吸引🤩。\n两人都不是青葱少年，那时我刚研究生二年级，而我的女朋友步步😍已经在一所初中工作了几年了，我们已不在年少热血，但我们的爱❤️并没有应为距离而暗淡，热烈真诚是我们感情的催化剂！\n2024.9.17（相❤️爱纪念日）我们第一次见面 第一次见面的我们俩有些羞涩和腼腆😚，但内心对对方汹涌的爱意❤️是抵不住的，并没有很多弯弯绕绕，我们就自然而然地在一起了😃！互相送了对方定情信物。哈哈哈，现在想起来谁家男朋友第一次见面送人书呀。\n","date":"2025-08-29T00:00:00Z","image":"https://jb-cao.github.io/Cao-blog/p/love-story/images/love_hu_d8861ebe2d0c7542.jpg","permalink":"https://jb-cao.github.io/Cao-blog/p/love-story/","title":"关于我们相遇"},{"content":"学习一些2025年最新的Nature环境微生物研究文章，了解一下当前较新的研究思路和方法。\nKnight, C.G., Nicolitch, O., Griffiths, R.I., Goodall, T., Jones, B., Weser, C., Langridge, H., Davison, J., Dellavalle, A., Eisenhauer, N., et al. (2024). Soil microbiomes show consistent and predictable responses to extreme events. Nature 636, 690–696. https://doi.org/10.1038/s41586-024-08185-3. 这篇文章通过统一设计的大规模模拟实验，在草地土壤中施加干旱、洪水、冻结和高温等极端气候事件，系统比较微生物群落的结构与功能响应，发现其响应具有高度一致性和系统发育保守性，并提出微生物响应强度可由土壤原生环境预测，建立了土壤微生物对极端气候冲击的普适响应框架。\n土壤微生物组对极端气候事件的响应模式 随着全球气候变迁，极端气候事件（Extreme Climatic Events, ECEs）发生频率显著增加，对陆地生态系统功能带来前所未有的挑战。土壤微生物作为生态系统功能的核心，其对极端事件的响应机制仍不清晰。本研究统一实验设计，在欧洲10个国家的30个草地土壤中模拟干旱、洪水、冻结和热浪，系统评估微生物群落的结构和功能变化。结果显示微生物响应具有高度一致性，并受系统发育约束。这一发现为全球尺度预测极端气候对微生物群落和生态功能的影响提供了理论基础。\n极端气候事件正以前所未有的频率和强度冲击地表生态系统。在陆地生态系统中，土壤微生物群落通过有机质分解、碳氮循环等过程维持生态功能。然而，我们尚不清楚：这些微生物是否存在通用的应对模式？是否可以通过系统发育特征或环境背景来预测群落响应？\n为回答上述问题，本研究设计了一项大规模跨气候区实验，在严格控制条件下施加四种典型极端气候事件，系统比较微生物响应的一致性、系统发育保守性和可预测性。\n研究设计与方法 研究采集自欧洲30个草地土壤（涵盖高山、温带、地中海、寒带等气候区），每个土壤样本在实验室中分别接受五种处理：对照、干旱、洪水、冻结和高温（热浪）。处理持续时间依据生态学合理尺度设定。随后，对样品进行宏基因组测序和代谢活性检测，以揭示微生物群落的组成和功能变化。\n微生物群落响应的整体趋势 所有四类极端气候事件都能显著改变微生物群落结构，特别是高温和干旱处理。高温引起α多样性降低，β多样性增大，群落组成趋于简化和重组。通过主坐标分析（PCoA）和距离分析，研究者发现同类事件下不同土壤样本的微生物变化方向高度一致，说明响应具有普遍性和可预测性。\n其中，高温处理不仅改变了群落结构，还显著增强了孢子形成菌（如芽孢杆菌、放线菌）的相对丰度，而洪水和冻结引发的变化则相对温和。\n展示不同极端事件下土壤微生物群落组成、β多样性和代谢基因群的变化趋势。\n微生物响应具有系统发育保守性 群落组成变化中，具有相近系统发育位置的微生物对同一事件表现出相似的响应。例如，在高温处理中，某些放线菌门和芽孢杆菌表现出显著富集，暗示其具备特有的耐热机制。 将响应信号投射到系统发育树中，发现微生物的响应具有明显的系统发育保守性：亲缘关系近的物种对同一事件表现出相似反应。例如，在热浪处理中，许多革兰氏阳性菌表现出一致的耐受或优势扩张趋势，而革兰氏阴性菌（如变形菌门）则整体下调。这种保守性使得基于系统发育信息可以对不同微生物类群的响应趋势进行合理预测。\n展示微生物群落中不同门类的响应差异及其系统发育树状图对比。\n功能响应：热胁迫引发“休眠化” 高温处理显著上调了与休眠和孢子形成相关的基因表达，如spo0A、sigF、relA等。这种“休眠化”策略降低了微生物的代谢活跃度，同时也可能限制其生态功能输出。\n代谢多样性分析显示，干扰事件总体降低了群落功能多样性，尤其是高温处理，表明微生物进入功能压制状态以应对胁迫。\n展示关键应激基因表达热图、代谢通路富集分析结果等。\n响应强度与原生环境有关 土壤历史气候背景和理化性质能部分预测其对某类事件的响应强度。例如，地中海气候土壤对干旱反应较弱，而寒带土壤对高温异常敏感。\n构建响应强度与环境因子之间的回归模型，发现年均降水、气温波动性、有机质含量等是重要预测因子。\n展示响应强度与历史气候和土壤特性之间的相关性图表、建模残差分析等。\n结论与展望 本研究首次在泛欧洲尺度上、通过统一设计系统考察土壤微生物群落对极端气候事件的响应，揭示出如下关键发现：\n响应一致性强：不同地点、不同背景的土壤微生物群落对同类事件反应方向一致； 系统发育保守性：群落变化受微生物亲缘关系影响，具备进化学上的一致模式； 功能趋同：高温诱导休眠与代谢抑制是主要功能响应路径； 敏感性可预测：土壤历史环境决定其对未来气候冲击的敏感度。 这些发现为未来构建气候事件风险图谱、开展生态恢复和土地管理提供了科学基础。下一步研究可进一步结合代谢组学、稳定同位素追踪等手段，以更全面揭示“微生物–生态功能”之间的耦合响应机制。\n","date":"2025-07-31T00:00:00Z","image":"https://jb-cao.github.io/Cao-blog/p/25-nature-4/images/1-2_hu_14f88c7136f41d18.png","permalink":"https://jb-cao.github.io/Cao-blog/p/25-nature-4/","title":"25年最新的一些Nature环境微生物研究文章（4）"},{"content":"学习一些2025年最新的Nature环境微生物研究文章，了解一下当前较新的研究思路和方法。\nLee, K.K., Liu, S., Crocker, K., Wang, J., Huggins, D.R., Tikhonov, M., Mani, M., and Kuehn, S. (2025). Functional regimes define soil microbiome response to environmental change. Nature, 1–11. https://doi.org/10.1038/s41586-025-09264-9. 这篇文章做了大量的土壤微宇宙（microcosms）扰动实验，测量硝酸盐利用和微生物组，工作量很大。还在此基础上构建了数学模型并实验验证，为理解复杂微生物群落如何应对环境扰动提供了新视角。\n功能机制定义土壤微生物组对环境变化的响应 土壤微生物组的代谢活动在全球养分循环中起着核心作用。理解土壤代谢活动如何响应气候驱动的环境扰动是一个关键挑战。然而，土壤的生态、空间和化学复杂性阻碍了本文对这些群落如何响应扰动的理解。微生物组代谢响应环境变化的机制问题，由于自然微生物组的复杂性而变得尤为困难。这种复杂性在土壤中表现得最为明显，土壤具有巨大的分类多样性、空间异质性和化学多样性环境。\n传统的大规模调查方法通过量化野外环境变化、群落组成和代谢过程之间的相关性来研究这个问题。虽然调查揭示了稳健的相关性，但它们在揭示决定群落对环境变化响应的机制方面面临两个挑战：首先，调查无法控制混杂因素；其次，很难在野外大规模量化代谢动态。因此，调查在确定控制自然群落对环境变化代谢响应的机制方面能力有限。\n研究方法与实验设计 为了控制混杂因素并获得机制性见解，研究团队采用了土壤微宇宙实验方法。这种方法消除了相关的环境波动，并允许在实验室中进行受控扰动。研究选择了美国华盛顿州Cook Agronomy Farm(CAF)的土壤作为研究对象，该地点表现出较大的自然pH变化，但其他环境因素变化最小。重要的是，土壤微宇宙能够高通量量化对环境扰动的代谢物动态。\n研究团队采集了20个表层土壤样品，这些样品的原生pH值从4.7到8.3不等。通过创建土壤-水混合物（浆液），并添加2mM硝酸盐和不同水平的强酸或强碱来扰动每个土壤的pH值至3到9之间的13个不同值。为了将预先存在的硝酸盐利用者的活性与每种条件下的生长分开，研究包括了用氯霉素处理的对照组，氯霉素抑制蛋白质合成。\n图1a显示了在长期pH梯度(n=20个土壤，pH 4.7至8.3)上进行短期pH扰动(n=13)的实验室条件下野外采样示意图。图1b展示了3种不同原生pH土壤在酸性或碱性pH扰动下的硝酸盐浓度随时间变化。图1c是功能机制的示意图。\n三种功能机制的发现 通过测量分析，研究发现了三种不同的硝酸盐利用机制：\n酸性死亡机制(Regime I)：在强酸性扰动(pH≤4)下，氯霉素处理和未处理条件下的硝酸盐还原都很小，表明几乎没有预先存在的硝酸盐还原生物量，也没有生长。\n养分限制机制(Regime II)：在接近原生pH的pH水平(4≤pH≤8)下，即使是非氯霉素样品中，硝酸盐也呈线性下降，但速率比氯霉素处理的对照组快。这表明在非氯霉素条件下发生了一些生长，但可能受到硝酸盐以外的养分缺乏的抑制。\n复苏生长机制(Regime III)：在强碱性条件下(pH\u0026gt;8)，非氯霉素样品显示硝酸盐还原加速，而氯霉素处理的样品显示很少的活性。这表明土著硝酸盐利用种群很小，但这个稀有种群迅速扩大，在非氯霉素条件下耗尽硝酸盐。\n图2左列展示了描述群落水平代谢的消费者-资源模型，包括单一功能生物量(x)、硝酸盐浓度(A)和限制性养分浓度(C)。中间和右列展示了两种机制下x(t)、A(t)和C(t)的动态。\n模型建立与验证 为了描述硝酸盐动态，研究团队使用了消费者-资源模型。该模型将土壤微生物组的生态复杂性归结为单一有效生物量，而不是明确考虑多种类群及其相互作用。模型包括三个变量：功能性硝酸盐利用生物量(x)、硝酸盐浓度(A)和碳养分(C)，以及五个参数：消耗速率(rA和rC)、亲和力(KA和KC)和生物量生长速率(γ)。\n模型有两个关键特性：首先，硝酸盐利用率(Ạ)与功能生物量(x)的数量成正比，即使在没有生长的情况下也是如此；其次，功能生物量对A和C的吸收遵循共同限制的Monod形式，因此任何一种资源的耗尽都会停止生长。这些特性意味着当C耗尽时，生长停止，硝酸盐(A)以与x成正比的恒定速率被消耗。\n研究团队将这个模型拟合到所有20种土壤和13种pH扰动的硝酸盐利用动态中，无论是否使用氯霉素处理。通过固定生长率γ和亲和力参数(KA和KC)，并改变两个重新调整的参数：x̃(0)=x(0)rA和γC̃(0)=γC(0)rA/rC，这些参数保留了与x和C相同的解释：x̃(0)反映了在给定条件下所有可以进行硝酸盐还原的类群的土著代谢活性，γC̃(0)反映了可用的限制性养分。\n图3a展示了从所有样品的硝酸盐动态推断出的两个模型参数——土著生物量活性(x̃(0))和限制性养分浓度(γC̃(0))的散点图。图3b展示了每种机制下中性和酸性土壤的硝酸盐动态示例。图3c和3d分别展示了不同原生pH和扰动pH值下土著生物量和限制性养分的热图。\n分类学模式与机制验证 为了开始确定控制跨机制代谢变化的主导机制，研究团队通过测序量化了组成变化。研究测量了在氯霉素处理和未处理条件下孵育四天后的绝对丰度，计算了门水平的生长倍数，并使用非负矩阵分解(NMF)来分解所有土壤和pH扰动下门水平生长的变化。\n分析表明，大多数生长可以用两个变化轴来捕捉：一个轴包括假单胞菌门和拟杆菌门的组合，另一个轴仅包括芽孢杆菌门。在机制II中，假单胞菌门和拟杆菌门随着pH的增加而增加生长，随后在机制III开始附近下降。这与模型在机制II中揭示的土著生物量活性(x̃(0))的行为相匹配。芽孢杆菌门直到pH阈值在7到8.5之间才开始生长，这与机制III中指数硝酸盐利用动态的开始相匹配。\n图4a和4b分别展示了假单胞菌门和拟杆菌门组合以及芽孢杆菌门在不同pH条件下的生长倍数。图4c展示了假单胞菌门和拟杆菌门与芽孢杆菌门生长倍数的散点图。图4d展示了x̃(0)与γC̃(0)的散点图，其中标出了机制，红色轮廓表示接近机制III边界的机制II条件。\n机制II中碳释放促进生长 在养分限制机制II中，无论是否使用氯霉素，硝酸盐还原速率都保持恒定，但在不使用药物时速率更高。模型将无药物时速率增加归因于养分(C(0))的快速初始利用。此外，随着扰动pH的增加，无氯霉素条件下的硝酸盐还原速率增加。模型提出，随着pH增加的限制性养分可用性(γC̃(0))推动了增加硝酸盐还原速率的生长。\npH增加可以通过粘土颗粒上离子交换位点的取代反应增强土壤中有机碳的可用性。由于养分是通过交换反应释放的，研究假设生物量的增加，因此硝酸盐还原速率应该与添加到系统中的酸或碱的量成正比。在所有土壤中都观察到了这一趋势，表现为硝酸盐还原速率随NaOH一致增加（浅蓝色区域）。如果硝酸盐利用率随NaOH增加是由于限制性养分可用性(γC̃(0))增加推动了硝酸盐还原者的生长，那么预计它们的丰度会随着NaOH的增加而上升。正如预期的那样，通过16S rRNA扩增子测序测量的绝对丰度与添加到系统中的NaOH量呈线性关系。\n图5a展示了硝酸盐还原速率（无氯霉素/氯霉素处理）随添加到土壤中的NaOH量的变化。图5b展示了养分释放的假设机制示意图。图5c展示了模型推断的可用限制性养分(C̃(0))与测量的水溶性有机碳(WSOC)的散点图。图5d和5e展示了在养分限制机制下未扰动pH(5.4)土壤的修正实验结果。\n机制I中生物量减少与细胞死亡相关 在酸性pH扰动响应中，模型显示土著生物量活性(x̃(0))减少和限制性养分可用性降低。为了测试土著生物量活性(x̃(0))随pH下降是否与细菌丰度相关，研究计算了在氯霉素处理条件下每个门终点绝对丰度相对于初始时间点T0的倍数变化(\u0026ldquo;存活倍数\u0026rdquo;)。存活倍数反映了在没有生长的情况下丰度的变化，因此本文将其视为死亡的代理。\n除了芽孢杆菌门外，所有门在酸性扰动下都表现出存活倍数的一致下降。存活倍数与x̃(0)近似线性下降，表明生物量活性的降低可能与细胞死亡有关。然而，存活倍数的变化也可能源于pH依赖性残留DNA的降解。为了测试细胞死亡减少机制I中生物量活性的假设，研究使用了从本文的土壤或代表图4中三个门的菌株集合中分离的菌株。使用这些分离株，测量了pH值从3到7范围内的DNA降解和细胞死亡率。结合这些速率和模型使本文能够得出结论，通过测序测量的丰度变化必须至少部分源于细胞死亡。\n图6a展示了土壤质地（沙、粘土和淤泥的比例）的三元图。图6b展示了来自LaBagh(IL, USA)、Pinhook(IN, USA)和Sedgwick CLG13和ELG13(CA, USA)土壤样品的拟合模型参数(x̃(0)和γC̃(0))的散点图。图6c展示了来自捷克共和国三种土壤的早期反硝化速率(反硝化酶活性(DEA，等同于x̃(0)))和DEA与长期反硝化速率(反硝化潜力(DP，等同于γC̃(0)))差异的散点图。图6d展示了来自LaBagh(IL)、Pinhook(IN)和Sedgwick CLG13和ELG13(CA)土壤样品在不同pH水平下芽孢杆菌门以及假单胞菌门和拟杆菌门组合的生长倍数。图6e展示了Anderson等人研究中pH扰动后门水平相对丰度随时间变化。图6f展示了来自四项研究的土壤在酸性或碱性pH扰动下土著生物量活性(x̃(0))下降。图6g展示了先前研究中土壤在接近原生pH下氮利用的恒定速率。\n长期pH对机制边界的影响 研究观察到，土壤的原生(长期)pH决定了在机制之间转变的pH阈值，酸性土壤在比中性土壤更小的酸性扰动后从机制II转变为机制I。这种行为可能是由群落过去暴露于pH波动所塑造的。虽然本文缺乏历史pH波动的直接记录，但本文可以使用滴定曲线来描述土壤对pH扰动的响应。\n在所有土壤中，这些曲线显示出一致的形状：在高(pH 9)和低(pH 3)pH值处的平台由陡峭的非线性转变连接。土壤的原生pH决定了其在无扰动时沿曲线的位置。酸性土壤位于较低平台附近，因此对pH变化有很强的缓冲作用。相比之下，更多的中性土壤位于陡峭区域，在那里小的酸或碱添加会导致大的pH变化。本文推测这种缓冲能力的差异使得来自酸性土壤的群落对pH波动的耐受性较差，这可能解释了它们在更小的扰动后从机制II转变为机制I。\n此外，本文的测序数据支持微生物组组成反映对原生pH的特定适应，有助于解释跨土壤的机制边界变化。在更酸的土壤中，假单胞菌门和拟杆菌门在较低pH下表现出更大的存活率。相反，芽孢杆菌门开始在机制III中生长的pH随原生土壤pH增加而增加。此外，在机制III中生长的菌株的身份预测了土壤的原生pH。这些发现表明，长期暴露于特定的pH条件会选择特定的类群，可能塑造群落转变功能机制之间的pH阈值。\n讨论与展望 这项研究对理论微生物生态学和微生物组代谢的实证研究具有重要意义。首先，本文的模型将整个群落抽象为单一有效生物量的成功与捕捉许多相互作用物种的复杂生态系统模型形成鲜明对比。这种对比表明，自然群落可能更适合通过粗粒度描述来理解，这种描述捕捉了群落中少数代谢相关的群体或行会。这种生态系统的低维图景尊重潜在机制，并与群落可观察的功能特性紧密相连。将这一成功扩展到更复杂的代谢过程，并将有效生物量变量如x̃与基础丰度动态联系起来，是未来工作的关键方向。\n其次，理解微生物群落代谢如何响应环境扰动仍然是应用微生物组科学的核心问题。这一挑战源于由许多具有不同代谢特征和生态相互作用的物种组成的群落的复杂性，这些相互作用发生在化学复杂的环境中。群落的复杂性促使测量越来越复杂，从宏基因组学和转录组学到单细胞代谢组学和定量稳定同位素探针。然而，将这些数据与群落代谢及其对环境扰动的响应联系起来仍然很困难。本文的研究结果表明，与其单独关注微观过程，不如首先进行定量、系统级的观察，如硝酸盐通量，并使用简单模型描述这些通量。然后，模型提出组织群落代谢的机制，如养分限制或生物量活性的变化。反过来，可以研究这些提出的机制的生理、化学或生态起源。\n本文的分析揭示了与功能机制相关的保守门水平关联。在强碱性扰动下，稀有芽孢杆菌门扩大，而优势假单胞菌门和拟杆菌门在接近原生pH下茁壮成长。这些模式表明，适应瞬时胁迫的稀有类群和适应稳定条件的优势类群，突出了波动在维持多样性中的作用。理解这些分类学模式需要将动态与生理学联系起来。尽管最近的工作已经对平衡生长的生理学产生了定量见解，但本文对波动在决定微生物特征中的作用的理解仍然有限。即使在缺乏生理学见解的情况下，本文的方法也能够从测序和养分测量中预测硝酸盐动态。使用从16S数据推断的硝酸盐还原酶基因丰度和WSOC测量，本文训练了回归来预测模型参数x̃(0)和γC̃(0)。这使本文能够仅从pH、WSOC和扩增子数据预测硝酸盐通量，证明功能机制即使在复杂群落中也能连接结构和功能。\n本文的研究有几个局限性。首先，土壤浆液缺乏完整土壤的物理结构和自然环境波动；特别是，原位硝酸盐利用发生在动态变化条件下。其次，自然pH变化通常很小(小于1个单位)，这意味着大多数土壤可能保持在机制II，除非在肥料或尿液输入等大型外源扰动下。第三，尽管本文的土壤合理地涵盖了全球分类多样性，但它们对高度碱性(pH\u0026gt;8)或强酸性(pH\u0026lt;4)土壤的代表性不足。高度缓冲的碱性土壤可能完全抵抗pH诱导的机制转变。\n","date":"2025-07-30T00:00:00Z","image":"https://jb-cao.github.io/Cao-blog/p/25-nature-3/images/fig1_hu_3ca09b7728abf61.png","permalink":"https://jb-cao.github.io/Cao-blog/p/25-nature-3/","title":"25年最新的一些Nature环境微生物研究文章（3）"},{"content":"学习一些2025年最新的Nature环境微生物研究文章，了解一下当前较新的研究思路和方法。\nBorton, M.A., McGivern, B.B., Willi, K.R., Woodcroft, B.J., Mosier, A.C., Singleton, D.M., Bambakidis, T., Pelly, A., Daly, R.A., Liu, F., et al. (2025). A functional microbiome catalogue crowdsourced from north american rivers. Nature 637, 103–112. https://doi.org/10.1038/s41586-024-08240-z. 这篇文章跟上一篇那个类似，采样贡献很大，同时有数据资源性贡献。然后测了宏基因组+宏转录组（所以可以自信的说功能数据库），还提出了河流连续体概念（这种思想可以借鉴）。最终也是没有做验证实验发表在Nature上。\n北美河流微生物组功能数据库（GROWdb） 在全球气候变化与人类活动加剧的背景下，河流生态系统作为陆地与水生环境的关键连接点，其微生物群落的结构与功能对元素循环、水质维持及生态系统稳定性具有决定性作用。该文章通过创新的众包采样模式与基因组解析技术，构建了首个覆盖北美大陆尺度的河流微生物组功能数据库（GROWdb），为理解河流微生物的生物地理学特征与生态功能提供了突破性视角。\n河流是地球表层物质循环的核心枢纽，承担着营养传输、碳氮转化等关键生态功能，同时直接影响人类的水资源安全与生态健康。尽管海洋微生物组已通过全球联盟（如Tara Oceans）得到深入研究，但河流微生物组的研究仍存在显著不足：多数研究依赖16S rRNA基因测序，难以解析功能潜力；宏基因组研究较少恢复宏基因组组装基因组（MAGs），掩盖了未知类群的贡献；采样范围局限于单一河流或流域，缺乏跨系统的普适性结论。\n针对这些缺口，本研究旨在通过众包协作与基因组分辨率分析，构建一个覆盖北美主要流域的河流微生物组功能数据库（GROWdb）。其核心目标包括：（1）解析河流微生物的分类与功能多样性，识别核心类群及其代谢潜力；（2）揭示微生物群落结构与功能的空间驱动因素（如地理、土地利用、溪流等级）；（3）验证河流连续体概念（RCC）在微生物功能层面的适用性；（4）建立微生物组与新兴污染物转化的关联，为水质管理提供依据。\n研究方法 众包采样与数据整合 研究采用“网络中的网络”模式，联合超过100个团队在北美106个站点采集163个表层水样本，覆盖美国90%的流域（21个水文单元），涵盖不同生态区、溪流等级与流域规模。采样同步记录287项地理空间参数（如土地利用、溪流等级、流域面积）和地球化学数据（如水温、营养盐浓度），确保环境变量的全面性。\n测序与分析技术 对样本进行宏基因组和宏转录组测序，获得约3.8Tb数据。通过三种组装方法（MEGAHIT、IDBA-UD、metaSPAdes）生成重叠群，结合MetaBAT2进行分箱，最终获得3825个中高质量MAGs，去重后保留2093个（99%序列一致性）。采用GTDB-tk进行分类注释，DRAM进行功能注释，并通过Bowtie2将测序 reads 映射到MAGs以量化丰度与表达量。\n数据库构建 GROWdb通过多平台开放访问：NCBI存储原始测序数据与MAGs；国家微生物组数据协作网（NMDC）链接多组学数据；KBase提供基因组注释与代谢模型；GROWdb Explorer提供交互式可视化工具，实现跨学科数据复用。\nGROWdb的核心特征 GROWdb包含2093个去重MAGs，覆盖27个门，其中10个科、128个属为新分类单元，大量类群仅通过字母数字命名（如未培养细菌UBA类群），凸显河流微生物的未知多样性。与现有淡水MAGs对比，河流与湖泊微生物组成差异显著，且河流样本的基因组覆盖率更高，表明GROWdb填补了河流微生物基因组资源的空白。\n通过分析全球266,764个公开宏基因组数据，发现GROWdb的MAGs存在于90%的河流样本和46%的淡水样本中，且在废水、土壤等环境中也有检出，印证了河流作为“景观整合者”的角色——其微生物群落整合了陆地、水生等多源输入。\n核心河流微生物组的功能特征 宏基因组分析显示，放线菌门（Actinobacteriota）、变形菌门（Proteobacteria）、拟杆菌门（Bacteroidota）和疣微菌门（Verrucomicrobiota）为优势类群，占所有样本相对丰度的主导地位。其中，Planktophilia属（放线菌门）在70%的样本中存在，平均相对丰度达12%，是分布最广且最丰富的类群；Limnohabitans_A、Polynucleobacter等5个属也存在于50%以上的样本中。\n宏转录组分析进一步识别出25个高表达属，其中Methylopumilus、Polynucleobacter、Planktophilia等6个属在所有转录组样本中均有活性（核心活性属）。这些类群普遍具备有氧呼吸（编码电子传递链复合体）和光驱动代谢（光合系统、视紫红质）能力，部分还能降解硫、甲烷或参与氮还原，体现了代谢冗余——这是河流微生物应对环境波动的关键策略。\n硝化作用是河流氮循环的核心环节，GROWdb识别出1个Nitrosomonas属MAG（氨氧化）和2个Nitrospiraceae科MAG（亚硝酸盐氧化），均编码抗紫外线损伤和抗氧化应激的基因（如光解酶、超氧化物歧化酶），适应表层水环境。此外，检测到17个Patescibacteria门MAGs，虽为专性发酵菌（无法呼吸），但在表层水中通过生物膜或低氧微生境存活，且其丰度随河流规模增加而降低，暗示与河床交换的关联。\n新兴污染物的微生物响应 河流作为人类活动的“受体”，持续暴露于抗生素、微塑料等新兴污染物。GROWdb分析显示，54.3%的MAGs（1135个）编码25类抗生素抗性基因（ARGs），其中糖肽抗性基因（van）数量最多（1219个），但多数不位于典型抗性基因簇中，功能待验证。30%的ARGs在转录组中表达，且污水处理厂（WWTP）影响的站点中，外排泵和ARGs的表达量显著更高，表明人类活动驱动抗性基因的活跃传播。\n此外，微生物还编码微塑料（如 terephthalate）、氟化物等污染物的转化基因。例如，Limnohabitans_A表达PET降解通路的下游基因，Polynucleobacter表达脱卤酶（参与脱氟），且这些基因的表达与城市用地比例正相关，揭示微生物对人为污染的适应性代谢潜力。\n大陆尺度的微生物地理模式 通过Mantel检验与方差分解分析，发现溪流等级（反映河流规模）是微生物组成的最强驱动因素，其影响超过纬度、总碳等传统变量。宏基因组和宏转录组组成均随溪流等级显著变化：基因组丰富度在6级溪流达到峰值，转录组丰富度随等级升高持续增加，表明功能活性的调控机制与基因存在性不同。\n温度也是关键驱动因素，光驱动代谢（如光合系统、视紫红质）的基因表达与流域最高温度显著相关，核心类群（如Methylopumilus）通过光捕获适应温度变化，暗示气候对河流微生物功能的潜在影响。\n微生物群落组成在Omernik生态区和水文单元（HUC）尺度上存在显著分异——干旱草原区与湿润亚热带区的群落结构差异明显，印证了陆地输入对河流微生物的“接种”效应。但功能组成未表现出地理分异，表明分类水平的变化被功能冗余补偿，这为跨区域的微生物管理指标开发提供了依据。\n河流连续体概念的功能扩展 河流连续体概念（RCC）预测：随河流规模增大，陆地输入影响减弱，生物多样性先增后减。本研究首次将RCC扩展至微生物功能层面：\n多样性模式：基因组丰富度在6级溪流达峰，符合RCC中“中等规模河流生物多样性最高”的预测；但转录组丰富度随等级升高而增加，反映功能活性对河流规模的独特响应。 碳利用策略：低等级溪流中，微生物高表达聚合物、芳香族化合物降解基因（依赖陆地输入）；高等级河流中，甲基营养基因（如甲醇氧化）表达增强（依赖自生源碳），印证RCC中“陆地碳输入随河流规模降低”的预测。 光代谢梯度：高等级河流中光驱动代谢基因表达显著增加，与RCC中“大型河流光照更充足”的特征一致，且光合/呼吸（P/R）比在6-8级溪流最高，支持RCC的能量流动模型。 研究结论 GROWdb通过众包模式与基因组解析，首次系统揭示了北美河流微生物的功能多样性与地理驱动机制，其创新点包括：（1）建立首个跨大陆尺度的河流微生物基因组资源，填补分类与功能研究的缺口；（2）阐明微生物对新兴污染物的代谢潜力，为水质监测提供生物标志物；（3）验证RCC在微生物功能层面的适用性，为生态预测模型提供框架。\n未来研究可基于GROWdb探索：（1）长期气候变化对河流微生物功能的影响；（2）污染物转化基因的水平转移机制；（3）跨大陆河流微生物的对比分析。作为开放数据库，GROWdb为 watershed 预测模型与微生物组管理实践提供了基础，助力应对水资源可持续性与环境变化的挑战。\n","date":"2025-07-29T00:00:00Z","image":"https://jb-cao.github.io/Cao-blog/p/25-nature-2/images/2-1-2_hu_6c1a6873640a2093.png","permalink":"https://jb-cao.github.io/Cao-blog/p/25-nature-2/","title":"25年最新的一些Nature环境微生物研究文章（2）"},{"content":"学习一些2025年最新的Nature环境微生物研究文章，了解一下当前较新的研究思路和方法。\nEzzat, L., Peter, H., Bourquin, M., Busi, S.B., Michoud, G., Fodelianakis, S., Kohler, T.J., Lamy, T., Geers, A., Pramateftaki, P., et al. (2025). Diversity and biogeography of the bacterial microbiome in glacier-fed streams. Nature, 1–9. https://doi.org/10.1038/s41586-024-08313-z. 这篇文章采样贡献很大，全球尺度的，然后冰川补给溪流（Glacier-fed Streams, GFSs）在讲故事时和气候变化联系起来，还有一些生态方面的讨论，最终也是没有做实验发表在Nature上。\n冰川补给溪流中细菌微生物组的多样性和生物地理学 气候变化正以前所未有的速度改变着地球的生态系统，其中山地冰川的快速融化尤为显著。冰川补给溪流（Glacier-fed Streams, GFSs）作为受冰川融化直接影响的生态系统，正面临着深刻的变革。GFSs 是寒冷、寡营养且不稳定的生态系统，其中生命主要由微生物生物膜主导。然而，在过往很长一段时间里，我们对 GFSs 微生物组的了解犹如雾里看花，极为匮乏。这种认知的不足严重阻碍了我们准确理解其对冰川退缩的响应机制。因此，开展一项全面且系统的全球范围调查，揭示 GFSs 微生物群的生物多样性和生物地理分布特征，以及驱动其形成的生态和进化过程，显得尤为迫切。这不仅有助于我们深入认识这一独特生态系统的内在运行规律，更能为应对气候变化对 GFSs 生态系统的影响提供关键的科学依据。\n研究方法 为了达成研究目标，研究团队踏上了一场跨越全球的科研征程。他们从地球上主要山脉的 152 个 GFSs 采集底栖微生物组样本，这其中涵盖了新西兰、俄罗斯高加索、喜马拉雅、帕米尔、天山、非洲、欧洲、阿拉斯加、格陵兰、厄瓜多尔和智利等地的山脉。在采集微生物样本的同时，研究人员还仔细记录了溪流水化学、冰川特性和地理等多方面的互补数据。回到实验室后，运用宏条码和宏基因组学等先进技术对样本进行分析。通过这些技术，能够精准地识别和分析微生物的种类及基因信息。随后，利用基于距离的冗余分析（db - RDAs）和多尺度方差分配等多种模型对数据进行深入挖掘，以探究微生物组组成与环境因素、空间因素之间的复杂关系。\nGFSs 的环境特征 GFSs 拥有一系列独特的环境特征。其水温常年接近冰点，这对大多数生物来说是一个极具挑战性的低温环境。沉积物由于受到冰川融水的强大冲刷力影响，结构松散且不稳定。夏季时，冰川融水携带大量泥沙等颗粒物，使得水体浑浊不堪，光照难以穿透，严重限制了光自养生物的光合作用。而到了冬季，冰和雪的覆盖进一步减少了光照时间和强度，让这里成为一个近乎黑暗的世界。不仅如此，GFSs 整体处于寡营养状态，有机碳和无机营养物质极度匮乏，微生物在这样的环境中面临着食物短缺的严峻考验。不过，不同区域的 GFSs 也存在一定差异，流域地质及相关的沉积矿物学在区域尺度上会对溪流水的地球化学特性产生影响，包括 pH 值和离子组成等，这些因素又会进一步影响微生物的氧化还原反应和生存策略。\n细菌微生物组的特性 研究发现，GFSs 细菌微生物组在分类和功能上与其他冰冻圈微生物组（如冰川冰尘、冰前湖和永久冻土土壤中的微生物组）有着显著差异。从功能潜力来看，基于 KEGG 通路分析，GFSs 微生物组在生物膜形成相关通路方面表现突出，例如分泌系统和双组分系统。这些通路对于细菌在 GFSs 中生存至关重要，它们帮助细菌对抗水流的侵蚀，以及在资源稀缺的环境中更好地获取和利用有限资源。在能量获取和代谢途径上，GFSs 中的细菌展现出了多样化的能力。它们能够在春季和秋季藻类渗出物脉冲期间，通过氨基酸、糖类和异生物质化合物的降解以及硫和氮代谢等途径，抓住短暂的资源丰富期，为自身的生存和繁衍积累能量。\n生物多样性模式 在全球多样性方面，研究人员在 GFSs 中发现了跨越 44 个门的细菌，其中存在大量未分类的物种，这表明 GFSs 中蕴含着丰富的未知细菌多样性。尽管 GFSs 资源可用性低，但令人意外的是，其 alpha 多样性指标（观察到的丰富度和 Shannon H 值）介于其他冰冻圈生态系统和全球分布土壤之间，这意味着 GFSs 沉积物能够支持与这些系统相似水平的细菌多样性。进一步研究发现，ASV 丰富度随海拔升高和冰川覆盖度增加而降低，然而功能多样性却并未遵循这一海拔梯度变化规律，这可能是由于冰川影响下复杂且独特的环境选择压力所致。从群落间差异来看，GFSs 细菌微生物组的 β 多样性在山脉内部和之间均较高，细菌组成呈现出明显的生物地理格局。南方和北方半球间的细菌组成存在显著分离，不同山脉间的聚类也十分明显，这种差异主要是由众多指示 ASV 驱动的。但有趣的是，功能组成的空间格局并不明显，这暗示着 GFSs 细菌微生物组的结构与功能潜力可能存在解耦现象。\n微生物组的特异性与核心 研究深入探究了 GFSs 细菌微生物组的特异性。通过严谨的数据预处理和去噪方法，确定了 62.2% 的 ASVs 为山脉特异性，尽管它们的相对丰度较低，仅占 9.0%，但对 beta 多样性的贡献却高达 20.9%，这充分凸显了它们在整体 GFSs 细菌生物多样性中的重要地位。此外，25.2% 的 ASVs 被认定为 “独特” 的，即仅在一个 GFSs 的多个沉积样本中发现，其中 6.4% 的独特 ASVs 出现在某一特定 GFSs 的所有沉积样本中。这种特异性在不同地区的分布并不均匀，新西兰南阿尔卑斯山和厄瓜多尔安第斯山脉的特异性最高，这一现象符合岛屿生物地理学理论，深刻反映了空间隔离、选择压力及长期气候稳定性对物种形成和特有性的重要影响。尽管 GFSs 细菌微生物组存在高度的山脉间及内部相异性，但研究人员还是成功识别出 165 个核心 ASVs，它们仅占总 ASVs 数量的 0.42%，但相对丰度却达到了 28.3%。这表明即使是在小核心微生物组中，也存在着相对丰富的分类单元。这些核心分类单元在竞争中可能具有明显优势，并且与特定和指示 ASVs 在分类学上存在重叠，主要由假单胞菌门、拟杆菌门、疣微菌门以及丛毛单胞菌科、甲基嗜菌科和几丁质杆菌科主导，在属水平上则以甲基营养菌属、极单胞菌属和红游动菌属为主。这些属不仅在 GFSs 中广泛存在，在其他冰冻圈生态系统中也能发现它们的身影，彰显了它们强大的适应极端环境的能力。\n微生物组组成的驱动因素 GFSs 微生物组在空间上呈现出明显的结构化特征，距离衰减模式（DDPs）清晰可见，这表明即使在相距遥远的 GFSs 之间，也存在着系统发育相似的类群，反映出少数分类单元在其中占据主导地位。通过基于距离的冗余分析（db - RDAs）和多尺度方差分配等分析手段，研究揭示了 GFSs 细菌微生物组组成的 54.9% 可被解释，其中空间过程（地理隔离和扩散限制）对 β 多样性的影响占比高达 23.6%，而纯且空间结构化的环境过程占 15.4%，这有力地强调了地理隔离和扩散限制在塑造 GFSs 微生物组结构中的关键作用。此外，流域地质与大气过程对 GFSs 细菌的影响也不容忽视，这进一步说明了地球多样性（地质、地貌和水文过程）在山区生物多样性形成中扮演着重要角色。与 GFSs 细菌组成相比，其功能潜力（以 KOs 表示）并未显示出强烈的生物地理模式，这在一定程度上支持了群落层面功能冗余的观点，但仍需要更多的研究，特别是借助蛋白质组学等技术，深入探讨细菌基因组的进化变化如何影响其功能冗余，以进一步验证这一结论。\n微生物组的系统发育地理 对 GFSs 细菌微生物组的系统地理学分析，为我们揭示了其进化和生态特征中确定性与随机性装配过程的作用。研究明确指出，扩散限制是最主要的装配过程，在群落对中占比高达 59.4%，其次是生态漂变（30.0%）和同质选择（11.7%）。扩散限制不仅广泛影响系统发育树上的多个支系，而且在每个山脉范围内，其对相对丰度的贡献约为 45.4%。受同质选择影响的支系在不同山脉间的贡献差异较大，例如在高加索山脉和新西兰分别贡献了 43.9% 和 30.4% 的相对丰度，而在智利安第斯山脉和西南格陵兰则分别为 16.6% 和 18.8%。这些支系中既包含全球分布的甲基营养菌属和极单胞菌属，也有较少见的皮雷拉属和铁细菌属。尽管同质环境选择的作用在地理距离上保持相对稳定，但在同一山脉内，随着地理距离的增加，扩散限制的重要性愈发凸显。此外，β 多样性主要发生在系统发育树末端密切相关的类群间，一些属存在微多样性，这种微多样性对生态位空间的优化以及生物地理格局的形成都有着重要贡献。\n研究结论 这项研究全面而深入地揭示了 GFSs 细菌微生物组在分类和功能上的独特性，以及其高度的区域特异性和局部独特性。其结构主要受扩散限制和环境选择的双重影响，核心微生物组虽小但相对丰富。生物地理格局的形成源于少数优势但微多样的类群内变化，功能冗余可能是细菌应对环境波动的重要策略。然而，令人担忧的是，随着全球气候变暖，冰川退缩的速度不断加快，这一独特的微生物组正面临着前所未有的威胁。许多特定的 ASV 可能会因为环境的改变而消失，这将对 GFSs 生态系统的结构和功能产生深远影响。因此，本研究不仅为我们理解 GFSs 生态系统中的微生物提供了全新的视角，更为未来针对正在消失的 GFSs 生态系统的气候变化微生物学研究提供了宝贵的全球性参考，也为保护这一脆弱的生态系统敲响了警钟，呼吁我们尽快采取行动，探索其遗传潜力，以应对气候变化带来的挑战。\n","date":"2025-07-28T00:00:00Z","image":"https://jb-cao.github.io/Cao-blog/p/25-nature/images/1-1-1_hu_64b80afcaa240a91.png","permalink":"https://jb-cao.github.io/Cao-blog/p/25-nature/","title":"25年最新的一些Nature环境微生物研究文章（1）"},{"content":"Introduction 最近有审稿人的comments中建议阅读大佬Susan Holmes (2014) 的经典论文《Waste Not, Want Not: Why Rarefying Microbiome Data Is Inadmissible》，参考在自己的分析中。这篇文章深入探讨了微生物组数据分析中常用的稀释（rarefying）方法的缺陷，并提出了更合适的统计模型。虽然这篇文章已经发表了10多年，但其观点仍然具有重要的参考价值。\n🌱 微生物组测序的统计挑战 高通量 DNA 测序技术让微生物组研究进入爆发期。通过测定来自不同环境或样本（如人体肠道、土壤、水体）的 16S rRNA 序列或宏基因组原始读数，研究者可以获得一个 OTU（操作分类单位，又可视作微生物“物种”）在各样本中的丰度矩阵。\n但一个关键问题是：不同样本之间测序深度存在显著差异——每个样本的读数（library size）可能相差一个数量级。这样直接比较 OTU 计数会导致误导。为此，研究者常用两种“归一化”方式：\n按比例（proportion）处理：将各 OTU 计数除以总读数。 稀释抽平（rarefying）：随机抽取每个样本相同数量的读数（即归到最小 library size）。 然而，McMurdie 和 Holmes 指出，这两种方法都存在严重统计缺陷。作者主张，应该使用更先进的统计模型，比如基于负二项分布的差异表达分析方法（edgeR、DESeq），这些方法能更好地处理 library size 差异和数据方差结构。\n稀释法的两个主要问题 损失统计能力（statistical power） 论文通过例子演示了 rarefying 带来的信息损失，例如样本 B 从 1000 个读数降到 100 后，估计微生物丰度比例的方差显著增加，导致对显著性差异的检验能力下降。即使两个样本在真实生态差异上有明显变化，稀释后信号可能被掩盖。\n丢弃样本 在 rarefying 流程中，通常设定一个最小读数阈值，低于阈值的样本被剔除。例如，如果用 500 读数标准化，而一个 sample 只有 300，则该 sample 会被完全删除。论文中指出，这可能导致有效样本被剔除，从而降低聚类分析或差异检测的结果质量。\n替代方案：基于负二项分布的混合模型 论文提出将微生物组计数数据视作负二项分布（Negative Binomial, NB）的一种表现：\n样本 j 的总体读数可视为 Poisson 随机变量。 OTU i 在样本 j 的计数$K[i,j] ~ NB(mean = s_j × μ_i, dispersion = φ_i)$，其中$s_j$ 是 library size 缩放因子，$μ_i$ 是 OTU 的相对丰度，$φ_i$ 捕捉 biological variability 和过度离散性。 这种模型有三个优点：\n统计理论支持：standard 方法来自 RNA-Seq 领域（edgeR、DESeq）。 变异估计更准确：考虑方差随着丰度增长而变化，避免样本深度不同导致的 heteroscedasticity。 没丢样本：所有样本保留，避免信息丢失。 此外还提及另一种方法，zero-inflated Gaussian 模型（metagenomeSeq），适合候选 OTU 零计数很多的情况，但在生物重复较少时假阳性率仍然较高。\n模拟实验 McMurdie 和 Holmes 为了系统地评估不同归一化和统计分析方法的性能，精心设计了两类模拟实验，分别聚焦于 样本聚类准确性 与 差异丰度检出能力。这些实验通过真实数据构造，并在可控的干预条件下测试各方法的稳健性与准确度，具有非常强的说服力。\nA:样本聚类的准确性（Clustering Accuracy） 作者从真实的微生物组数据集中（如“soil”和“ocean”数据）选取样本，构建两个组成明显不同的样本群体，并在这些群体中模拟不同的测序深度（library size），例如一个样本有 10,000 reads，而另一个只有 1,000 reads，反映现实中常见的不平衡情况。\n接着，他们使用不同的归一化方式处理这些样本，包括：\n稀释（rarefying）：所有样本统一稀释至相同深度。 比例归一化（proportions）：每个 OTU 相对其样本总数转换为相对丰度。 基于模型的方法（edgeR / DESeq）：使用负二项分布估计归一化因子并建模。 metagenomeSeq：使用零膨胀正态模型（zero-inflated Gaussian）。 归一化后，再对 OTU 表进行距离计算（Bray-Curtis 或 UniFrac），最后进行聚类（如 PAM 或 hierarchical clustering）以观察样本是否能准确归类。\n稀释法准确率最低，尤其当稀释程度较高（即大部分样本初始 read 数远高于稀释阈值）时，稀释过程导致数据大幅减少，聚类准确率明显下降； 比例归一化方法略好但仍不稳定，尤其在物种丰富度差异大时，常低估丰度低但重要的 OTU； edgeR 和 DESeq 准确率最高且最稳定，能有效识别样本之间真实的结构差异； metagenomeSeq 表现介于中间，在某些条件下表现尚可，但 replicates 少时不稳定。 这说明：基于模型的方法不仅能保留样本完整性，还能在复杂多变的测序深度下维持稳定的聚类表现。\nB:差异丰度检测能力（Differential Abundance Detection） 作者构建了一个 OTU 表，其中一部分 OTU 被设定为“差异丰度 OTU”——它们在组 A 与组 B 中的丰度存在系统性差异（如增加 2 倍或 5 倍），而其余 OTU 丰度一致不变。\n通过不同方法处理这些数据并检测差异 OTU，然后使用 ROC 曲线和 AUC（Area Under Curve） 来衡量每种方法检出真实差异 OTU 的能力与假阳性控制水平。\nedgeR 与 DESeq 明显优于其他方法，具体表现为：\nAUC 高达 0.95–0.98，说明检出真正差异 OTU 的能力极强； 假阳性率控制良好，尤其在样本数较多时尤为明显； 稀释法表现最差，不仅灵敏度低（漏检多），而且假阳性率高，尤其当稀释阈值较低时更严重； metagenomeSeq 在 replicates 较多时接近 edgeR，但在 n=2~3 样本时性能急剧下降。 此外，作者强调，稀释法带来的最大问题是“有效样本数的减少”——本来可以使用 10,000 个 reads 做差异分析，稀释后只剩 1,000 个，等效于用更小的样本重复去估计参数，导致功效大幅下降。\nMcMurdie \u0026amp; Holmes 在文中总结如下：\n明确反对 rarefying：既浪费数据又带来分析偏差，是 inadmissible 的 normalization 方法。 推荐基于统计混合模型的方法：借用 RNA-Seq 的 edgeR、DESeq，甚至 metagenomeSeq。作者还将这些方法整合进 R 包 phyloseq 中，方便微生物组分析。 树立统计意识：研究者应理解 library size、overdispersion 的本质，并采用合适的 GLM（Generalized Linear Model）模型或经验贝叶斯方法，而不是简单采样。 这篇论文自 2014 年发布后对微生物组数据分析流程影响深远：\n推动了差异丰度分析方法的演进，例如 ANCOM、ALDEx2、Songbird 等工具开始强调 compositional data 和统计模型。 2024 年，Schloss 又在 mSphere 中重访 rarefying，提出一些更新观点，可视为对这篇论文的回应和延伸。 微生物组数据本质是成分数据（compositional），总和约束 → 需要特殊方法处理，而 NB 模型正是合理起点之一。 References McMurdie, P.J., and Holmes, S. (2014). Waste not, want not: why rarefying microbiome data is inadmissible. PLOS Comput. Biol. 10, e1003531. https://doi.org/10.1371/journal.pcbi.1003531. ","date":"2025-07-24T00:00:00Z","image":"https://jb-cao.github.io/Cao-blog/p/rarefaction-10/images/fig1_hu_9754129a0f2d8408.png","permalink":"https://jb-cao.github.io/Cao-blog/p/rarefaction-10/","title":"有关Rarefaction的探讨，一篇10年前的文章"},{"content":"Introduction 在现代社会，人们平均有超过90%的时间在室内度过——无论是家中、办公室，还是学校或医院。然而，我们很少意识到，这些封闭空间并非“无菌”环境，而是充满了肉眼看不见的微生物群落，它们构成了复杂的室内微生物组（Indoor Microbiome）。\n从地板上的灰尘到空调系统的滤网，从厨房台面到浴室的水龙头，微生物无处不在。它们有些来自人体（如皮肤和肠道菌群），有些通过空气、物品或宠物进入室内，还有些在建筑材料和管道中顽强生存。近年来，科学研究逐渐揭示，这些微小的生命不仅影响我们的健康——从免疫系统的发育到过敏和感染的风险——还可能通过“微生物-环境-宿主”的互动，塑造我们的长期福祉。\n随着城市化进程加速和建筑密闭性提高，室内微生物组的平衡变得愈发重要。本文介绍一些关于室内微生物组的研究进展，探讨它们对人类健康的潜在影响。\n室内微生物组与健康 Gilbert, J.A., Hartmann, E.M. The indoors microbiome and human health. Nat Rev Microbiol 22, 742–755 (2024). https://doi.org/10.1038/s41579-024-01077-3\n先看一篇比较新的发表在《Nature Reviews Microbiology》的综述文章对室内微生物有个整体的概念。这篇文章探讨了建筑环境——人类大部分时间居住的地方——的微生物生态对免疫、内分泌和神经健康的影响，还提出了利用室内微生物组来改善健康的策略。\n室内微生物组 室内微生物组与室外环境存在显著差异，主要受人类活动和建筑特性的影响。室内环境通常干燥且营养匮乏，微生物大多来自人体和环境输入。人类皮肤相关的细菌如葡萄球菌和链球菌在频繁接触的表面占主导，而建筑管道内部则以环境菌为主。不同场所的微生物特征各异：农场家庭富含动物粪便相关菌种，医院环境则常见致病菌如假单胞菌。每个人每小时会向周围释放大量微生物颗粒，使得每个室内空间都形成独特的微生物群落。空气流通和建筑材料选择会显著影响微生物定植，例如厨房台面的微生物组成与居民对食品安全的重视程度相关，而浴室则容易滋生肠道相关菌群。即使在严格消毒的医院，耐甲氧西林金黄色葡萄球菌等病原体仍可能持续存在，凸显了室内微生物管理的重要性。\n室内微生物生态学 要实现健康的室内环境，必须将微生物组研究与室内环境质量概念相结合。早期的研究主要集中于阐述室内空间中的细菌和真菌的分类多样性。随着技术进步，研究者开始对包括古菌和病毒在内的广义微生物多样性进行特征阐述，并探索它们的功能代谢特性。全面了解室内微生物组的真实功能和分类多样性，将使我们更接近实现健康建筑设计的崇高目标。\n抗菌耐药性 室内微生物组中抗菌耐药性基因的分布是一个重要研究领域。多个研究发现抗菌化学品和清洁实践与室内尘埃中的抗菌耐药性基因存在关联。医院环境尤其值得关注，研究表明高流量诊所地面上存在比其他环境更多的临床相关抗菌耐药性基因。患者与环境之间可能存在抗菌耐药性基因的交换，这种现象在新生儿重症监护环境中尤为明显。\n建筑管道系统是另一个值得关注的区域。淋浴软管和喷头中的微生物组受到管道材料类型和水源的影响，而水槽排水口由于接收药物和个人护理产品残留，其抗菌耐药性问题尤为突出。\n细菌和真菌的生存能力和代谢 室内微生物的生存能力和代谢活动受到多种因素影响：\n设计因素：如照明和材料选择会影响微生物种类及其生存时间 湿度条件：不同程度的湿润可以诱导真菌生长，使用\u0026quot;湿润时间\u0026quot;框架可以对其进行定量建模 水的存在：在持续潮湿环境（如建筑管道）中，微生物群落的丰度和多样性受到水流速率的强烈影响 值得注意的是，在遭受湿气问题的建筑物内部，发霉材料与相连空间之间的物理距离会影响表面真菌的分布。实验室模拟中还观察到细菌与真菌之间的代谢互动。\n病毒和古菌 病毒动态： 托儿所的病毒组呈现季节性变化，冬季以人源病毒为主 病毒来源多样，包括人类、宠物、植物及外部环境 噬菌体在调节细菌群体方面具有重要作用，可能成为控制耐药菌的工具 古菌特征： 传统检测方法可能低估了古菌存在 最新研究表明古菌确实存在于室内尘埃中，且可能具有生存能力 产甲烷古菌等严格厌氧菌在特定条件下仍可在室内传播 人类与建筑之间的微生物交换 人类是室内微生物的主要来源：\n新医院研究表明高接触环境中皮肤相关微生物占主导 这一现象在其他环境（飞机舱、交通系统等）中也得到证实 研究显示健康成人的微生物组也会受到建筑环境的影响 肠道来源的严格厌氧菌（包括某些古菌）在特定条件下仍可在室内存活 这些发现突显了人-环境微生物交换的双向性，为健康建筑设计提供了重要依据。\n室内微生物组对人类健康的影响 室内微生物组通过多种途径影响人类健康。微生物暴露不仅可能导致感染性疾病，还会影响免疫系统发育，并与多种慢性疾病的发生发展相关。城市化进程带来的微生物多样性降低，可能与抑郁症、肥胖、过敏性疾病等健康风险的增加存在关联。\n感染性疾病 建筑环境在疾病传播中扮演重要角色，这在COVID-19大流行中得到充分印证。医院获得性感染尤其值得关注，其本质是患者、医护人员与医院微生物环境互动的结果。值得注意的是，某些常见共生菌（如金黄色葡萄球菌）在医院环境中可能演变为耐药菌株（如MRSA）。消毒剂和抗菌材料的广泛使用可能通过选择压力促进耐药性的产生，这一现象在家庭环境中同样存在。儿童因免疫系统发育不完善，更容易受到环境病原体的影响。\n代谢性疾病 城市化带来的生活方式改变显著影响了人类微生物组。肠道菌群通过调节能量代谢和脂肪储存，在肥胖发生中起关键作用。研究表明，户外活动时间的减少和自然环境接触的匮乏，可能导致肠道菌群多样性下降，进而增加代谢疾病风险。虽然直接证据有限，但室内微生物多样性降低可能是推动肥胖流行的重要因素之一。\n心理健康 建筑环境可能通过\u0026quot;肠-脑轴\u0026quot;影响心理健康。现代建筑环境中微生物暴露模式的改变，加上城市生活压力，可能导致肠道菌群失调，进而影响神经递质产生、诱发炎症反应，最终增加抑郁和焦虑风险。这一领域的研究尚处于起步阶段，但已显示出微生物-神经-免疫互作的重要性。\n过敏性疾病 著名的\u0026quot;卫生假说\u0026quot;为理解微生物暴露与过敏的关系提供了框架。阿米什人与赫特莱特儿童的对比研究显示，丰富的农场微生物暴露可显著降低哮喘风险。室内环境中的微生物代谢产物（如脂多糖）通过调节Th1/Th2免疫平衡影响过敏发生。生命早期接触特定细菌（如厚壁菌门）对预防过敏至关重要，而建筑潮湿等问题可能促进致敏微生物的生长。\n这些发现突显了建筑环境设计在维护健康方面的重要性，需要平衡感染防控与有益微生物暴露的关系。\n创建健康建筑 在建筑创新浪潮中，\u0026ldquo;健康建筑\u0026quot;理念正成为连接人居环境与生态健康的重要纽带。这一理念超越了传统建筑标准，将微生物组管理纳入整体设计框架，创造性地平衡了健康效益与可持续性目标。\n现代健康建筑通过三大核心要素重塑人居环境：\n生物友好设计：采用透气性建材和动态通风系统，促进有益微生物定植 智能调控系统：实时监测温湿度等参数，优化微生物生长条件 自然融合设计：通过垂直绿化和室内园艺增加环境微生物多样性 尽管前景广阔，健康建筑的推广仍面临显著障碍：\n成本瓶颈：初期建设费用比传统建筑高出15-30% 改造难题：现有建筑结构限制创新技术的整合应用 标准缺失：全球范围内缺乏统一的微生物安全评估体系 前沿研究正在探索三种突破性干预路径：\n城市再野化 通过立体绿化系统和生态走廊设计，将自然微生物群落引入城市空间。研究显示，接触多样化环境微生物可使儿童过敏风险降低40%。\n活性建材开发\n3D打印生物材料成功包埋枯草芽孢杆菌孢子 智能水凝胶材料可特异性激活对抗病原菌 自修复混凝土利用微生物矿化作用延长建筑寿命 微生物组精准调控 益生菌清洁剂重建表面微生物平衡 噬菌体涂层有效控制医院耐药菌传播 空气循环系统选择性富集有益气溶胶微生物 随着合成生物学进步，下一代健康建筑可能实现：\n动态响应型微生物群落调控 个性化微生物环境定制 建筑-人体微生物组双向调节 这种创新范式正在重新定义建筑与健康的边界，为城市化进程中的公共卫生挑战提供全新解决方案。尽管仍需克服技术标准化和长期安全性评估等障碍，健康建筑已展现出改变人类生活方式的巨大潜力。\n住宅区四季室内外空气微生物组 Indoor/outdoor airborne microbiome characteristics in residential areas across four seasons and its indoor purification (2024). Environ. Int. 190, 108857. https://doi.org/10.1016/j.envint.2024.108857.\n发表在Environment International（IF=9.7）的一篇文章，这个研究系统调查了中国广州6个典型住宅区室内外空气微生物组在四季中的分布特征、影响因素及健康风险，并评估了空气净化器的去除效果。研究通过高通量测序和培养方法，揭示了微生物群落结构、粒径分布及其与环境因素的关联。\n核心发现 微生物浓度与粒径分布 季节性差异：夏季微生物浓度最高（细菌64-905 CFU/m³，真菌4-580 CFU/m³），冬季PM2.5浓度最高（室内68.42μg/m³）。 粒径特征：74.6%的微生物为可吸入颗粒（\u0026lt;4.7μm），其中1.1-4.7μm占比最高（秋季达87.5%），易沉积于肺泡区。 微生物群落组成 优势菌群：室内外均以Anoxybacillus（细菌）和Cladosporium（真菌）为主，后者冬季占比高达65.8%。 功能预测：室内微生物含人类肠道相关基因，且医院环境中耐药基因（如MRSA）丰度显著高于其他场所。 环境驱动因素 关键关联：温度与Peanibacillus正相关（r\u0026gt;0.6, p\u0026lt;0.05），PM2.5促进Stenotrophomonas生长；臭氧（O₃）影响细菌代谢。 来源解析：中性模型显示细菌扩散随机性高于真菌（R²=0.694-0.846），秋季随机分布最显著。 健康风险 暴露评估：儿童吸入剂量（ADD）高于成人，秋季风险最高；但危害商数（HQ）均\u0026lt;1，属可接受范围。 致病潜力：检出机会致病菌如Rhodococcus（肺脓肿）和Stenotrophomonas（耐药性强）。 净化效果 空气净化器：对1.1-4.7μm细菌去除率最高（秋季达49.4%），革兰阴性菌去除优于阳性菌；但对真菌效果有限。 研究意义与局限 实践价值：为湿热气候区住宅微生物污染控制提供数据支持，建议结合通风与净化策略。 创新点：首次系统量化净化器对微生物粒径选择性去除效应。 局限性：样本量较小（6个住宅），未考虑居民行为对微生物的直接影响。 室内空气微生物的高度分辨率分析 Shen, F., Wang, M., Ma, J., Sun, Y., Zheng, Y., Mu, Q., Li, X., Wu, Y., and Zhu, T. (2024). Height-resolved analysis of indoor airborne microbiome: comparison with floor dust-borne microbiome and the significance of shoe sole dust. Environ. Sci. Technol. 58, 17364–17375. https://doi.org/10.1021/acs.est.4c06218.\n发表在Environmental Science \u0026amp; Technology（IF=11.3）的一篇文章，通过创新的被动采样方法，系统分析了室内空气中微生物群落在不同高度（天花板附近H1、成人呼吸高度H2、地面附近H3）的垂直分布特征，并与地板灰尘微生物组进行比较。研究首次量化了鞋底灰尘对室内空气微生物的贡献，揭示了传统地板灰尘样本作为空气微生物替代指标的局限性。\n核心发现 空气微生物的垂直分层现象 多样性梯度：细菌和真菌的α多样性（如Chao1指数）随高度降低而增加（H1\u0026lt;H2\u0026lt;H3），但香农指数无显著差异，表明物种分布不均匀。\n群落差异：细菌在H1与H3间存在弱分层（ANOSIM R=0.07），真菌分层更明显（R=0.18）。中高度（H2）细菌群落变异最大，可能与人类活动扰动相关。\n空气与地板灰尘微生物组的显著差异 组成差异：空气中以变形菌门（41.4%）为主，地板灰尘中厚壁菌门（31.4%）更丰富。芽孢杆菌属（空气）与葡萄球菌属（灰尘）分别为优势菌。\n功能差异：空气微生物代谢相关基因（如脂质代谢、异生物质降解）更活跃，而灰尘微生物的遗传信息处理通路更丰富（图5）。\n鞋底灰尘的关键作用 贡献量化：鞋底灰尘贡献4%空气细菌和14%空气真菌，与地板灰尘贡献相当（细菌4.3% vs 真菌12.6%）。对地板灰尘的贡献更高（细菌25.5%、真菌52.7%）。\n生态过程：随机过程（如扩散限制）主导微生物群落构建（\u0026gt;80%），鞋底灰尘通过漂变过程（drift）显著影响真菌群落（贡献79%）。\n健康暴露启示 采样方法革新：矿物油被动采样器实现长期连续采样，克服传统主动采样噪音干扰，更贴近真实暴露场景。 风险评估：地板灰尘不能准确代表可吸入微生物，需开展高度分辨研究（如儿童爬行区与成人呼吸区差异）。 创新点与局限 方法创新：\n首次采用多高度同步被动采样 建立鞋底灰尘贡献的定量模型（FEAST算法） 实际意义：\n为\u0026quot;再野化\u0026quot;室内微生物组提供新思路（通过鞋底引入有益环境微生物） 提示需关注鞋底作为病原传播载体的风险 研究局限：\n未比较主动/被动采样器的捕获效率 样本量较小（5个场所） 未评估室外空气影响 新加坡食品中心微生物组 Teo, J.J.Y., Ho, E.X.P., Ng, A.H.Q., How, S.H.C., Chng, K.R., Ateş, Y.C., Fau’di, M.T., Aung, K.T., and Nagarajan, N. (2024). City-wide metagenomic surveillance of food centres reveals location-specific microbial signatures and enrichment of antibiotic resistance genes. Preprint at medRxiv, https://doi.org/10.1101/2024.07.28.24310840 https://doi.org/10.1101/2024.07.28.24310840.\n这项研究首次对新加坡16个食品中心(又称小贩中心)进行了城市规模的宏基因组监测(n=240样本)，旨在了解这些高人流环境中微生物(细菌、古菌、真菌、病毒)和非微生物DNA的分布特征。食品中心作为亚洲许多大城市主要的食品消费场所，其微生物组成可能对公共卫生有重要影响，特别是在全球食源性和污染物相关疾病发病率上升的背景下。研究重点关注了食品中心特有的微生物特征、抗生素抗性基因(ARGs)的富集情况，以及与食品相关的微生物特征。\n研究团队在两个时间点(2019年3月和2022年7月)采集了样本，采用MetaSUB协议对食品中心桌面进行拭子采样，使用Isohelix DNA Buccal Swabs收集样本。DNA提取后进行了深度shotgun宏基因组测序(平均每样本2000万reads)。数据分析使用了Kraken 2和Bracken进行分类分析，并采用多种统计和机器学习方法进行特征分析。\n主要发现 食品中心特有的微生物特征 研究发现食品中心宏基因组中富含与食品相关的DNA特征，这些特征可以部分解释观察到的微生物谱(解释了44%的变异)。研究发现了特定的食物-微生物关联，如肠杆菌科与鱼类之间的关联。\n位置特异性微生物特征 通过机器学习分析，研究确定了22种微生物物种可以作为不同食品中心高度准确(\u0026gt;80%)的位置特异性标志，其中一些标志在3年后仍然存在。这些标志性微生物的平均相对丰度为4.5%，表明它们是宏基因组中的非优势物种。\n抗生素抗性基因富集 食品中心显示出相对于其他非医疗环境(\u0026gt;2.5倍)和医院环境(某些病原体高出1个数量级)的抗生素抗性基因(ARGs)富集。特别是，粘菌素抗性在食品中心最为富集(\u0026gt;1.5倍)。\n病原体富集情况 研究发现了高优先级ESKAPE病原体(如肺炎克雷伯菌、肠杆菌属等)在食品中心显著富集(\u0026gt;3倍)，甚至比医院环境还要高。\n这项研究首次大规模应用shotgun宏基因组方法对食品中心环境进行监测，证明了该方法在追踪环境中微生物和相关关注基因方面的实用性。研究发现食品中心具有独特的微生物特征，这些特征既反映了食品来源的变化，也反映了地理位置和相关环境因素的影响。研究结果强调了食品中心环境作为抗生素抗性监测重要节点的公共卫生意义，并为未来旨在降低感染风险的各种清洁和行为干预策略研究提供了基础。\nReferences Gilbert, J.A., Hartmann, E.M. The indoors microbiome and human health. Nat Rev Microbiol 22, 742–755 (2024). https://doi.org/10.1038/s41579-024-01077-3 Indoor/outdoor airborne microbiome characteristics in residential areas across four seasons and its indoor purification (2024). Environ. Int. 190, 108857. https://doi.org/10.1016/j.envint.2024.108857. Shen, F., Wang, M., Ma, J., Sun, Y., Zheng, Y., Mu, Q., Li, X., Wu, Y., and Zhu, T. (2024). Height-resolved analysis of indoor airborne microbiome: comparison with floor dust-borne microbiome and the significance of shoe sole dust. Environ. Sci. Technol. 58, 17364–17375. https://doi.org/10.1021/acs.est.4c06218. Teo, J.J.Y., Ho, E.X.P., Ng, A.H.Q., How, S.H.C., Chng, K.R., Ateş, Y.C., Fau’di, M.T., Aung, K.T., and Nagarajan, N. (2024). City-wide metagenomic surveillance of food centres reveals location-specific microbial signatures and enrichment of antibiotic resistance genes. Preprint at medRxiv, https://doi.org/10.1101/2024.07.28.24310840 https://doi.org/10.1101/2024.07.28.24310840. ","date":"2025-07-16T00:00:00Z","image":"https://jb-cao.github.io/Cao-blog/p/indoor/images/ind3_hu_b2111ccb06092ddc.png","permalink":"https://jb-cao.github.io/Cao-blog/p/indoor/","title":"室内微生物组相关研究"},{"content":"Introduction 微生物组研究的一个核心问题是识别与特定表型（如健康状况或环境条件）相关的微生物特征。然而，微生物组数据具有稀疏性、组成性和异方差性等特点，使得统计分析面临巨大挑战。近期发表在bioRxiv上的论文《MaAsLin 3: Refining and extending generalized multivariable linear models for meta-omic association discovery》提出了一个强大的解决方案。\nMaAsLin 3文章简介 MaAsLin3 (Microbiome Multivariable Associations with Linear Models) 是哈佛大学Huttenhower C.大佬团队开发的微生物组多变量关联分析R包工具，相比前代主要有三大突破：\n同时检测丰度和存在性关联 传统方法只能检测微生物相对丰度的变化 MaAsLin 3通过分步建模，分别检测： 存在/缺失（Prevalence） 非零时的丰度变化（Abundance） 创新的组成性校正方法\n通过中位数系数比较策略推断绝对丰度变化 支持实验性绝对定量数据（如spike-in） 扩展的分析能力\n支持混合效应模型 新增有序预测变量分析 支持特征特异性协变量（如宏转录组中的DNA丰度） 性能表现 在模拟数据测试中，MaAsLin 3展现出显著优势：\n在50个以上样本时F1分数最高 平均精确度≥0.82，优于同类工具 系数估计偏差最小（仅-12%） 在IBD研究中的新发现 应用MaAsLin 3分析HMP2炎症性肠病(IBD)数据库时发现：\n77%的显著关联是存在性（而非丰度）变化 确认了成人IBD中Enterocloster spp.的富集 首次发现Dysosmobacter welbionis在IBD中的存在性降低 实际应用建议 数据类型选择：\n优先使用spike-in或qPCR绝对定量数据 相对丰度数据需启用中位数校正 模型设定：\n1 2 3 4 5 6 7 8 # 基础模型 maaslin3( input_data = features, input_metadata = metadata, normalization = \u0026#34;TSS\u0026#34;, transform = \u0026#34;LOG\u0026#34;, analysis_method = \u0026#34;LM\u0026#34; ) 结果解读：\n关注q-value\u0026lt;0.1且|β|\u0026gt;1的关联 区分丰度与存在性变化的生物学意义 使用教程 官方教程：https://github.com/biobakery/biobakery/wiki/MaAsLin3\n安装MaAsLin 3 最新开发版的MaAsLin 3可通过devtools工具包从GitHub安装。\n稳定版MaAsLin 3可通过BiocManager安装：\n1 2 3 4 if (!require(\u0026#34;BiocManager\u0026#34;, quietly = TRUE)) install.packages(\u0026#34;BiocManager\u0026#34;) BiocManager::install(\u0026#34;remotes\u0026#34;) BiocManager::install(\u0026#34;biobakery/maaslin3\u0026#34;) 运行前需加载依赖库：\n1 2 3 for (lib in c(\u0026#39;maaslin3\u0026#39;, \u0026#39;dplyr\u0026#39;, \u0026#39;ggplot2\u0026#39;, \u0026#39;knitr\u0026#39;, \u0026#39;kableExtra\u0026#39;)) { suppressPackageStartupMessages(require(lib, character.only = TRUE)) } 使用MaAsLin 3进行微生物组关联分析 运行MaAsLin 3需要提供以下数据：\n样本特征丰度表（需保留零值） 样本元数据表 指定元数据与特征存在率（特征出现概率）及丰度（存在时的数量级）关系的公式或固定效应（可添加随机效应） 输出结果包括：\n关联分析表（含每个特征-元数据组合的效应量及p值） 可视化文件夹（含显著关联的摘要图及诊断图） 输入文件要求 需准备两个输入文件：\n1.特征丰度数据框\n格式1：列=特征，行=样本 格式2：行=特征，列=样本（转置格式亦可） 特征类型：分类单元或基因（支持相对丰度或绝对计数） 可接受制表符分隔的文件路径 2.元数据数据框\n格式1：列=变量，行=样本 格式2：行=变量，列=样本（转置格式亦可） 变量类型：性别、年龄等 可接受制表符分隔的文件路径 注意事项：\n允许存在仅出现在一个文件中的样本，分析时会自动剔除不匹配样本 两个文件的样本顺序无需一致，程序会自动对齐 含NA值的样本在模型拟合时会被排除，建议在随机缺失假设下预先剔除或使用多重插补处理 示例文件说明： 示例数据来自人类微生物组计划2（HMP2），存放于MaAsLin 3源码的inst/extdata目录或教程文件库：\nHMP2_taxonomy.tsv：物种丰度子集（行=样本，列=物种） HMP2_metadata.tsv：元数据子集（行=样本，列=变量） 数据读取与预处理：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 读取物种丰度表 taxa_table_name \u0026lt;- system.file(\u0026#34;extdata\u0026#34;, \u0026#34;HMP2_taxonomy.tsv\u0026#34;, package = \u0026#34;maaslin3\u0026#34;) taxa_table \u0026lt;- read.csv(taxa_table_name, sep = \u0026#39;\\t\u0026#39;, row.names = 1) # 读取元数据表 metadata_name \u0026lt;- system.file(\u0026#34;extdata\u0026#34;, \u0026#34;HMP2_metadata.tsv\u0026#34;, package = \u0026#34;maaslin3\u0026#34;) metadata \u0026lt;- read.csv(metadata_name, sep = \u0026#39;\\t\u0026#39;, row.names = 1) # 分类变量因子化（用于IBD与健康对照比较） metadata$diagnosis \u0026lt;- factor(metadata$diagnosis, levels = c(\u0026#39;nonIBD\u0026#39;, \u0026#39;UC\u0026#39;, \u0026#39;CD\u0026#39;)) metadata$dysbiosis_state \u0026lt;- factor(metadata$dysbiosis_state, levels = c(\u0026#39;none\u0026#39;, \u0026#39;dysbiosis_UC\u0026#39;, \u0026#39;dysbiosis_CD\u0026#39;)) metadata$antibiotics \u0026lt;- factor(metadata$antibiotics, levels = c(\u0026#39;No\u0026#39;, \u0026#39;Yes\u0026#39;)) # 查看数据结构 taxa_table[1:5, 1:5] 1 2 3 4 5 6 7 8 9 10 11 12 ## Phocaeicola_vulgatus Faecalibacterium_prausnitzii ## CSM5FZ3N_P 0.4265226 0.060255109 ## CSM5FZ3R_P 0.5369584 0.007396904 ## CSM5FZ3T_P 0.5911821 0.000000000 ## CSM5FZ3V_P 0.2661378 0.029680329 ## CSM5FZ3X_P 0.6601039 0.003596740 ## Bacteroides_uniformis Prevotella_copri_clade_A Bacteroides_stercoris ## CSM5FZ3N_P 0.269241131 0.0000e+00 0.000000000 ## CSM5FZ3R_P 0.252604847 0.0000e+00 0.008390958 ## CSM5FZ3T_P 0.000000000 0.0000e+00 0.000000000 ## CSM5FZ3V_P 0.400426526 0.0000e+00 0.000000000 ## CSM5FZ3X_P 0.000880428 1.3081e-05 0.001335669 1 metadata[1:5, 1:5] 1 2 3 4 5 6 ## participant_id site_name week_num reads diagnosis ## CSM5FZ3N_P C3001 Cedars-Sinai 0 9961743 CD ## CSM5FZ3R_P C3001 Cedars-Sinai 2 16456391 CD ## CSM5FZ3T_P C3002 Cedars-Sinai 0 10511448 CD ## CSM5FZ3V_P C3001 Cedars-Sinai 6 17808965 CD ## CSM5FZ3X_P C3002 Cedars-Sinai 2 13160893 CD 运行MaAsLin 3分析 MaAsLin 3的运行需要指定以下参数：\n丰度表（input_data） 元数据表（input_metadata） 输出目录（output） 分析模型（可通过公式或变量向量指定） 模型构建方式\n公式法：\n遵循lme4语法规范，可包含： 固定效应 随机效应 交互项 多项式项 分类变量作为固定效应时，各水平将与首个因子水平对比 支持特殊声明： group(variable_name)：分组预测变量 ordered(variable_name)：有序预测变量 strata(variable_name)：配对样本的条件逻辑回归 向量法：\n通过以下参数指定变量： fixed_effects：固定效应 random_effects：随机效应 group_effects：分组变量 ordered_effects：有序变量 strata_effects：配对变量 注意事项： 需使用列名而非$符号引用变量 分类变量需预先因子化，或通过'变量,参考水平;...'格式指定（如diagnosis,nonIBD;antibiotics,No） 重要建议\n当存在测序深度数据时，应将其作为协变量纳入模型（reads参数），以避免因测序深度差异导致的假阳性关联 HMP2数据实战示例 以下代码演示如何分析微生物物种与IBD诊断的关联，同时控制抗生素使用、年龄和测序深度的影响：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 set.seed(1) fit_out \u0026lt;- maaslin3( input_data = taxa_table, input_metadata = metadata, output = \u0026#39;hmp2_output\u0026#39;, formula = \u0026#39;~ diagnosis + dysbiosis_state + antibiotics + age + reads\u0026#39;, normalization = \u0026#39;TSS\u0026#39;, # 总丰度标准化 transform = \u0026#39;LOG\u0026#39;, # 对数转换 augment = TRUE, # 启用数据增强（解决逻辑回归线性可分问题） standardize = TRUE, # 连续变量Z-score标准化 max_significance = 0.1, # FDR阈值设为0.1 median_comparison_abundance = TRUE, # 丰度系数与中位数比较（应对组成性效应） median_comparison_prevalence = FALSE,# 存在率系数与0比较 max_pngs = 250, # 最大可视化结果数 cores = 1 # 单核运行 ) 关键参数解析\n标准化与转换\nTSS+LOG组合是推荐配置，其他选项详见?maaslin3 统计检验策略\n丰度关联：默认与特征的中位数系数比较（median_comparison_abundance=TRUE），适用于相对丰度数据 存在率关联：默认与0比较（median_comparison_prevalence=FALSE） 适用场景建议\n关闭中位数比较的情况： 研究相对丰度关联 假设总绝对丰度不变时的绝对关联分析 使用spike-in或未标准化丰度数据时 输出控制\n默认输出详细日志，可通过verbosity = 'WARN'减少输出 中位数比较机制详解\n当启用median_comparison时：\n丰度系数：与所有特征在该元数据上的中位数系数对比，抵消组成性效应 仅影响p值/q值计算（除非设置subtract_median=TRUE才会修正系数值） 存在率系数：通常保持与0比较，因其不受组成性影响 该设计确保了：\n相对丰度数据可推断绝对丰度变化 避免因技术偏差（如测序深度）导致的假关联 3.3 MaAsLin 3 输出结果解析\nMaAsLin 3的输出包含数据文件和可视化图表两类，完整示例可参考教程文件库中的HMP2分析结果。\n核心结果文件 1. 显著性关联表 (significant_results.tsv)\n按q值升序列出所有通过显著性检验的关联，字段说明：\n字段 说明 示例值 feature 微生物特征名 Phocaeicola_sartorii metadata 元数据变量名 reads coef 效应量系数 1.095 - 丰度模型：表示元数据每增加1单位，特征相对丰度的2^coef倍变化 - 存在率模型：表示对数几率（log-odds）的变化量 null_hypothesis 零假设值（0或中位数） 0 qval_individual 个体检验FDR校正q值 1.06E-40 qval_joint 联合检验q值（基于Beta(1,2)分布计算） 1.14E-40 model 模型类型（abundance/prevalence） prevalence 完整输出文件结构 数据文件\n文件/目录 内容 all_results.tsv 全量关联结果（含错误信息） features/ 处理后的特征表（过滤→标准化→转换） models_*.rds 模型对象（需save_models=TRUE） residuals_*.rds 模型残差（线性模型为普通残差，逻辑模型为偏差残差） maaslin3.log 完整运行日志（含参数设置与报错信息） 可视化文件\n摘要图 (summary_plot.pdf) 左：系数热图（*表示q\u0026lt;0.1，**表示q\u0026lt;0.01） 右：显著关联的效应量排序图 关联详图 (association_plots/) 连续变量：散点图（丰度）或箱线图（存在率） 分类变量：箱线图（丰度）或网格图（存在率） 图表右上角标注：q值、总样本数、非零样本数 诊断与验证要点 错误排查\n检查all_results.tsv的error列：模型拟合失败会标记错误 启用warn_prevalence=TRUE时，存在率关联可能受丰度影响（需通过可视化验证） 有效性验证\n分类变量：每组至少10个样本（丰度模型）且存在/缺失样本均≥10（存在率模型） 连续变量：通过散点图检查异常值影响 超大系数（|coef|\u0026gt;15）：需验证： 样本量充足（建议样本数≥10×变量数） 元数据无多重共线性 随机效应设置合理 多重检验校正\n默认对所有关联进行FDR校正，若需聚焦特定变量，可单独校正目标p值 结果重绘功能 通过maaslin_plot_results_from_output可重新生成图表（无需原始R对象）：\n1 2 3 4 5 6 # 示例：指定热图与系数图的元数据变量 maaslin_plot_results_from_output( output_dir = \u0026#34;hmp2_output\u0026#34;, heatmap_vars = c(\u0026#34;diagnosis\u0026#34;, \u0026#34;dysbiosis_state\u0026#34;), coef_plot_vars = c(\u0026#34;age\u0026#34;, \u0026#34;reads\u0026#34;) ) 更多高级功能，请查看https://github.com/biobakery/biobakery/wiki/MaAsLin3#4-advanced-topics\nReferences Nickols, W.A., Kuntz, T., Shen, J., Maharjan, S., Mallick, H., Franzosa, E.A., Thompson, K.N., Nearing, J.T., and Huttenhower, C. (2024). MaAsLin 3: refining and extending generalized multivariable linear models for meta-omic association discovery. Preprint at bioRxiv, https://doi.org/10.1101/2024.12.13.628459 https://doi.org/10.1101/2024.12.13.628459. https://github.com/biobakery/biobakery/wiki/MaAsLin3 ","date":"2025-07-02T00:00:00Z","image":"https://jb-cao.github.io/Cao-blog/p/maaslin-3/images/git1_hu_70f47e8701de132.png","permalink":"https://jb-cao.github.io/Cao-blog/p/maaslin-3/","title":"MaAsLin 3：微生物组多变量关联分析"},{"content":"我们实验室经常处理低微生物生物量样本（如宿主相关的呼吸道，阴道等微生物组，或是环境相关的沙子，冻土等微生物组），最近看到Nature Microbiology发表了一篇关于低微生物生物量样本污染的指南。\n发布日期：2025年6月20日 原文：https://doi.org/10.1038/s41564-025-02035-2\n众多重要环境中微生物生物量水平较低，包括某些人体组织、大气环境、植物种子、处理后的饮用水、超干旱土壤以及深层地下环境，部分环境甚至完全不存在常驻微生物群落。这些低微生物生物量环境对基于DNA的标准测序方法提出了独特挑战——当检测工作接近技术极限时，外部污染源的干扰必然成为关键问题。同样地，低生物量样本更容易受到交叉污染的严重影响，适用于高生物量样本的操作流程若直接应用于低微生物生物量样本，很可能导致误导性结果。本共识声明系统阐述了降低污染与交叉污染的应对策略，重点关注标记基因和宏基因组分析领域。我们同时制定了污染物信息报告与去除流程的最低标准规范。从样本采集处理到数据分析报告，研究全流程各环节都必须建立污染防控与识别机制。我们强烈建议研究者在设计、实施和报告微生物组研究（特别是低生物量系统研究）时采纳这些建议方案。\nIntroduction 过去二十年，随着非培养方法的普及，微生物组研究迅猛发展。标记基因测序和宏基因组测序已成为探索细菌、古菌、真菌、原生生物及病毒多样性的主流手段。尽管学界已就微生物组研究的最佳实践达成诸多共识，但这些建议主要基于高生物量样本（如表层土壤、污水和人类粪便）的研究经验。此类样本中微生物DNA含量较高，目标信号远强于污染噪声，不易产生假阳性结果。\n然而，许多系统的微生物生物量极低，接近常规DNA测序的检测极限（图1）。由于测序数据的比例特性，微量污染物即可严重影响研究结果，这在低生物量系统研究中尤为突出。这类系统包括：大气、保存不佳的古样本、深层地下环境、超干旱土壤、永久冻土、饮用水、金属表面、岩石、高盐卤水、雪和冰芯等。\n某些宿主相关系统（如人类呼吸道、母乳、胎儿组织、血液，以及植物种子、部分动物肠道等）虽含大量宿主DNA，但微生物DNA含量极低。更有研究报道，人类胎盘、特定动物肠道及极端环境中甚至完全检测不到常驻微生物。\n图 1 | 宿主、自然环境和人工环境系统中原核生物（细菌和古菌）细胞的典型数量（对数尺度）。估算值采用不依赖培养的方法（主要为直接细胞计数）获得，但我们注意到这些是平均近似值，并且从特定环境中采集的样本之间的细胞数量可能存在相当大的差异。细胞数量/计数来自已发表的文献，并根据通常用于 DNA 提取的样本量（体积或重量）进行了调整。详情请参阅补充表 1。图中不同颜色的点表示环境的一般类别。\n研究低微生物生物量环境需要严格把控样本采集、实验操作和数据分析各环节，以降低并识别污染物。污染物来源广泛（如人体、采样设备、试剂耗材、实验室环境），可出现在采样、储存、DNA提取、测序等任何阶段。另一个突出问题是样本间交叉污染（如孔间DNA渗漏，图2）。\n虽然已有多种生物信息学去污染方法，但难以准确区分真实信号与污染噪声，尤其对严重污染的测序数据。尽管已有研究提出污染防控指南，但污染问题依然存在，且对照实验的使用率十年未增。这导致学界对部分微生物组研究（特别是低生物量系统研究）的可靠性存疑。操作不当轻则影响研究质量与结果可比性，重则导致错误结论——污染可能扭曲生态与进化特征、造成病原体暴露途径误判，或导致微生物存在的假阳性判定。例如关于\u0026quot;胎盘微生物组\u0026quot;的争议，促使人们重视污染问题与最佳实践。类似争议也存在于人类血液、脑组织、肿瘤组织，以及深层地下环境、高层大气等系统的研究中。\n本文提出一套污染最小化方案及报告标准（经微生物组领域专家共识制定）。这些建议适用于所有微生物组研究（尤其低生物量系统、病原体追踪等易受污染影响的领域），虽以标记基因（如16S rRNA测序）和宏基因组测序为重点，但同样适用于宏转录组、DNA稳定同位素探针、qPCR和培养等方法。遵循这些建议将提升研究质量，有效规避低生物量系统研究中的常见问题。尽管无法完全消除污染，但通过系统防控可将其影响降至最低。\n图 2 | 概念图说明了微生物组研究三个步骤中污染和交叉污染的发生方式，并提出了缓解控制措施。目标样本（红色光滑形状表示）可能被外部污染物（灰色阴影尖锐形状表示）污染。这些外部污染物可能是来自采样群落以外来源的细胞或 DNA（例如，实验室试剂、采样设备）。此外，目标样本也可能受到交叉污染的影响，在采样、实验室处理和/或通过“标签切换”（例如，当条形码读取被错误分配给错误的样本时会发生这种情况）过程中，细胞或 DNA 被无意地与其他样本（棕色阴影光滑形状表示）交换。此外，污染物和交叉污染物会在整个工作流程中累积。准备，制备。\n低生物量系统的采样策略 污染可能发生在从采样到测序的任何环节（图2）。采样阶段的主要污染源包括操作人员、采样设备及周边环境（如患者血液样本接触皮肤，或沉积物样本混入上层水体）。由于大多数DNA检测方法的非特异性，采样过程中引入的微生物DNA很难与目标样本DNA区分。因此，建议采用污染防控型采样设计，以最大限度减少并识别污染。\n采样时的污染防控措施需根据具体系统调整，但以下核心原则普遍适用：\n全面评估污染源：从原位环境到采样容器，识别样本可能接触的所有污染源，并在采样前后采取防控措施。 采样前准备： 确保采样试剂（如保存液）无DNA污染 通过预实验优化流程并发现问题 采样过程控制： 实时监控样本接触的物体和环境 采用去污染措施或物理隔离阻断污染 人员培训：对采样人员进行标准化操作培训，确保流程规范执行。 需特别注意：初始样本的微生物生物量越低，污染对最终测序数据的比例影响越大。建议尽可能采取以下措施（参见表1）：\n污染源去污染措施 所有采样设备、工具、容器及手套均需进行去污染处理。首选一次性无DNA耗材（如拭子与采集管），若需重复使用则须严格消毒：先用80%乙醇灭活污染微生物，再以核酸降解溶液清除残留DNA，这对连续使用同一设备的场景尤为重要。手套需同等处理且在采样前避免接触任何物品。用于采集或储存样本的塑料/玻璃器皿应经过高压灭菌或紫外辐照预处理，并保持密封至采样时刻。需注意无菌状态不等同于无DNA残留——即便活细胞已被清除，游离DNA仍可能存留于处理后的表面。因此建议在安全可行条件下，采用次氯酸钠、UV-C辐照、过氧化氢、环氧乙烷气体或商用DNA清除剂进行深度处理。\n个人防护装备应用规范 采样操作应遵循最小接触原则。操作人员需根据环境穿戴防护装备（手套、护目镜、防护服/洁净服及鞋套等），以隔绝呼吸气溶胶、衣物皮屑等人体污染源。航天洁净室与古DNA实验室的防护标准具有示范价值：前者要求全覆盖式防护，后者采用口罩、防护面罩及三层可更换手套的配置。尽管极端场景才需如此严密的防护，但常规研究中适度使用PPE仍是经济高效降低人源污染的关键措施。\n污染源对照样本采集 设置采样对照对识别污染来源、评估防控效果及数据校正至关重要。对照类型包括空采集管、环境空气拭子、PPE表面拭子、操作接触面拭子及保存液等分试样等。涉及钻探或切割操作的研究常将工作流体作为阴性对照，部分实验还通过示踪染料标记流体污染。例如胎儿胎粪研究通过采集消毒后产妇皮肤拭子与手术室空气拭子，证实胎粪微生物组与阴性对照无差异。建议每4个样本至少设置1个对照，且所有对照需与实验样本同步经历全流程处理，以便结合DNA提取与建库阶段的阴性对照精准追溯污染环节。所有对照信息均需完整记录并报告（参见表2与框1）。\n实验室污染防控与识别规范 实验室操作流程（包括DNA提取、PCR扩增、文库构建和测序）既可能引入污染物，也会放大其影响。常见污染源包括试剂耗材（如提取试剂盒、保存液、离心管乃至纯化水）中可扩增的游离DNA或顽固菌种（如Ralstonia、Pseudomonas）残留，以及操作人员、实验室环境或其他样本的交叉污染。研究表明，实验室污染特征会随月份、季节及操作者变化，而样本管间DNA气溶胶扩散或\u0026quot;标签跳跃\u0026quot;现象更会导致数据误判。因此，必须通过实验室分区设计、规范操作和系统对照来防控污染。以下为关键措施（参见表1）：\n实验室空间管理 分子实验区应严格划分前处理区（样本制备/DNA提取）与后处理区（PCR/文库构建），并建立单向工作流。所有操作需在生物安全柜内完成，使用专用移液器与滤芯吸头。实验前后需用DNA降解溶液彻底消毒台面，并辅以UV-C辐照。人员须穿戴专用PPE，不同区域设备不得混用，且一次性防护装备应按\u0026quot;洁净区→污染区\u0026quot;单向穿行。定期清洁地面及水平面以控制灰尘污染。\n试剂质量控制 优先选用经认证的无DNA试剂，但使用前仍需通过qPCR或测序验证其洁净度。建议将大宗试剂分装为小份，每批次单独设立阴性对照以监控污染。塑料耗材使用前需UV-C灭菌，样本管进入工作区前应彻底表面消毒。若外包测序环节，需确认服务商具备低生物量样本处理经验，并建议进行预实验。\n对照系统设置 每个实验批次需同步设置多类型对照：\n采样对照（环境空白、试剂空白等） 过程对照（无样本DNA提取、无模板PCR等） 阳性对照（梯度稀释的模拟群落标准品） 交叉污染监控对照（如掺入特异性寡核苷酸）\n所有对照应与样本同步进行全流程处理并测序，即使阴性对照PCR产物不可见也需测序验证。建议每批次试剂均设立独立对照，因不同批次的污染物谱可能存在差异。 样本处理策略 高低生物量样本应分开处理，96孔板布局时需注意中心孔位更易发生交叉污染。推荐使用双索引纠错条形码，必要时可采用亚硫酸盐转化等化学标记技术，以区分预处理后引入的污染DNA。单管操作虽可降低交叉污染风险，但需权衡通量需求。\n检测并潜在去除序列数据中的污染物 在分析微生物组测序数据时，污染识别与清除是至关重要的环节，尤其对于低生物量样本。即便采用最严格的采样和实验流程，污染风险仍无法完全消除。通过系统比对阳性/阴性对照与样本中的序列、分类单元或基因，结合专业去污染软件（表3），可评估污染程度并进行针对性处理。但需注意，宏基因组数据因其复杂性较标记基因更难净化，且去污染过程可能导致信息失真。当信噪比过低时，建议直接弃用受污染数据，但保留原始记录（参见表2与框1）以追溯污染来源。\n分析测序对照并检查意外分类单元 质量控制阶段应重点分析三类信息：阴性对照中的非目标DNA、阳性对照分类单元在样本中的分布、以及污染物在读段中的占比。标记基因数据可通过比对ASVs与常见污染物数据库进行净化，而宏基因组数据则需将样本读段映射至对照组的MAGs。需警惕那些生态学上不合理的分类单元（如南极高空出现人体共生菌、脑组织中发现光合蓝藻等），这些异常信号往往提示污染存在。\n考虑使用净化软件，但要注意其局限性 去污染软件虽能辅助识别外源污染物（如decontam基于检出频率或丰度特征），但对交叉污染识别有限（SCRuB等工具例外）。使用时应考虑其假设前提与适用场景，注意假阳性与假阴性风险。宏基因组分析更需谨慎：即便设置阴性对照，低覆盖度污染物仍可能残留，且近缘物种序列难以区分。建议结合qPCR定量、细胞计数等生物量指标综合判断，同时认识到基于短读长组装的MAGs只能反映部分读段信息这一技术局限。\n防胜于治：污染防控优先原则 研究者应在开展大规模采样与测序前，投入充分精力优化污染防控方案。尽管微量污染难以避免，但系统性污染可被有效控制——已有研究成功获取了极低生物量生态系统的高质量数据，甚至证实了某些环境不存在常驻微生物。这些成果均依赖于全流程污染防控体系的建立，包括无污染采样流程开发、试剂与水质验证，以及测序数据的严谨分析。通过多维度对照实验，可追溯污染来源（如采样操作、试剂或人员），并据此迭代优化实验方案。\n对于已存在显著污染的数据集，事后去污染措施往往收效有限。例如近期一项全球大气微生物组研究中，近半数序列（包括已知试剂污染物如假单胞菌属）被迫剔除，导致群落组成与驱动因素的分析可靠性存疑。任何去污染算法均非完美， retrospective处理可能导致假阳性/假阴性结果。当标记基因或宏基因组数据需剔除大量序列时，应重新评估样本数据的有效性；若污染问题持续且严重，则需质疑整个数据集的可靠性。在关键研究中，跨实验室重复验证仍是确认结果可信度的金标准。\nConclusion 基于DNA技术的微生物组研究中，特别是在处理低生物量样本时，必须预设交叉污染难以完全避免。为此，研究者应当双管齐下：一方面通过标准化操作最大限度降低污染风险，另一方面设置系统对照以准确评估污染性质与程度。尤为关键的是，必须完整报告三项核心信息：污染防控的具体措施、检出污染物的特征、以及后续分析中对可疑污染数据的处理方案。这种全流程透明化记录将显著提升研究结果的可信度。需要说明的是，本文提出的建议并非强制性操作清单，而是旨在推动学界更系统地审视污染问题。我们相信，通过强化对污染和交叉污染问题的认知与管理，不仅能够提升微生物组研究的整体质量，更有助于解决既往研究中因污染导致的可重复性争议。最终目标是为微生物组科学建立更可靠的方法学基础，使研究成果能够经得起时间和实践的检验。\n","date":"2025-06-26T00:00:00Z","image":"https://jb-cao.github.io/Cao-blog/p/lowmass-nm/images/fig2_hu_7e70a37e87e867de.png","permalink":"https://jb-cao.github.io/Cao-blog/p/lowmass-nm/","title":"在低生物量微生物组研究中预防和报告污染｜Nature Microbiology指南"},{"content":"MetaNet是一个用于组学网络分析的R包，提供了多种功能，包括网络构建、可视化、比较和稳定性分析等。最近我把MetaNet的预印本放到了bioRxiv上，欢迎大家阅读和使用。\n预印本地址：https://www.biorxiv.org/content/10.1101/2025.06.26.661636v1 软件主页：https://github.com/Asa12138/MetaNet 大家可以帮忙在github上点点star⭐️，谢谢🙏 详细英文版教程：https://bookdown.org/Asa12138/metanet_book/ 网络分析是揭示高通量组学数据集中复杂关系的有力策略。然而，现有工具通常在可扩展性、灵活性以及多组学整合的原生支持方面存在不足，这为探索复杂生物网络设置了重大障碍。为突破这些限制，我们开发了MetaNet——一个高性能R语言软件包，专为多组学数据集的生物网络构建、可视化与分析而设计。MetaNet支持基于相关性的高效网络构建，可扩展至包含超过10,000个特征的数据集的快速计算，并提供与静态和交互式平台兼容的丰富布局算法与可视化选项。该软件包还包含一套完整的拓扑和稳定性指标，用于深度网络表征。基准测试表明，MetaNet在计算时间上比现有R包快达100倍，内存使用减少达50倍。我们通过两个案例研究展示其实用性：(1) 微生物共现网络的纵向分析揭示了空气微生物组的动态变化；(2) 包含40,000多个特征的暴露组-转录组整合网络，揭示了生物与化学暴露的差异化调控影响。MetaNet通过提供强大、可重复且具有生物学解释力的框架，弥合了网络理论与组学应用之间的鸿沟，支持跨组学平台的大规模、可解释的整合网络分析，推动现代生命科学的系统水平认知。MetaNet已在 CRAN发布(https://cran.r-project.org/web/packages/MetaNet)。\nIntroduction 网络（或称图论模型）是解析复杂生物系统交互关系的基础工具。这种抽象而信息丰富的表征方式，可跨越分子到生态等多个层次揭示生物特征间的相互作用。网络理论已深刻影响生命科学的多个分支领域——蛋白质互作网络阐明信号传导与药物靶点，基因调控网络描绘发育与疾病的级联控制，代谢网络绘制生物合成与能量通路，而生态网络则揭示物种互作与群落动态。随着宏基因组、转录组、蛋白组和代谢组等高通量组学技术的爆发式发展，基于网络的分析方法已成为处理多维生物大数据的核心策略，能有效识别功能模块、推断关联关系并发现关键调控因子。\n现有网络分析工具各具特色：Cytoscape提供分子互作可视化平台，Gephi擅长大规模图布局算法；R/Python生态中的igraph、ggraph和tidygraph包提供灵活的网络功能，WGCNA专注于基因共表达分析，而ggClusterNet、microeco和NetCoMi等工具则针对微生物组分析进行了优化。此外，MENAP、iNAP等在线流程为简单需求提供了快速解决方案。\n然而，这些工具难以满足现代组学数据的复杂需求：首先，缺乏多组学整合的原生支持；其次，高维数据相关性网络构建存在计算瓶颈；第三，相关性阈值选择通常依赖主观判断；第四，可视化功能有限，难以生成出版级图表；最后，在线工具的不可复现性问题突出。这些局限严重制约了组学尺度网络分析的可靠性。\n为此，我们开发了MetaNet——专为组学数据设计的可扩展R包。该工具通过四大创新突破现有局限：(1) 采用并行优化算法，实现万级特征的高效网络构建；(2) 引入随机矩阵理论实现数据驱动的相关性阈值筛选；(3) 集成40余种布局算法，支持与ggplot2/Gephi/Cytoscape的交互；(4) 提供拓扑分析与稳定性评估的全套指标。通过微生物组时序共现网络和暴露组-转录组整合网络两个案例，我们验证了其在复杂生物大数据解析中的卓越性能。\nMethods MetaNet设计与开发 MetaNet是基于R语言的多组学网络分析工具包，兼容Windows、MacOS和Linux系统（需R 4.0以上版本），核心功能基于igraph包实现。其架构包含八大模块（图1A）：计算、操作、布局、可视化、拓扑分析、模块分析、稳定性分析和数据读写，支持从网络构建到分析可视化的全流程。核心数据结构为扩展自igraph的\u0026quot;metanet\u0026quot;对象，兼容所有基础igraph操作，并可转换为tbl_graph对象与ggraph/tidygraph生态交互。所有功能函数均以\u0026quot;c_net_\u0026ldquo;前缀统一命名，便于记忆和使用。\n数据预处理\n提供\u0026quot;trans\u0026quot;函数支持CPM、log转换、aCPM等十余种标准化方法（表S1） 内置\u0026quot;guolv\u0026rdquo;（过滤）和\u0026quot;hebing\u0026quot;（合并）函数用于原始数据清洗 网络构建\n支持四种构建方式： 从原始数据计算（c_net_calculate + c_net_build） 导入graphml/pajek格式文件（c_net_load） 通过边列表生成（c_net_from_edgelist） 升级现有igraph对象（c_net_update） 网络操作\n注释管理：c_net_set/c_net_annotate实现属性标注 子网提取：c_net_filter/c_net_neighbors支持局部网络分析 集合运算：c_net_union/c_net_intersect实现网络比较 可视化与布局\n集成40余种布局算法（c_net_layout） 支持几何变换（缩放/旋转/3D投影等） c_net_plot函数提供出版级绘图参数控制 拓扑分析\nc_net_index计算17种拓扑指标 c_net_stability评估网络鲁棒性（特别适用于微生物生态网络） 性能对比 在Apple M2芯片上的基准测试显示（图1C）：\n计算速度：较WGCNA、NetCoMi等工具提升最高100倍（p\u0026lt;0.001） 内存占用：降低达50倍（特征数=1000时） 优势源于：向量化矩阵运算与t分布解析法求p值 案例应用 微生物共现网络\n数据集：6名受试者24个时间点的微生物组数据 筛选：保留出现频率\u0026gt;10%的914个物种 构建：Spearman相关性（|ρ|\u0026gt;0.6且FDR\u0026lt;0.05） 分析： 快速贪婪算法识别功能模块 时序子网拓扑指标计算（连通性/中心性等） 暴露组-转录组整合网络\n关联分析： 化学暴露-转录组：|ρ|\u0026gt;0.6且FDR\u0026lt;5e-4 生物暴露-转录组：|ρ|\u0026gt;0.5且FDR\u0026lt;5e-4 功能注释：ReporterScore包进行KEGG/GO富集分析 获取方式 CRAN/GitHub/Gitee平台开源 附在线手册（https://bookdown.org/Asa12138/metanet_book/） Results 高效且可扩展的网络计算可以分析更大的omics数据集 MetaNet实现了高效可扩展的网络计算能力，能够处理大规模组学数据集分析。该工具提供多种标准化策略（表S1），支持微生物组、转录组、蛋白组和代谢组等不同组学数据的预处理。网络构建基于Spearman、Pearson和Bray-Curtis等相似性计算方法，通过随机化检验和多重检验校正保留显著关联。相比现有工具，MetaNet采用优化的向量化矩阵算法，将计算速度提升100-10,000倍（p\u0026lt;0.001），在1000个特征规模下仅需0.2秒和100MB内存（图1D），且资源消耗随特征数呈平方级增长（图1E）。\n针对相关性网络阈值选择的主观性问题，MetaNet整合随机矩阵理论（RMT），通过数据驱动方式自动确定最优相关性阈值（图S1A-B），有效减少虚假边的影响。除相关性方法外，该工具还兼容互信息和偏相关等非线性关系分析方法的输出结果，为复杂组学网络构建提供灵活解决方案。\nFigure 1. Overview of the MetaNet workflow and its high-efficiency computation. (A) Functional modules of MetaNet, as visualized using MetaNet. (B) Detailed workflow of MetaNet. Green boxes indicate data objects, blue and red boxes represent MetaNet-specific objects, and gray boxes denote core functions. (C) MetaNet logo and its code repositories and platforms. (D) Line plots comparing memory usage and runtime for correlation-based network construction across different R packages. Comparisons were capped at 1000 features because some packages required too many resources and time to process larger networks. Error bars represent standard deviation (SD). (E) Line plots showing MetaNet’s performance on increasingly larger datasets in terms of memory usage and runtime. Error bars represent SD.\n网络注释、操作与比较的集成化功能工具 MetaNet提供完整的网络操作功能体系。通过\u0026quot;get_*\u0026ldquo;系列函数可快速获取网络、节点和边的属性表，支持数据检查和统计汇总。\u0026ldquo;metanet\u0026quot;对象完全兼容igraph基础操作，并可转换为tbl_graph对象实现与ggraph/tidygraph生态的无缝对接。\n在多组学研究中，网络注释常需整合丰度谱、分类学或临床元数据等外部信息。\u0026ldquo;c_net_set\u0026quot;函数支持批量添加注释表并自动配置可视化参数（图2B），包括颜色映射、线型设置、节点形状及图例生成。针对特定研究需求，\u0026ldquo;c_net_filter\u0026quot;可基于组合条件提取子网络（图2C），而\u0026quot;c_net_highlight\u0026quot;则能高亮显示关键节点或边（图2D）。\n对于复杂网络中的功能模块识别，\u0026ldquo;c_net_module\u0026quot;集成多种社区发现算法（图2E），检测结果可通过弦图或桑基图展示模块间关联（图2F）。通过\u0026quot;c_net_skeleton\u0026quot;函数可实现组间连接的统计汇总，显著提升多条件或时序数据的可解释性（图2G）。\n跨网络比较分析方面，MetaNet提供集合运算功能（图2H），支持通过交集、并集和差集运算揭示实验组间差异边或保守子网，为进化分析和差异比较建立标准化框架。\nFigure 2. MetaNet supports flexible and intuitive network manipulation. (A) Initial multi-omics network constructed without annotations. (B) Annotated multi-omics network using the \u0026ldquo;c_net_set\u0026rdquo; function. Node shape indicates the types of omics data, color represents the subtypes of omics data, size denotes average abundance, edge color indicates positive or negative correlation, edge type (solid or dashed) distinguishes intra- and inter-omics connections, and edge width reflects the absolute value of the correlation coefficient. (C) Subnetwork filtered from intra-omics interactions between the Microbiome and Metabolome layers using \u0026ldquo;c_net_filter\u0026rdquo;. (D) Highlighted nodes centered on \u0026ldquo;Dongia_mobilis\u0026rdquo; and its neighbors using \u0026ldquo;c_net_highlight\u0026rdquo;. (E) Community detection and modular visualization using \u0026ldquo;c_net_module\u0026rdquo;. (F) Chord diagram displaying the proportion of edges between modules. (G) Skeleton network across omics subtypes at a grouped level using \u0026ldquo;c_net_skeleton\u0026rdquo;. (H) Operations among networks: \u0026ldquo;c_net_union\u0026rdquo; merges net1 and net2, \u0026ldquo;c_net_intersect\u0026rdquo; extracts shared nodes and edges, and \u0026ldquo;c_net_difference\u0026rdquo; isolates net1-specific nodes and edges. All networks shown are based on simulated data and are for illustrative purposes only.\n进阶网络布局与可视化功能 网络布局是可视化的重要环节，直接影响网络结构的可解释性。MetaNet采用灵活的\u0026quot;coors\u0026quot;对象存储布局坐标，支持布局设置的便捷控制与复用。\u0026ldquo;c_net_layout\u0026quot;函数集成40余种布局算法（图3A），既包含经典布局也创新开发了\u0026quot;spatstat_layout\u0026quot;方法——该方法支持在用户自定义多边形内或边缘生成节点分布，例如实现星形排布（图3B）或地理映射（图3C）。系统还支持与Gephi、Cytoscape等工具的布局互操作。\n针对分组网络，\u0026ldquo;g_layout\u0026quot;函数提供高级布局接口，允许分别定义各组的空间配置策略。通过嵌套调用可构建多级复合布局，例如人体各部位微生物共现网络的高效排布（图3D）。该功能特别适用于模块化结构展示：\u0026ldquo;g_layout_circlepack\u0026quot;生成紧凑的圆形包块布局（图3E），而\u0026quot;g_layout_multi_layer\u0026quot;则创建突出模块关系的伪3D多层表达（图3F）。\n可视化方面，\u0026ldquo;c_net_plot\u0026quot;提供丰富的参数定制选项（表S2），精确控制节点、边、模块与图例的视觉呈现。系统默认采用igraph的基础绘图体系，同时通过\u0026quot;as.ggig\u0026quot;函数支持转换为ggplot2对象，可进一步应用\u0026quot;labs\u0026rdquo;、\u0026ldquo;theme\u0026quot;等函数优化图表（图S3A）。此外，MetaNet支持导出至NetworkD3、Gephi等工具实现扩展可视化流程（图S3B-D）。\nFigure 3. MetaNet enables diverse and powerful network layout strategies. (A) The application of 24 out of more than 40 built-in layout algorithms from \u0026ldquo;c_net_layout\u0026rdquo; on the Zachary Karate Club network was provided by the igraph package. (B) Layout generated within a star using \u0026ldquo;spatstat_layout\u0026rdquo;. (C) Layout generated within the map of Australia using \u0026ldquo;spatstat_layout\u0026rdquo;. (D) Grouped network layout consisting of four subgroups arranged with \u0026ldquo;with_fr()\u0026rdquo;, \u0026ldquo;on_grid()\u0026rdquo;, \u0026ldquo;as_polycircle(3)\u0026rdquo;, and \u0026ldquo;as_polygon(3)\u0026rdquo; within a human-body schematic. All visualization elements were rendered with MetaNet without manual adjustments. (E) Modular network visualized using \u0026ldquo;g_layout_circlepack\u0026rdquo;. (F) A three-layer modular structure visualized using \u0026ldquo;g_layout_multi_layer\u0026rdquo;. All networks shown are based on simulated data.\n专业生物网络与数据库的扩展支持 MetaNet原生支持多种生物信息学专用网络类型。通过构建Venn式网络（图4A），可突破传统维恩图的局限，直观展示样本组间的集合关系与连接结构。针对分类学或基因本体等树状数据，内置\u0026quot;as_circle_tree\u0026quot;布局能紧凑呈现层级关系（图4B）。特有的饼图节点设计（图4C）支持将多组学丰度等多元注释直接编码于网络结构中。\n该工具深度整合生物数据库资源：可导入STRING数据库的蛋白质互作网络（图4D）和miRTarBase验证的miRNA-靶基因调控网络（图4E），并支持自定义布局与注释。通过与ReporterScore包的无缝衔接，能直接可视化KEGG同源基因与通路的关联网络（图4F），更支持通过KEGG ID实时渲染全注释通路图（图4G）。这些功能使MetaNet成为整合生物知识库与多组学分析的强大平台。\nFigure 4. Diverse specialized network visualizations by MetaNet. (A) Venn-style network: Large nodes represent groups, while smaller nodes denote individual elements within each group, enabling visualization of shared and unique components. (B) Hierarchical tree network: Nodes are organized based on classification hierarchy. Node color corresponds to the taxonomic or categorical level. (C) Pie-node network: Each node is displayed as a pie chart, where slice colors indicate relative abundance across different groups. (D) Protein–protein interaction (PPI) network: Extracted from the STRING database, showing experimentally validated and predicted molecular interactions among proteins. (E) miRNA–gene regulatory network: Sourced from the miRTarBase database, illustrating experimentally supported regulatory relationships between miRNAs and their target genes. (F) KEGG KO–pathway association network: The network shows KEGG orthologs (KOs) involved in selected biological pathways. Small nodes represent KOs, and large nodes represent pathways. KO nodes are colored by their expression trend. Shaded regions surrounding pathways indicate whether the pathway is globally up-regulated (orange) or down-regulated (green). (G) KEGG pathway-specific network: Network representation of the “EGFR tyrosine kinase inhibitor resistance” pathway. Rectangular nodes denote KEGG orthologs, circular nodes indicate compounds, and edge colors reflect interaction types.\n全面的网络拓扑与稳定性分析 MetaNet提供全面的网络拓扑分析功能，涵盖全局和局部两个维度。全局指标包括网络密度、平均连接度、聚类系数、平均路径长度等（表S3），可量化生物网络的冗余性、鲁棒性等特征。例如平均路径长度能反映代谢或基因调控网络中的信号传递效率。局部指标则用于评估节点/边的重要性（表S4），可识别关键调控因子或瓶颈节点。\n系统支持通过Erdős–Rényi模型生成随机网络作为参照（图S4A），用于检测生物网络普遍具有的无标度、小世界等特征。\u0026ldquo;fit_power\u0026quot;函数可验证度分布的幂律特性（图S4B），而\u0026quot;smallworldness\u0026quot;则计算小世界指数σ。针对生物网络典型的模块化结构，通过\u0026quot;c_net_module\u0026quot;函数实现多种社区发现算法（图S4C），并支持分析模块内的表达或丰度模式（图S4D）。基于Zi-Pi方法将节点划分为外围节点、连接节点、模块枢纽和网络枢纽四种拓扑角色（图S4E-F），为功能解析提供新视角。\n在稳定性分析方面，MetaNet集成多种生态与结构稳定性算法。结构鲁棒性测试通过逐步移除节点计算自然连通性变化（图S5A），其下降速率反映网络抗干扰能力。鲁棒性评估则模拟节点删除并跟踪基于丰度的交互强度（图S5B）。脆弱性分析揭示节点对网络通信效率的贡献（图S5C），而正负凝聚指数则量化微生物群落的合作与竞争关系（图S5D-E）。所有分析均支持多核并行加速。\n案例1：微生物共现网络的时序动态分析 为展示MetaNet在多组学整合分析中的灵活性，我们将其应用于一项个体水平的多组学纵向研究数据。该研究通过可穿戴采样器获取19名受试者在特殊环境暴露下的化学与生物暴露组时序数据。我们重点分析了空气微生物组的动态变化，其中时间点A代表自然环境基线，B-D为暴露环境阶段。\n构建的全局微生物共现网络包含871个物种（图5A），覆盖四个分类界（图5B）。通过贪婪模块优化算法识别出六个功能模块，其度分布符合幂律特征（图5C），呈现典型复杂系统特性。模块内物种丰度分析显示，如M3模块成员随时间推移持续下降。拓扑角色分类鉴定出13个模块枢纽和19个连接节点，这些关键物种可能维持网络整体性。\n针对各时间点的细菌子网络分析（图5F）发现，部分微生物物种（灰色标记）的存在与丰度发生显著变化。拓扑指标比较显示，从时间点A到B出现重大转变（图5G）：暴露后网络的模块化程度和平均路径长度增加，而全局效率、聚类系数和自然连通性下降。这些变化暗示微生物群落发生功能解离——模块化增强反映亚群落间交流受限，聚类效率降低表明细菌互作网络受损，共同指向特殊暴露条件下空气微生物组的生态稳定性丧失。该发现与既往关于环境压力导致微生物网络脆弱性增加的研究结论一致。\nFigure 5. Modularity and temporal dynamics of the microbial co-occurrence network. (A) Species-level microbial co-occurrence network constructed from all microbial exposure samples, showing six modules (M1 to M6). Node color indicates module membership, node size reflects relative abundance, and edge color distinguishes intra- versus inter-module connections. (B) Phylogenetic relationship network of all species in panel A, arranged using the \u0026ldquo;as_circle_tree\u0026rdquo; layout. (C) Comparison of degree distribution between the empirical network in panel A and a randomized network with the same number of nodes and edges. (D) Temporal abundance profiles of species within each module. The y-axis represents the scaled abundance of species, while the x-axis represents individual samples sorted by time point (E) Key microbial taxa identified based on topological role classification using the Zi-Pi framework. (F) Subnetwork dynamics across four exposure stages. Node color represents bacterial phylum, node size reflects relative abundance, and gray nodes denote non-core species with presence or abundance changes over time. (G) Changes in global network topological metrics across different stages. P-values for comparisons between timepoints A and B were calculated using the Wilcoxon rank-sum test.\n案例2：多组学整合网络揭示生物与化学暴露组对转录组的差异化影响 基于同一纵向多组学数据集，我们进一步构建了暴露组（生物与化学）与宿主转录组的整合网络。该分析共纳入35,587个转录组基因、2,955个微生物物种和3,729种化学暴露物（图6A），发现590个微生物分类单元与1,983个基因存在显著关联（以正相关为主），而245种化学暴露物与1,026个基因的关联则以负相关为主导。最强关联子网络可视化显示（图6B），微生物暴露与基因表达呈正向关联，而化学暴露则倾向负相关（图6C）。关键环境因子包括：微生物中的Microbacterium lacticum和Aureobasidium melanogenum，化学物中的(SR)-4-甲基-2,3-戊二醇、吲哚等。\n功能富集分析揭示显著差异：微生物暴露关联基因主要富集于免疫负调控通路（图6D），如唾液链球菌与炎症信号枢纽HMGB1的正相关，提示潜在免疫调节机制；而化学暴露则显著关联神经退行性疾病（帕金森病、阿尔茨海默病等）和DNA损伤应答通路（图S6），其中苯系物和多环芳烃等已知神经毒物与认知功能障碍相关基因的负相关尤为突出。\n本案例证实MetaNet能有效解析多组学交互网络，揭示生物与化学暴露通过差异化的基因-环境互作机制影响健康结局——微生物暴露可能通过免疫调节通路发挥作用，而化学暴露更倾向于通过神经毒性和遗传毒性途径产生影响。\nFigure 6. Integrated Network Analysis of Exposome–Transcriptome Interactions. (A) Spearman correlation-based multi-omics network linking all microbial and chemical exposures to transcriptomic data. (B) Spearman correlation-based multi-omics network showing the most prominent associations. Links with |ρ| \u0026gt; 0.7 (for chemical–transcriptome pairs) or \u0026gt; 0.6 (for biological–transcriptome pairs) are included. Only the top 10 ranked node labels are shown. Node size reflects degree centrality. (C) Skeleton structure of the network in panel B, highlighting the core architecture of microbial and chemical associations with genes. (D) Network representations of significantly correlated genes and enriched pathways for biological exposures. Bar charts on either side indicate the number of positively and negatively correlated connections for each exposure.\nDiscussion 本研究推出的MetaNet是一个可扩展、灵活且具有生物学解释力的R语言工具包，专为组学与多组学网络分析设计。通过将网络构建、可视化、拓扑分析和跨组学整合集成至统一的可复现流程，该工具解决了现有方法的多个关键局限。其处理上万特征的能力、支持多样化网络类型以及生成高质量可定制可视化结果的特点，使其特别适用于现代系统生物学研究。两个案例研究证实了MetaNet从复杂数据中提取生物学洞见的价值，基准测试则验证了其计算性能优势，模块化设计则保障了功能的可扩展性。\n当前网络分析工具生态呈现多元化发展：Cytoscape擅长可视化扩展，Gephi支持大规模动态布局，igraph提供跨语言高性能计算，WGCNA专注基因共表达分析，而NetCoMi等工具则聚焦微生物生态网络。面对高通量技术产生的海量多维组学数据，MetaNet通过四大核心优势推动领域发展：(1) 基于相关性的超高效网络构建；(2) 多组学数据的无缝整合；(3) 覆盖40余种布局算法的可视化引擎；(4) 拓扑与稳定性分析的完整指标体系。该工具尤其适用于微生物生态网络、多组学互作网络等需要精确复现的研究场景，并能对接KEGG、STRING等生物知识库。\n尽管取得显著进展，MetaNet仍存在若干局限：当前主要优化相关性网络，对非线性关系的解析能力有待加强；随着数据规模扩大，布局算法与拓扑分析效率需持续提升；此外，生物网络分析领域普遍存在的标准化缺失问题（如阈值选择、零模型构建等）也亟待解决。未来发展方向包括：(1) 整合贝叶斯网络等新型推断方法；(2) 深化与生物知识库的融合；(3) 扩展单细胞组学数据支持；(4) 增加生态网络专用指标。通过持续优化与社区共建，MetaNet有望发展成为多组学网络分析的核心平台。\n","date":"2025-06-26T00:00:00Z","image":"https://jb-cao.github.io/Cao-blog/p/metanet-biorxiv/images/fig4_hu_795c2e261a855265.png","permalink":"https://jb-cao.github.io/Cao-blog/p/metanet-biorxiv/","title":"预印本｜MetaNet: a scalable and integrated tool for reproducible omics network analysis"},{"content":"Introduction 中介分析是一种统计方法，用于研究自变量(X)通过一个或多个中介变量(M)影响因变量(Y)的机制。简单来说，它帮助我们回答”X如何影响Y”而不仅仅是”X是否影响Y”的问题。例如，在教育研究中，我们可能想知道”教师教学水平(X)“是否通过”学生课堂参与度(M)“影响了”学生成绩(Y)“，这就是一个典型的中介分析问题。\n中介分析的核心在于识别和量化三种效应：\n直接效应：X对Y的直接影响 间接效应：X通过M对Y的影响 总效应：直接效应与间接效应之和 结构方程模型（Structural Equation Modeling，简称SEM）可以被视为中介分析的扩展和泛化，它允许更复杂的模型设定，包括多重中介、调节中介以及各种变量间的交互作用，它们后续能用到的可视化工具也类似。\nSEM是一种结合多元统计方法和数学模型的分析技术。它能够帮助研究者探究多个变量之间的关系和影响，包括直接和间接的影响。SEM 可以同时估计多个方程（即多元回归模型），并且允许变量间相互作用，同时还能考虑隐变量（latent variable）和测量误差等因素。\n中介分析 先看一个简单的中介分析示例，使用R语言中的mediation包来进行中介分析。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # 安装并加载必要的包 library(mediation) # 示例数据 set.seed(123) n \u0026lt;- 200 X \u0026lt;- rnorm(n) M \u0026lt;- 0.5*X + rnorm(n) Y \u0026lt;- 0.3*X + 0.4*M + rnorm(n) data \u0026lt;- data.frame(X, M, Y) # 步骤1: 建立中介模型(M ~ X) model.m \u0026lt;- lm(M ~ X, data = data) # 步骤2: 建立结果模型(Y ~ X + M) model.y \u0026lt;- lm(Y ~ X + M, data = data) # 步骤3: 进行中介分析 med.sum \u0026lt;- mediate(model.m, model.y, treat = \u0026#34;X\u0026#34;, mediator = \u0026#34;M\u0026#34;, boot = TRUE, sims = 500) # 查看结果 summary(med.sum) ## ## Causal Mediation Analysis ## ## Nonparametric Bootstrap Confidence Intervals with the Percentile Method ## ## Estimate 95% CI Lower 95% CI Upper p-value ## ACME 0.1645 0.0997 0.25 \u0026lt;2e-16 *** ## ADE 0.2929 0.1067 0.46 \u0026lt;2e-16 *** ## Total Effect 0.4574 0.2682 0.62 \u0026lt;2e-16 *** ## Prop. Mediated 0.3596 0.2074 0.64 \u0026lt;2e-16 *** ## --- ## Signif. codes: 0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 ## ## Sample Size Used: 200 ## ## ## Simulations: 500 1 2 # 绘制结果 plot(med.sum) ACME stands for average causal mediation effects.间接因果效应，表示X通过M对Y的效应大小 通过med.sum$d0和med.sum$d0.p可以获得ACME的效应和p值\nADE stands for average direct effects.直接效应，表示X直接对Y的作用大小 通过med.sum$z0和med.sum$z0.p可以获得ADE的效应和p值\nTotal Effect stands for the total effect (direct + indirect) of the IV on the DV. X对Y的直接和间接作用总和\nProp. Mediated describes the proportion of the effect of the IV on the DV that goes through the mediator. X通过M对Y的作用的比例\n中介效应的类型 互补型中介（Complementary Mediation） 定义：间接效应和直接效应都显著且方向一致（例如，均为正或均为负）。\n意义：中介变量部分解释了自变量与因变量之间的关系，并增强了总效应。\n竞争型中介（Competitive Mediation） 定义：间接效应和直接效应都显著，但方向相反（一个为正，一个为负）。\n意义：中介变量的解释部分抵消了直接效应，导致自变量与因变量之间的关系呈现混合效应。\n仅间接中介（Indirect-Only Mediation） 定义：间接效应显著，但直接效应不显著。\n意义：中介变量完全解释了自变量与因变量之间的关系，即完全中介。\n非中介效应的类型\n仅直接非中介（Direct-Only Non-Mediation） 定义：直接效应显著，但间接效应不显著。\n意义：中介变量在自变量与因变量之间未发挥作用，关系主要通过直接路径发生。\n无效非中介（No-Effect Non-Mediation） 定义：直接效应和间接效应均不显著。\n意义：自变量与因变量之间不存在关系，无论是否涉及中介变量。\n或者使用psych包可以进行中介分析并绘制简单的中介图。\n1 2 3 4 library(psych) m2=psych::mediate(Y ~ X + (M),data = data,n.iter = 500,plot = FALSE) psych::mediate.diagram(m2) 这里的\nc = the total effect of X on Y c = c’ + ab c’= the direct effect of X on Y after controlling for M; c’=c - ab ab= indirect effect of X on Y 生存数据中介分析 可以再看一个生存数据的中介分析示例，使用survival包和mediation包来进行中介分析。这里我们使用lung数据集作为示例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 library(survival) library(dplyr) # 加载 lung 数据集 data(lung) # 数据预处理 dat \u0026lt;- lung %\u0026gt;% mutate(status = ifelse(status == 2, 1, 0), ph.ecog = ifelse(ph.ecog == 0, 0, 1), time = time/30) %\u0026gt;% dplyr::select(ph.ecog, wt.loss, time, status, age, sex) %\u0026gt;% drop_na() # head(dat) library(mediation) # 中介模型 mod_med \u0026lt;- lm(wt.loss ~ ph.ecog + age + sex, data = dat) # 结局模型 mod_out \u0026lt;- survreg(Surv(time, status) ~ wt.loss + ph.ecog + age + sex, dist = \u0026#34;weibull\u0026#34;, data = dat) # nonparametric bootstrap置信区间 set.seed(111) med_res1 \u0026lt;- mediate(model.m = mod_med, model.y = mod_out, sims = 1000, boot = TRUE, boot.ci.type = \u0026#34;perc\u0026#34;, treat = \u0026#34;ph.ecog\u0026#34;, mediator = \u0026#34;wt.loss\u0026#34;, outcome = \u0026#34;time\u0026#34;) summary(med_res1) # 结果总结 ## ## Causal Mediation Analysis ## ## Nonparametric Bootstrap Confidence Intervals with the Percentile Method ## ## Estimate 95% CI Lower 95% CI Upper p-value ## ACME (control) 0.3142 -0.5340 1.70 0.474 ## ACME (treated) 0.2087 -0.3880 1.01 0.474 ## ADE (control) -6.7308 -12.6789 -2.24 0.004 ** ## ADE (treated) -6.8363 -13.2424 -2.28 0.004 ** ## Total Effect -6.5220 -12.3459 -2.01 0.006 ** ## Prop. Mediated (control) -0.0482 -0.2847 0.12 0.480 ## Prop. Mediated (treated) -0.0320 -0.1939 0.09 0.480 ## ACME (average) 0.2615 -0.4739 1.37 0.474 ## ADE (average) -6.7835 -12.9447 -2.26 0.004 ** ## Prop. Mediated (average) -0.0401 -0.2341 0.10 0.480 ## --- ## Signif. codes: 0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 ## ## Sample Size Used: 213 ## ## ## Simulations: 1000 1 plot(med_res1) 结果解释：主要关注以下指标的p值是否显著，及点估计和置信区间估计： ACME(average)，平均因果中介效应，p=0.474，表明中介效应不显著。 ADE(average)，平均直接效应，p=0.004，表明直接效应显著。 Prop. Mediated (average) ，平均中介比例。 Total Effect，总效应，p=0.006，表明总效应显著。 结论：ph.ecog 直接影响 status，而不是通过 wt.loss 间接影响（中介）。\n结构方程模型（SEM） SEM是一个广泛复杂的话题，这里我们只介绍简单的SEM模型示例，使用lavaan包来实现。更详细的SEM模型可以参考相关文献或教程。比如https://mp.weixin.qq.com/s/NEhoOlAau_jyxHPTf7H3ug这个讲的很详细。\nSEM是一个线性模型框架，它对具有潜变量（ latent variables）的同步回归方程进行建模。\n线性回归(linear regression)、多元回归(multivariate regression)、路径分析(path analysis)、验证因子分析(confirmatory factor analysis)和结构回归(structural regression)等模型可以被认为是 SEM 的特殊情况。\nSEM 中可能存在以下关系：\n从观察变量到观察变量（observed to observed variables）(γ，e.g., regression) 从潜变量到观测变量 （latent to observed variables） (λ, e.g., confirmatory factor analysis) 从潜变量到潜变量 （latent to latent variables）(γ，β，e.g., structural regression) 变量类型划分 观察变量(Observed Variable) 又称”显变量”(Manifest Variable)或”指标变量”(Indicator Variable) 实际测量得到的变量，存在于数据集中 示例：问卷项目得分、生理指标测量值等 潜变量(Latent Variable) 又称”构念”(Construct)或”因子”(Factor) 无法直接测量，需要通过观察变量间接反映 示例：满意度、焦虑程度、智力等抽象概念 因果关系\n外生变量(Exogenous Variable) 独立变量，不受模型中其他变量影响 可以是观察变量(x)或潜在变量(ξ) 在路径图中无指向它的箭头 内生变量(Endogenous Variable) 因变量，至少有一条因果路径指向它 可以是观察变量(y)或潜在变量(η) 在路径图中有指向它的箭头 测量模型(Measurement Model)\n描述潜在变量与观察变量之间的关系 包含以下要素： 指标(Indicator)：测量模型中的观察变量 因子(Factor)：由指标定义的潜在变量 因子载荷(Loading)：指标与因子间的关联强度 结构模型(Structural Model)\n描述变量(包括潜在变量)间的因果关系 主要元素： 回归路径：外生变量到内生变量的因果关系 方差/协方差：外生变量间的相关关系 lavaan包语法速查表 符号 含义 示例 说明 ~ 回归关系 y ~ x y对x的回归 =~ 潜在变量定义 f =~ q + r + s 定义f由q,r,s测量 ~~ 方差/协方差 x ~~ y x与y的协方差 ~1 截距/均值 x ~ 1 估计x的均值 1* 固定参数 f =~ 1*q 固定q的因子载荷为1 NA* 自由参数 f =~ NA*q 释放q的因子载荷 a* 参数标签 f =~ a*q 标记q的因子载荷为a，用于约束 模型设定示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 # 测量模型示例 measurement_model \u0026lt;- \u0026#39; # 潜在变量定义 f1 =~ q1 + q2 + q3 # f1由q1-q3测量 f2 =~ q4 + q5 + q6 # f2由q4-q6测量 # 固定第一个指标的载荷为1 f1 =~ 1*q1 f2 =~ 1*q4 # 估计指标残差方差 q1 ~~ q1 q2 ~~ q2 \u0026#39; # 结构模型示例 structural_model \u0026lt;- \u0026#39; # 回归关系 y ~ x1 + x2 # y对x1,x2的回归 f1 ~ f2 + x1 # f1对f2,x1的回归 # 协方差 x1 ~~ x2 # x1与x2的协方差 \u0026#39; # 完整SEM模型 full_model \u0026lt;- \u0026#39; # 测量模型部分 f1 =~ y1 + y2 + y3 f2 =~ y4 + y5 + y6 # 结构模型部分 f1 ~ f2 + x1 f2 ~ x1 + x2 # 残差相关 y1 ~~ y2 \u0026#39; 理解这些核心概念和语法是掌握SEM分析的基础。\nSEM测量中介效应 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 library(lavaan) # 定义模型 model \u0026lt;- \u0026#39; # 直接效应 Y ~ c*X # 中介路径 M ~ a*X Y ~ b*M # 间接效应(a*b) indirect := a*b # 总效应 total := c + (a*b) \u0026#39; # 拟合模型 fit \u0026lt;- sem(model, data = data,sample.nobs = 500) # 查看结果 summary(fit, standardized = TRUE, rsq = TRUE) ## lavaan 0.6.15 ended normally after 1 iteration ## ## Estimator ML ## Optimization method NLMINB ## Number of model parameters 5 ## ## Number of observations 200 ## ## Model Test User Model: ## ## Test statistic 0.000 ## Degrees of freedom 0 ## ## Parameter Estimates: ## ## Standard errors Standard ## Information Expected ## Information saturated (h1) model Structured ## ## Regressions: ## Estimate Std.Err z-value P(\u0026gt;|z|) Std.lv Std.all ## Y ~ ## X (c) 0.293 0.079 3.705 0.000 0.293 0.249 ## M ~ ## X (a) 0.471 0.075 6.307 0.000 0.471 0.407 ## Y ~ ## M (b) 0.349 0.068 5.107 0.000 0.349 0.343 ## ## Variances: ## Estimate Std.Err z-value P(\u0026gt;|z|) Std.lv Std.all ## .Y 0.923 0.092 10.000 0.000 0.923 0.751 ## .M 0.986 0.099 10.000 0.000 0.986 0.834 ## ## R-Square: ## Estimate ## Y 0.249 ## M 0.166 ## ## Defined Parameters: ## Estimate Std.Err z-value P(\u0026gt;|z|) Std.lv Std.all ## indirect 0.164 0.041 3.969 0.000 0.164 0.140 ## total 0.457 0.077 5.958 0.000 0.457 0.388 1 2 # 参数估计 parameterEstimates(fit) ## lhs op rhs label est se z pvalue ci.lower ci.upper ## 1 Y ~ X c 0.293 0.079 3.705 0 0.138 0.448 ## 2 M ~ X a 0.471 0.075 6.307 0 0.324 0.617 ## 3 Y ~ M b 0.349 0.068 5.107 0 0.215 0.483 ## 4 Y ~~ Y 0.923 0.092 10.000 0 0.742 1.104 ## 5 M ~~ M 0.986 0.099 10.000 0 0.793 1.179 ## 6 X ~~ X 0.885 0.000 NA NA 0.885 0.885 ## 7 indirect := a*b indirect 0.164 0.041 3.969 0 0.083 0.246 ## 8 total := c+(a*b) total 0.457 0.077 5.958 0 0.307 0.608 1 2 3 # 最后可以用`semMediation`包或者`semPlot`包来可视化SEM模型 #devtools::install_github(\u0026#34;cardiomoon/semMediation\u0026#34;) semMediation::mediationPlot(fit) https://zhuanlan.zhihu.com/p/53206137\n生物例子 在宏基因组微生物生态学中，研究者通常会测量样品中多个微生物群落的组成和它们所处的环境变量（如温度、pH值等）之间的关系。然而，这些微生物群落之间可能存在相互作用，如竞争、合作等，这些作用可能会影响到它们与环境之间的关系。在这种情况下，SEM可以用来建立微生物群落与环境变量之间的关系网络，同时考虑微生物群落之间的相互作用。\n例如，一项研究调查了植物根际微生物群落与土壤性质之间的关系。研究者测量了植物根际中多个微生物群落的组成，以及土壤中的一些物理化学性质，如有机质含量、pH值等。他们使用SEM来建立微生物群落与土壤性质之间的关系网络，并同时考虑微生物群落之间的相互作用。他们发现，微生物群落之间存在着复杂的相互作用，而这些相互作用会影响到微生物群落与土壤性质之间的关系，提高了对微生物群落与环境之间关系的理解。\n下面给出一个用R生成模拟数据并实现SEM的例子，假设我们研究一些微生物和它们生长环境之间的关系。其中，环境因子包括pH、温度、盐度，微生物包括细菌、真菌和古菌。\n首先，我们需要生成一些符合正态分布的随机数据作为我们的变量。具体代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 library(mvtnorm) set.seed(123) # 生成环境因子数据 n \u0026lt;- 1000 mu_env \u0026lt;- c(pH = 7, temp = 25, salinity = 3) sigma_env \u0026lt;- matrix(c(1, 0.8, 0.5, 0.8, 1, 0.3, 0.5, 0.3, 1), ncol = 3) env \u0026lt;- rmvnorm(n, mean = mu_env, sigma = sigma_env)%\u0026gt;%as.data.frame() # 生成微生物数据 mu_microbe \u0026lt;- c(bacteria = 20, fungi = 10, archaea = 5) sigma_microbe \u0026lt;- matrix(c(1, 0.5, 0.3, 0.5, 1, 0.2, 0.3, 0.2, 1), ncol = 3) microbe \u0026lt;- rmvnorm(n, mean = mu_microbe, sigma = sigma_microbe)%\u0026gt;%as.data.frame() # 将生成的数据合并为一个数据框 df \u0026lt;- data.frame(env, microbe) 接下来，我们使用sem函数实现SEM。具体代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 library(lavaan) model \u0026lt;- \u0026#39; # 定义测量模型 # bacteria =~ bacteria # fungi =~ fungi # archaea =~ archaea # 定义结构模型 bacteria ~ pH + temp fungi ~ temp + salinity archaea ~ pH + salinity bacteria ~~ fungi bacteria ~~ archaea fungi ~~ archaea \u0026#39; # 运行SEM fit \u0026lt;- sem(model, data = df) # 查看SEM结果 summary(fit) ## lavaan 0.6.15 ended normally after 22 iterations ## ## Estimator ML ## Optimization method NLMINB ## Number of model parameters 12 ## ## Number of observations 1000 ## ## Model Test User Model: ## ## Test statistic 3.024 ## Degrees of freedom 3 ## P-value (Chi-square) 0.388 ## ## Parameter Estimates: ## ## Standard errors Standard ## Information Expected ## Information saturated (h1) model Structured ## ## Regressions: ## Estimate Std.Err z-value P(\u0026gt;|z|) ## bacteria ~ ## pH -0.022 0.047 -0.463 0.643 ## temp 0.074 0.048 1.541 0.123 ## fungi ~ ## temp 0.019 0.033 0.574 0.566 ## salinity 0.024 0.029 0.828 0.408 ## archaea ~ ## pH 0.017 0.036 0.481 0.631 ## salinity 0.028 0.034 0.822 0.411 ## ## Covariances: ## Estimate Std.Err z-value P(\u0026gt;|z|) ## .bacteria ~~ ## .fungi 0.467 0.035 13.496 0.000 ## .archaea 0.295 0.032 9.221 0.000 ## .fungi ~~ ## .archaea 0.183 0.031 5.869 0.000 ## ## Variances: ## Estimate Std.Err z-value P(\u0026gt;|z|) ## .bacteria 0.990 0.044 22.361 0.000 ## .fungi 0.988 0.044 22.361 0.000 ## .archaea 0.948 0.042 22.361 0.000 最后，我们可以使用semPlot函数绘制SEM图形，以便更好地理解SEM模型的结构。具体代码如下：\n1 2 3 library(semPlot) semPaths(fit, what = \u0026#34;std\u0026#34;, nCharNodes = 10, sizeMan = 8, edge.label.cex = 1.1, curvePivot = TRUE, fade = FALSE) 1 semMediation::mediationPlot(fit) 运行上述代码后，我们就得到了一个可视化的SEM模型图，该模型描述了微生物和环境因子之间的关系。\nReferences https://mp.weixin.qq.com/s/NEhoOlAau_jyxHPTf7H3ug https://mp.weixin.qq.com/s/OLr9Xo-GoAAt0Tu8L-c93g https://mp.weixin.qq.com/s/UhcnqytZUmTHDcSh3mAaOQ ","date":"2025-06-13T00:00:00Z","image":"https://jb-cao.github.io/Cao-blog/p/sem/images/sem_model_hu_5e863a097cf938da.jpg","permalink":"https://jb-cao.github.io/Cao-blog/p/sem/","title":"中介分析与结构方程模型（SEM）学习"},{"content":"Introduction KEGG（Kyoto Encyclopedia of Genes and Genomes）是一个广泛使用的生物信息学数据库，用于研究基因组、代谢组、信号通路和生物化学反应等方面的信息。它提供了基因、蛋白质、代谢物和信号通路等生物分子的综合信息，帮助研究人员理解生物体内分子之间的相互作用和功能。\n之前的文章详细介绍了KEGG 数据库及API的基础使用。其中KEGG pathway是我们经常需要使用的功能之一，它提供了生物体内代谢通路和信号传导通路的详细信息。\n使用KEGG官网提供的绘图功能或者R包pathview可以绘制下面这种KEGG通路图，但这些方法通常只能处理单个通路，且绘图功能较为简单：\n为了更好地处理和可视化KEGG通路网络，我们尝试获取KEGG pathway的网络结构然后用MetaNet绘制，因为涉及到KEGG通路的一些函数我之前已经在ReporterScore包中实现了，所以我这次把通路网络的获取和绘图功能放在了ReporterScore包中，但背后调用的还是MetaNet包的绘图功能。\n软件主页：https://github.com/Asa12138/MetaNet 大家可以帮忙在github上点点star⭐️，谢谢🙏 详细英文版教程：https://bookdown.org/Asa12138/metanet_book 可以从 CRAN 安装稳定版：install.packages(\u0026quot;MetaNet\u0026quot;)\n最新的开发版本可以在 https://github.com/Asa12138/MetaNet 中找到：\n1 2 remotes::install_github(\u0026#34;Asa12138/MetaNet\u0026#34;, dependencies = T) remotes::install_github(\u0026#34;Asa12138/ReporterScore\u0026#34;, dependencies = T) ReporterScore+MetaNet 1 2 3 4 5 6 7 8 9 10 library(ReporterScore) library(MetaNet) tmp_dir \u0026lt;- tempdir() # 下载KEGG通路XML文件 pcutils::download2(\u0026#34;https://rest.kegg.jp/get/ko01521/kgml\u0026#34;, file.path(tmp_dir, \u0026#34;ko01521.xml\u0026#34;)) # 读取KEGG通路XML文件 path_net_c \u0026lt;- c_net_from_pathway_xml(file.path(tmp_dir, \u0026#34;ko01521.xml\u0026#34;)) # 绘制KEGG通路网络图 plot_pathway_net(path_net_c) 我们也可以使用update_pathway_xml_ls()函数来获取或更新所有的KEGG通路XML文件。这个函数会下载最新的KEGG通路XML文件到指定的目录。\n1 2 3 4 # org参数可以指定组织或物种，默认为NULL，表示获取所有通路 update_pathway_xml_ls(download_dir = \u0026#34;~/Documents/\u0026#34;,org = NULL) # 下载过一次之后，就可以用load_pathway_xml_ls获取KEGG通路 load_pathway_xml_ls()-\u0026gt;pathway_xml_ls 想要给节点加上注释，并换上不同颜色，大小，布局等参数也非常简单，与之前介绍的MetaNet包的c_net_plot绘图参数完全一致的，可以查看3.网络注释与操作，4.布局和可视化。\n1 2 3 4 5 6 7 8 9 10 11 12 # 调整一下布局 coors=get_v(path_net_c)[,c(\u0026#34;name\u0026#34;,\u0026#34;x\u0026#34;,\u0026#34;y\u0026#34;)] colnames(coors)=c(\u0026#34;name\u0026#34;,\u0026#34;X\u0026#34;,\u0026#34;Y\u0026#34;) coors=rescale_coors(as_coors(coors)) coors=transform_coors(coors,aspect_ratio = 0.6) # 调整纵横比 plot_pathway_net(path_net_c,coors=coors, label_cex=0.6, vertex.color=c(\u0026#34;#a6cee3\u0026#34;, \u0026#34;#78c679\u0026#34;), vertex.frame.width=0.2, arrow_size_cex=2,arrow_width_cex=2, edge.width=0.5) 添加注释文件，比如基因上调和下调信息。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 添加注释信息 anno_df=data.frame( name=V(path_net_c)$name, Group=sample(c(\u0026#34;Up\u0026#34;,\u0026#34;None\u0026#34;,\u0026#34;Down\u0026#34;),vcount(path_net_c),replace = TRUE) ) path_net_c=c_net_set(path_net_c,anno_df,vertex_class = \u0026#34;Group\u0026#34;) # \u0026#34;#FFFFFF00\u0026#34;是透明色 pal=setNames(c(\u0026#34;#92C5DE\u0026#34;,\u0026#34;#FFFFFF00\u0026#34;,\u0026#34;#D6604D\u0026#34;),c(\u0026#34;Down\u0026#34;,\u0026#34;None\u0026#34;,\u0026#34;Up\u0026#34;)) plot_pathway_net(path_net_c,coors=coors, label_cex=0.6, vertex.color=pal, vertex.frame.width=0.2,arrow_size_cex=2,arrow_width_cex=2, edge.width=0.5) 还可以使用MetaNet对网络进行各种操作筛选，比如我想获取某个基因的下游网络：\n1 get_v(path_net_c) 1 2 3 4 5 6 7 8 9 10 11 12 13 ## name _type type reaction graphics_name x y width height fgcolor ## 1 ko:K04357 from ortholog \u0026lt;NA\u0026gt; K04357 155 -247 46 17 #000000 ## 2 ko:K08774 from ortholog \u0026lt;NA\u0026gt; K08774 155 -271 46 17 #000000 ## 3 ko:K05460 from ortholog \u0026lt;NA\u0026gt; K05460 155 -530 46 17 #000000 ## bgcolor graphics_type coords xmin xmax ymin ymax orig.id pathway_id ## 1 #BFBFFF rectangle NA 132 178 -255.5 -238.5 32 ko01521 ## 2 #BFBFFF rectangle NA 132 178 -279.5 -262.5 20 ko01521 ## 3 #BFBFFF rectangle NA 132 178 -538.5 -521.5 75 ko01521 ## label size v_group shape v_class color Group ## 1 K04357 1 ortholog square None #fb9a99 None ## 2 K08774 1 ortholog square None #fb9a99 None ## 3 K05460 1 ortholog square Up #fdbf6f Up ## [ reached \u0026#39;max\u0026#39; / getOption(\u0026#34;max.print\u0026#34;) -- omitted 50 rows ] 1 2 3 c_net_neighbors(path_net_c, nodes = \u0026#34;ko:K04456\u0026#34;,order=2, mode = \u0026#34;out\u0026#34;) -\u0026gt; path_net_c2 plot_pathway_net(path_net_c2,vertex.color=pal) ggkegg 但目前MetaNet不支持一些巨大的代谢网络如ko01100，因为其xml文件不是标准网络信息，可以使用更强大的ggkegg包来绘制，代码稍微复杂一点：\nggkegg是一个基于ggplot2的KEGG通路绘图包，提供了更灵活的绘图功能和更美观的图形输出。它可以处理更复杂的KEGG通路数据，并支持多种自定义样式。\nhttps://github.com/noriakis/ggkegg\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 library(ggkegg) library(ggfx) library(igraph) library(tidygraph) library(dplyr) pathway(\u0026#34;ko01100\u0026#34;) |\u0026gt; process_line() |\u0026gt; highlight_module(module(\u0026#34;M00021\u0026#34;)) |\u0026gt; highlight_module(module(\u0026#34;M00338\u0026#34;)) |\u0026gt; ggraph(x=x, y=y) + geom_node_point(size=1, aes(color=I(fgcolor), filter=fgcolor!=\u0026#34;none\u0026#34; \u0026amp; type!=\u0026#34;line\u0026#34;)) + geom_edge_link0(width=0.1, aes(color=I(fgcolor), filter=type==\u0026#34;line\u0026#34;\u0026amp; fgcolor!=\u0026#34;none\u0026#34;)) + with_outer_glow( geom_edge_link0(width=1, aes(color=I(fgcolor), filter=(M00021 | M00338))), colour=\u0026#34;red\u0026#34;, expand=5 ) + with_outer_glow( geom_node_point(size=1.5, aes(color=I(fgcolor), filter=(M00021 | M00338))), colour=\u0026#34;red\u0026#34;, expand=5 ) + geom_node_text(size=2, aes(x=x, y=y, label=graphics_name, filter=name==\u0026#34;path:ko00270\u0026#34;), repel=TRUE, family=\u0026#34;sans\u0026#34;, bg.colour=\u0026#34;white\u0026#34;) + theme_void() References https://github.com/noriakis/ggkegg https://github.com/datapplab/pathview ","date":"2025-06-12T00:00:00Z","image":"https://jb-cao.github.io/Cao-blog/p/metanet-kegg/index.en_files/figure-html/unnamed-chunk-5-1_hu_77cc3541fb288779.png","permalink":"https://jb-cao.github.io/Cao-blog/p/metanet-kegg/","title":"使用MetaNet绘制KEGG通路网络图"},{"content":"采样地图可以帮助我们直观地展示研究样本的地理分布和采样点信息。我之前也写过一篇R绘制优美的地图的推文，详细介绍了地图文件，坐标参考系统，绘制地图，注释地图，RasterLayer等内容，但对于一些简单的采样地图绘制，可能不需要那么复杂的步骤。\n本文将介绍如何使用pcutils包中的sample_map函数快速绘制采样地图。\n函数介绍 该函数用于绘制 空间采样点分布图，支持三种可视化模式：\n静态基础地图（mode=1）：基于 ggplot2 + 内置世界地图 自定义地理边界（mode=2）：使用用户提供的GeoJSON/SHP文件 交互式地图（mode=3）：基于 leaflet 的动态地图 参数详解\n1. 数据输入\n参数 类型 必填 说明 metadata data.frame 是 必须包含 Longitude 和 Latitude 列（WGS84坐标） group 字符 否 指定分组变量（控制点的颜色映射） label 字符 否 指定点的标签文本列 2. 可视化模式控制\n参数 选项 默认 说明 mode 1/2/3 1 1=静态图, 2=自定义边界, 3=交互地图 map_provider 字符 \u0026ldquo;OpenStreetMap\u0026rdquo; 仅mode=3有效，可选 providers$Esri.WorldTerrain 等 3. 地理数据处理\n参数 类型 默认 说明 shp_file 字符 NULL mode=2 时指定地理边界文件路径 crs 整数 4326 坐标参考系统（EPSG代码），4326=WGS84 xlim/ylim 数值向量 NULL 设置地图显示范围（如 xlim=c(75,135)） 4. 图形元素定制\n参数 类型 说明 point_params list 传递给 geom_point() 的参数（如 list(size=3, shape=17)） map_params list 地图边界样式（mode=1控制geom_polygon，mode=2控制geom_sf） leaflet_pal 函数 mode=3专用，如 leaflet::colorFactor(\u0026quot;Set1\u0026quot;, domain=metadata$group) 5. 地图装饰元素\n参数 类型 默认 说明 add_scale 逻辑 TRUE 是否添加比例尺 scale_params list 空 控制比例尺样式（位置、单位等） add_north_arrow 逻辑 TRUE 是否添加指北针 north_arrow_params list 空 控制指北针样式 以下是一些示例代码，展示如何使用sample_map函数绘制采样地图：\n自带地图（粗糙） 1 2 3 4 5 6 library(pcutils) data(otutab) anno_df \u0026lt;- metadata[, c(\u0026#34;Id\u0026#34;, \u0026#34;long\u0026#34;, \u0026#34;lat\u0026#34;, \u0026#34;Group\u0026#34;)] colnames(anno_df) \u0026lt;- c(\u0026#34;Id\u0026#34;, \u0026#34;Longitude\u0026#34;, \u0026#34;Latitude\u0026#34;, \u0026#34;Group\u0026#34;) head(anno_df) 1 2 3 4 5 6 7 ## Id Longitude Latitude Group ## NS1 NS1 103.4767 26.94422 NS ## NS2 NS2 109.6196 29.08733 NS ## NS3 NS3 104.0361 28.25164 NS ## NS4 NS4 106.8651 33.82415 NS ## NS5 NS5 105.4571 33.51011 NS ## NS6 NS6 102.7832 31.86864 NS 使用mode=1参数可以绘制一个简单的静态地图，默认使用内置的世界地图：\n1 sample_map(anno_df, mode = 1, group = \u0026#34;Group\u0026#34;) 使用xlim和ylim参数可以设置地图的显示范围：\n1 sample_map(anno_df, mode = 1, group = \u0026#34;Group\u0026#34;, xlim = c(90, 135), ylim = c(20, 50)) 自定义地图文件（精细） 自己找一个合适的GeoJSON或Shapefile文件，放在本地，然后指定路径。\n网上能够下载到中国地图的地方很多，比如 GeoJSON.cn，yezongyang/china-geojson等等，而世界上其他区域，不同精度（洲，国家，城市，县\u0026hellip;）的地图数据就需要自己按照需求寻找一下，如GeoJSON Maps of the globe (ash.ms)，georgique/world-geojson，datasets/geo-countries等等。\n使用mode=2参数可以绘制自定义地理边界的地图，指定shp_file参数为GeoJSON或Shapefile文件路径：\n1 2 3 4 5 6 7 sample_map(anno_df, mode = 2, group = \u0026#34;Group\u0026#34;, shp_file = \u0026#34;~/database/china.json\u0026#34;, label = \u0026#34;Id\u0026#34;,xlim = c(90, 135), ylim = c(20, 50), point_params = list(size=4), label_params = list(check_overlap = F,size=1.5))+ theme_bw()+ scale_fill_pc() leaflet交互式地图 Leaflet是一个开源的JavaScript库，用于创建交互式地图。R中的Leaflet包提供了一个轻量级的接口，允许在R中创建交互式地图。Leaflet包提供了许多基本的地图操作功能，例如缩放、平移和旋转，同时还允许添加标记、文本注释、多边形、线条和点。\n1 sample_map(anno_df, mode = 3, group = \u0026#34;Group\u0026#34;) Leaflet包支持多种地图提供商（如OpenStreetMap、Esri、Stamen等），可以通过leaflet::providers函数查看可用的地图提供商列表。\n也可以在这个网站预览列表里的各种效果https://leaflet-extras.github.io/leaflet-providers/preview/index.html。\n1 sample_map(anno_df, mode = 3, group = \u0026#34;Group\u0026#34;,map_provider = \u0026#34;USGS.USImagery\u0026#34;) ","date":"2025-05-26T00:00:00Z","image":"https://jb-cao.github.io/Cao-blog/p/sample-map/images/leaf2_hu_8d4d18b9f664a059.png","permalink":"https://jb-cao.github.io/Cao-blog/p/sample-map/","title":"快速绘制采样地图"},{"content":"Introduction 在生物信息学研究中，从NCBI下载基因组数据是一项基础的任务。无论是进行基因组比较分析、注释研究还是构建本地数据库，高效获取目标基因组数据都是第一步。\n目前已有一些成熟的工具可以实现这一需求，例如：\nncbi-genome-download：一个功能强大的Python工具 NCBI Datasets command-line tools (CLI)：NCBI官方提供的命令行工具 然而，在实际使用中，这些工具经常会遇到网络连接不稳定、下载中断等问题。这里介绍一下自己写的一个函数，可以完成批量根据genome accession id下载相关数据的任务，基本不会有网络问题，只要网页能打开NCBI应该就能下。然后也介绍一下上述已有的轮子，他们的功能还是非常多且强大的。\ndownload_ncbi_genome_file 这是一个很简单的R函数，具体实现如下：\nNCBI的基因组Accession ID具有特定格式，例如：GCF_001036115.1_ASM103611v1，GCA_000005845.2_ASM584v2\n其中：\nGCF开头表示RefSeq数据库 GCA开头表示GenBank数据库 中间9位数字是唯一标识符 .1表示版本号 后缀ASM103611v1是组装名称 文件存储结构与下载原理：\nNCBI的FTP服务器采用分层目录结构存储基因组数据。例如，GCF_001036115.1对应的完整路径为： https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/001/036/115/GCF_001036115.1_ASM103611v1/\n该目录下通常包含多种文件类型：\ngenomic.fna：基因组FASTA文件； genomic.gff：GFF格式注释文件； genomic.gtf：GTF格式注释文件； genomic.gbff：GenBank格式文件\n实现逻辑：\n从ID（如GCF_001036115.1）解析出FTP基础路径 通过网页爬虫获取完整ID（如GCF_001036115.1_ASM103611v1） 拼接出目标文件的完整URL 使用wget或curl等工具下载文件 使用示例：\n该函数已集成到pcutils R包中，使用非常简便。\n1 2 3 4 5 6 7 8 9 10 11 12 13 library(pcutils) # 下载基因组FASTA文件（可使用简写ID） download_ncbi_genome_file(\u0026#34;GCF_001036115.1\u0026#34;, out_dir = \u0026#34;downloads\u0026#34;, type = \u0026#34;fna\u0026#34;) # 下载GFF注释文件（也可使用完整ID） download_ncbi_genome_file(\u0026#34;GCF_001036115.1_ASM103611v1\u0026#34;, out_dir = \u0026#34;downloads\u0026#34;, type = \u0026#34;gff\u0026#34;) # 批量下载示例 genome_id_list \u0026lt;- c(\u0026#34;GCF_001036115.1\u0026#34;, \u0026#34;GCA_000005845.2\u0026#34;) for (id in genome_id_list) { download_ncbi_genome_file(id, out_dir = \u0026#34;downloads\u0026#34;, type = \u0026#34;fna\u0026#34;) } ncbi-genome-download 软件主页：https://github.com/kblin/ncbi-genome-download\nncbi-genome-download 是一个功能强大的Python命令行工具，专门用于从NCBI FTP服务器批量下载基因组数据。它支持：\n多种生物分类（细菌、真菌、病毒等） RefSeq和GenBank两大数据库 多种文件格式下载 灵活的筛选条件 安装方法 1 2 3 4 5 6 7 # 使用pip安装（推荐） pip install ncbi-genome-download # 或者从源码安装 git clone https://github.com/kblin/ncbi-genome-download.git cd ncbi-genome-download python setup.py install 1 ncbi-genome-download [选项] \u0026lt;分类组\u0026gt; 常用参数详解\n参数 说明 示例 -h, --help 显示帮助信息 - -s, --section 指定数据库（默认为refseq） -s genbank -F, --formats 指定下载格式（逗号分隔） -F fasta,gff -l, --assembly-levels 按组装级别筛选 -l complete -g, --genera 按属名筛选（逗号分隔） -g \u0026quot;Escherichia,Salmonella\u0026quot; -T, --taxids 按分类ID筛选 -T 562 -o, --output-folder 指定输出目录 -o my_genomes -p, --parallel 并行下载数 -p 4 -v, --verbose 显示详细日志 - 实用示例 1 2 3 4 5 6 7 8 9 10 11 # 示例1：下载所有完整组装的细菌基因组（RefSeq） ncbi-genome-download -l complete bacteria # 示例2：下载大肠杆菌和沙门氏菌的基因组（GenBank） ncbi-genome-download -s genbank -g \u0026#34;Escherichia,Salmonella\u0026#34; bacteria # 示例3：下载特定分类ID的基因组（FASTA+GFF格式） ncbi-genome-download -T 562 -F fasta,gff -o ecoli_genomes bacteria # 示例4：并行下载4个真菌基因组 ncbi-genome-download -p 4 fungi NCBI Datasets command-line tools NCBI Datasets是NCBI官方推出的新一代数据获取工具，特点包括：\n官方维护，数据更新及时 支持REST API和命令行两种方式 可下载基因组、基因、转录本、蛋白等多类数据 提供丰富的元数据（JSON格式） 安装 方法一：Conda安装（推荐）\n1 2 conda create -n ncbi_datasets -c conda-forge ncbi-datasets-cli conda activate ncbi_datasets 方法二：直接下载二进制文件\n1 2 3 4 5 6 7 8 9 10 # Linux curl -o datasets https://ftp.ncbi.nlm.nih.gov/pub/datasets/command-line/LATEST/linux-amd64/datasets chmod +x datasets # macOS (Intel) curl -o datasets https://ftp.ncbi.nlm.nih.gov/pub/datasets/command-line/LATEST/mac-amd64/datasets chmod +x datasets # Windows (PowerShell) Invoke-WebRequest -Uri \u0026#34;https://ftp.ncbi.nlm.nih.gov/pub/datasets/command-line/LATEST/win64/datasets.exe\u0026#34; -OutFile \u0026#34;datasets.exe\u0026#34; 核心命令结构\n1 datasets [全局选项] \u0026lt;命令\u0026gt; [命令选项] 主要子命令 命令 功能 download 下载数据包 summary 获取数据摘要 reformat 格式转换 help 帮助信息 基因组下载详解\n1 datasets download genome [选项] \u0026lt;参数\u0026gt; 常用选项\n选项 说明 示例 accession 按accession下载 accession GCF_000001405.40 taxon 按分类单元下载 taxon \u0026quot;Escherichia coli\u0026quot; reference 仅下载参考基因组 --reference filename 指定输出文件名 --filename ecoli.zip include 指定包含的数据类型 --include genome,gff3 dehydrated 仅下载元数据 --dehydrated 实用示例 1 2 3 4 5 6 7 8 9 10 11 # 示例1：下载单个基因组（包含所有文件） datasets download genome accession GCF_000005845.2 --filename ecoli_k12.zip # 示例2：下载大肠杆菌所有参考基因组 datasets download genome taxon \u0026#34;Escherichia coli\u0026#34; --reference --filename all_ecoli_refs.zip # 示例3：自定义下载内容（基因组+注释） datasets download genome accession GCF_000005845.2 --include genome,gff3,protein --filename ecoli_k12_essentials.zip # 示例4：获取数据摘要（不下实际文件） datasets summary genome taxon \u0026#34;Escherichia coli\u0026#34; --reference 数据处理流程\n1 2 3 4 5 6 7 8 # 解压下载包 unzip ecoli.zip # 查看内容 ls ncbi_dataset/data/ # 转换格式（如GBFF转FASTA） datasets reformat gbff --inputfile genomic.gbff --outputfile cds.fasta --fasta 高级应用\n1 2 3 4 5 6 7 8 # 结合jq处理JSON元数据 datasets summary genome accession GCF_000005845.2 --json | jq \u0026#39;.assemblies[0].assembly.assembly_name\u0026#39; # 批量下载脚本示例 accessions=(\u0026#34;GCF_000005845.2\u0026#34; \u0026#34;GCF_000006945.2\u0026#34; \u0026#34;GCF_000007445.1\u0026#34;) for acc in \u0026#34;${accessions[@]}\u0026#34;; do datasets download genome accession \u0026#34;$acc\u0026#34; --filename \u0026#34;${acc}.zip\u0026#34; done ","date":"2025-05-26T00:00:00Z","image":"https://jb-cao.github.io/Cao-blog/p/ncbi-genome/images/datasets_schema_taxonomy.svg","permalink":"https://jb-cao.github.io/Cao-blog/p/ncbi-genome/","title":"批量下载NCBI genome相关数据"},{"content":"Introduction MetaNet是一个用于组学网络分析的R包，提供了多种功能，包括网络构建、可视化、比较和稳定性分析等。\n之前发布的推文中，有多位同学提到如何进行网络的比较，我也根据他们的一些建议改进了MetaNet的一些函数。 本文将介绍如何使用MetaNet进行网络比较，并展示一些示例代码和结果。\n软件主页：https://github.com/Asa12138/MetaNet 大家可以帮忙在github上点点star⭐️，谢谢🙏 详细英文版教程：https://bookdown.org/Asa12138/metanet_book/ 可以从 CRAN 安装稳定版：install.packages(\u0026quot;MetaNet\u0026quot;)，本文请使用最新的开发版本。\n最新的开发版本可以在 https://github.com/Asa12138/MetaNet 中找到：\n1 remotes::install_github(\u0026#34;Asa12138/MetaNet\u0026#34;, dependencies = T) 网络间运算 多个网络之间的比较和运算操作对组学数据分析很重要，例如，比较不同组别网络之间的差异部分，或者是探究动态网络变化中的核心稳定子网络。为了方便比较，MetaNet提供了c_net_union、c_net_intersect、c_net_difference等函数来计算网络的并集、交集和差集。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 library(MetaNet) library(igraph) set.seed(123) g1 \u0026lt;- make_graph(\u0026#34;Icosahedron\u0026#34;) V(g1)$color \u0026lt;- \u0026#34;#4DAF4A77\u0026#34; E(g1)$color \u0026lt;- \u0026#34;#4DAF4A77\u0026#34; g1=as.metanet(g1) g2 \u0026lt;- make_graph(\u0026#34;Octahedron\u0026#34;) V(g2)$name=as.character(9:14) V(g2)$color \u0026lt;- \u0026#34;#984EA366\u0026#34; # 紫色 E(g2)$color \u0026lt;- \u0026#34;#984EA366\u0026#34; g2=as.metanet(g2) # 执行操作 g_union \u0026lt;- c_net_union(g1, g2) E(g_union)$color\u0026lt;-\u0026#34;orange\u0026#34; g_inter \u0026lt;- c_net_intersect(g1, g2) g_diff \u0026lt;- c_net_difference(g1, g2) par_ls=list(main = \u0026#34;\u0026#34;,legend = F,vertex_size_range = c(20,20)) par(mfrow = c(2, 3)) c_net_plot(g1, params_list = par_ls) c_net_plot(g2, params_list = par_ls) c_net_plot(g_union, params_list = par_ls) c_net_plot(g_inter , params_list = par_ls) c_net_plot(g_diff, params_list = par_ls) c_net_compare 基于上述的网络运算，MetaNet提供了c_net_compare函数来比较两个网络的差异部分。该函数可以计算两个网络之间的并集、交集、网络拓扑指标以及计算的网络相似性，并返回一个包含这些信息的列表。\n1 2 3 4 5 6 7 8 set.seed(12) co_net_p1=c_net_filter(co_net,name%in%sample(V(co_net)$name,300)) co_net_p2=c_net_filter(co_net,name%in%sample(V(co_net)$name,300)) c_net_compare(co_net_p1,co_net_p2)-\u0026gt;c_net_comp # 展示网络拓扑指标 c_net_comp$net_par_df 1 2 3 4 5 6 7 8 9 10 11 12 13 ## g1 g2 g_union g_inter ## Node_number 300.000000000 300.000000000 392.0000000 208.000000000 ## Edge_number 334.000000000 321.000000000 499.0000000 156.000000000 ## Edge_density 0.007447046 0.007157191 0.0065113 0.007246377 ## Negative_percentage 0.443113772 0.389408100 0.4128257 0.429487179 ## Average_path_length 6.801472290 6.964863184 7.3484195 5.549893086 ## Global_efficiency 0.088800074 0.067651256 0.1044344 0.033600618 ## Average_degree 2.226666667 2.140000000 2.5459184 1.500000000 ## Average_weighted_degree 0.787061535 0.755481803 0.8992606 0.530061699 ## Diameter 18.000000000 18.000000000 19.0000000 13.000000000 ## Clustering_coefficient 0.330228620 0.311132255 0.2922078 0.337595908 ## Centralized_betweenness 0.127059002 0.074659531 0.1184792 0.049258854 ## Natural_connectivity 3.441388267 2.895183227 4.3359822 1.643829036 直接plot一下，结果图会将两个网络中不同的节点和边变成灰色，相当于共有节点和边高亮出来，帮助我们更好地看见网络的共有或差异部分。\n1 plot(c_net_comp) 网络相似性计算了三种，一个是基于共有节点的jaccard相似性，一个是基于共有边的jaccard相似性，还有一个是基于网络邻接矩阵的相似性。\n1 c_net_comp$net_similarity 1 2 ## node_jaccard edge_jaccard adjacency_similarity ## 0.5306122 0.3126253 0.9331847 邻接矩阵相似性计算的实现代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 adjacency_similarity \u0026lt;- function(g1, g2, method = \u0026#34;frobenius\u0026#34;) { if(!is_metanet(g1)) g1 \u0026lt;- as.metanet(g1) if(!is_metanet(g2)) g2 \u0026lt;- as.metanet(g2) # 获取邻接矩阵 adj1 \u0026lt;- as.matrix(igraph::as_adjacency_matrix(g1)) adj2 \u0026lt;- as.matrix(igraph::as_adjacency_matrix(g2)) # 统一节点集合 all_nodes \u0026lt;- union(rownames(adj1), rownames(adj2)) # 初始化全零矩阵 adj1_fixed \u0026lt;- matrix(0, nrow = length(all_nodes), ncol = length(all_nodes), dimnames = list(all_nodes, all_nodes)) adj2_fixed \u0026lt;- matrix(0, nrow = length(all_nodes), ncol = length(all_nodes), dimnames = list(all_nodes, all_nodes)) # 填充已知边 adj1_fixed[rownames(adj1), colnames(adj1)] \u0026lt;- adj1 adj2_fixed[rownames(adj2), colnames(adj2)] \u0026lt;- adj2 # 计算相似性 if (method == \u0026#34;frobenius\u0026#34;) { diff_norm \u0026lt;- norm(adj1_fixed - adj2_fixed, \u0026#34;F\u0026#34;) max_norm \u0026lt;- sqrt(nrow(adj1_fixed) * ncol(adj2_fixed)) similarity \u0026lt;- 1 - diff_norm / max_norm } else if (method == \u0026#34;cosine\u0026#34;) { similarity \u0026lt;- sum(adj1_fixed * adj2_fixed) / (norm(adj1_fixed, \u0026#34;F\u0026#34;) * norm(adj2_fixed, \u0026#34;F\u0026#34;)) } else { stop(\u0026#34;Method must be \u0026#39;frobenius\u0026#39; or \u0026#39;cosine\u0026#39;.\u0026#34;) } return(similarity) } 我们还可以使用plot_net_degree函数来绘制网络的度分布图，帮助更好地理解网络的结构特征，下面这两个随机取出来的子网络的度分布非常类似。\n1 plot_net_degree(list(co_net_p1,co_net_p2)) c_net_highlight 我们也可以自行调用以下这些函数：\nc_net_neighbors函数可以获取指定节点的邻居节点，\nc_net_highlight函数可以高亮显示网络中指定的节点和边，方便用户进行网络比较和分析。\nplot_multi_nets函数可以将多个网络图并排显示，便于展示。\n1 2 3 4 5 6 7 8 9 10 11 nodes \u0026lt;- c(\u0026#34;s__Kribbella_catacumbae\u0026#34;, \u0026#34;s__Verrucosispora_andamanensis\u0026#34;) nodes \u0026lt;- V(c_net_neighbors(co_net, nodes, order = 2))$name g_hl \u0026lt;- c_net_highlight(co_net, nodes = nodes) get_e(co_net) %\u0026gt;% head(40) -\u0026gt; hl_edges g_hl2 \u0026lt;- c_net_highlight(co_net, edges = hl_edges[, 2:3]) g_hl3 \u0026lt;- c_net_highlight(co_net, nodes = nodes, edges = hl_edges[, 2:3]) plot_multi_nets( list(g_hl, g_hl2, g_hl3),nrow = 1,multi_params_list = list(list(legend=F)) ) ","date":"2025-05-23T00:00:00Z","image":"https://jb-cao.github.io/Cao-blog/p/metanet-comparison/index.en_files/figure-html/unnamed-chunk-4-1_hu_c6393b8d49ffd7f.png","permalink":"https://jb-cao.github.io/Cao-blog/p/metanet-comparison/","title":"使用MetaNet进行网络比较"},{"content":"MetaNet默认使用的是igraph的绘图系统，其中自带的节点形状是非常有限的，只有circle、square、csquare、rectangle、crectangle、vrectangle、pie、none这几种形状，MetaNet在此基础上添加了更多常用形状，并且可以根据本文方法添加自定义形状。\n软件主页：https://github.com/Asa12138/MetaNet 大家可以帮忙在github上点点star⭐️，谢谢🙏 详细英文版教程：https://bookdown.org/Asa12138/metanet_book 可以从 CRAN 安装稳定版：install.packages(\u0026quot;MetaNet\u0026quot;)\n最新的开发版本可以在 https://github.com/Asa12138/MetaNet 中找到：\n1 remotes::install_github(\u0026#34;Asa12138/MetaNet\u0026#34;, dependencies = T) igraph节点形状 1 2 3 4 5 6 7 8 9 10 11 12 library(igraph) # all vertex shapes, minus \u0026#34;raster\u0026#34;, that might not be available # 默认只有以下这些 shapes \u0026lt;- c(\u0026#34;circle\u0026#34;,\u0026#34;crectangle\u0026#34;,\u0026#34;csquare\u0026#34;,\u0026#34;none\u0026#34;,\u0026#34;pie\u0026#34;,\u0026#34;raster\u0026#34;,\u0026#34;rectangle\u0026#34;,\u0026#34;sphere\u0026#34;,\u0026#34;square\u0026#34;,\u0026#34;vrectangle\u0026#34;) g \u0026lt;- make_ring(length(shapes)) set.seed(42) plot(g, vertex.shape = shapes, vertex.label = shapes, vertex.label.dist = 1, vertex.size = 15, vertex.size2 = 15, vertex.pie = lapply(shapes, function(x) if (x == \u0026#34;pie\u0026#34;) 2:6 else 0), vertex.pie.color = list(heat.colors(5)) ) 可以看到csquare、rectangle、crectangle、vrectangle等形状都是矩形的变种，主要是线的连接方式不同，有时候是难以区分的。\nsphere是一个三维的球体，还是很好看的，可以模拟STRING 数据库的节点形状。\n1 2 3 4 g\u0026lt;-make_graph(\u0026#34;Zachary\u0026#34;) plot(g, vertex.shape = \u0026#34;sphere\u0026#34;, vertex.label = NA, vertex.size = 18, vertex.color= pcutils::get_cols(4) ) MetaNet节点形状 MetaNet在igraph的基础上添加了更多的形状，主要是diamond、triangle1、triangle2、star、polygon等形状。\nMetaNet的形状默认是跟v_group变量绑定的（查看之前的推文 3.网络注释与操作），所以当设定了多个大分组时，需要一些易于区分的形状来区分不同的组。\n默认的形状分配是c(\u0026ldquo;circle\u0026rdquo;,\u0026ldquo;square\u0026rdquo;,\u0026ldquo;diamond\u0026rdquo;,\u0026ldquo;triangle1\u0026rdquo;,\u0026ldquo;triangle2\u0026rdquo;)\n1 2 3 4 5 6 library(MetaNet) # 给一些v_group V(g)$v_group \u0026lt;- sample(paste0(\u0026#34;Group\u0026#34;,1:5), vcount(g), replace = TRUE) V(g)$v_class \u0026lt;- sample(letters[1:3], vcount(g), replace = TRUE) as.metanet(g)-\u0026gt;g2 c_net_plot(g2,vertex.color= pcutils::get_cols(4)) 也可以指定star、ploygon等形状。\n1 2 3 c_net_plot(g2,vertex.color= pcutils::get_cols(4), vertex.shape=c(\u0026#34;star\u0026#34;,\u0026#34;polygon\u0026#34;),vertex.norays=5, legend = F) `star`、`ploygon`两种形状可以指定边数，vertex.norays参数可以指定边数，默认是5角星和5边形。 1 2 3 c_net_plot(g2,vertex.color= pcutils::get_cols(4), vertex.shape=c(\u0026#34;star\u0026#34;,\u0026#34;polygon\u0026#34;), vertex.norays=sample(4:7,vcount(g2), replace = TRUE),legend = F) 添加自定义形状 add_shape 可用于向igraph/MetaNet添加新的顶点形状，提供新形状的剪切和打印功能即可。也可以在参数中列出剪裁和/或绘图函数可以使用的绘图/顶点/边参数。\n拿上述的star做一个例子，构建以下add_metanet_shape_star函数，并运行后，就可以添加上述的star形状了，并且支持color，size，frame.color等参数的修改。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 add_metanet_shape_star \u0026lt;- function() { mystar \u0026lt;- function(coords, v = NULL, params) { vertex.color \u0026lt;- params(\u0026#34;vertex\u0026#34;, \u0026#34;color\u0026#34;) if (length(vertex.color) != 1 \u0026amp;\u0026amp; !is.null(v)) { vertex.color \u0026lt;- vertex.color[v] } vertex.frame.color \u0026lt;- params(\u0026#34;vertex\u0026#34;, \u0026#34;frame.color\u0026#34;) if (length(vertex.frame.color) != 1 \u0026amp;\u0026amp; !is.null(v)) { vertex.frame.color \u0026lt;- vertex.frame.color[v] } vertex.frame.width \u0026lt;- params(\u0026#34;vertex\u0026#34;, \u0026#34;frame.width\u0026#34;) if (length(vertex.frame.width) != 1 \u0026amp;\u0026amp; !is.null(v)) { vertex.frame.width \u0026lt;- vertex.frame.width[v] } vertex.size \u0026lt;- 1 / 150 * params(\u0026#34;vertex\u0026#34;, \u0026#34;size\u0026#34;) if (length(vertex.size) != 1 \u0026amp;\u0026amp; !is.null(v)) { vertex.size \u0026lt;- vertex.size[v] } norays \u0026lt;- params(\u0026#34;vertex\u0026#34;, \u0026#34;norays\u0026#34;) if (is.null(norays)) norays=5 if (length(norays) != 1 \u0026amp;\u0026amp; !is.null(v)) { norays \u0026lt;- norays[v] } # 处理边框宽度和颜色 vertex.frame.color[vertex.frame.width \u0026lt;= 0] \u0026lt;- NA vertex.frame.width[vertex.frame.width \u0026lt;= 0] \u0026lt;- 1 # 避免宽度为0 mapply(coords[, 1], coords[, 2], vertex.color, vertex.frame.color, vertex.size, vertex.frame.width, norays, FUN = function(x, y, bg, fg, size, lwd, nor) { symbols( x = x, y = y, bg = bg, fg = fg, lwd = lwd, stars = matrix(c(size, size / 2), nrow = 1, ncol = nor * 2), add = TRUE, inches = FALSE ) } ) } igraph::add_shape(\u0026#34;star\u0026#34;, clip = igraph::shape_noclip, plot = mystar) } add_metanet_shape_star() 我们当然也可以绘制各种奇怪的多边形：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 new_polygon \u0026lt;- function(coords, v = NULL, params) { vertex.color \u0026lt;- params(\u0026#34;vertex\u0026#34;, \u0026#34;color\u0026#34;) if (length(vertex.color) != 1 \u0026amp;\u0026amp; !is.null(v)) { vertex.color \u0026lt;- vertex.color[v] } vertex.frame.color \u0026lt;- params(\u0026#34;vertex\u0026#34;, \u0026#34;frame.color\u0026#34;) if (length(vertex.frame.color) != 1 \u0026amp;\u0026amp; !is.null(v)) { vertex.frame.color \u0026lt;- vertex.frame.color[v] } vertex.frame.width \u0026lt;- params(\u0026#34;vertex\u0026#34;, \u0026#34;frame.width\u0026#34;) if (length(vertex.frame.width) != 1 \u0026amp;\u0026amp; !is.null(v)) { vertex.frame.width \u0026lt;- vertex.frame.width[v] } vertex.size \u0026lt;- 1 / 200 * params(\u0026#34;vertex\u0026#34;, \u0026#34;size\u0026#34;) if (length(vertex.size) != 1 \u0026amp;\u0026amp; !is.null(v)) { vertex.size \u0026lt;- vertex.size[v] } norays \u0026lt;- params(\u0026#34;vertex\u0026#34;, \u0026#34;norays\u0026#34;) if (is.null(norays)) norays=5 if (length(norays) != 1 \u0026amp;\u0026amp; !is.null(v)) { norays \u0026lt;- norays[v] } weird_polygon_coords \u0026lt;- function(x, y, size) { theta \u0026lt;- seq(0, 2 * pi, length.out = 7)[-7] # 6个顶点 # 每个顶点的半径随机变化（size 的 0.5~1.5 倍） random_size \u0026lt;- size * runif(6, min = 0.5, max = 1.5) x_coords \u0026lt;- x + random_size * cos(theta) y_coords \u0026lt;- y + random_size * sin(theta) list(x = x_coords, y = y_coords) } # 处理边框宽度和颜色 vertex.frame.color[vertex.frame.width \u0026lt;= 0] \u0026lt;- NA vertex.frame.width[vertex.frame.width \u0026lt;= 0] \u0026lt;- 1 mapply(coords[, 1], coords[, 2], vertex.color, vertex.frame.color, vertex.size, vertex.frame.width, FUN = function(x, y, bg, fg, size, lwd) { coords \u0026lt;- weird_polygon_coords(x, y, size) polygon(coords$x, coords$y, col = bg, border = fg, lwd = lwd) } ) } igraph::add_shape(\u0026#34;new_polygon\u0026#34;, clip = igraph::shape_noclip, plot = new_polygon) 然后用用我们新定义的随机奇怪多边形来绘制网络图：\n1 2 3 c_net_plot(g2,vertex.color= pcutils::get_cols(4), vertex.shape=c(\u0026#34;new_polygon\u0026#34;), legend = F) 注意，最好是用symbols()或者polygon()函数来绘制形状，其他的绘图函数比如points()也可以这样添加形状，但是这样添加的形状大小缩放的逻辑和默认形状的不一致，所以我最后也是放弃了支持ggplot和graphics默认的形状1-25，但感觉有上述这些大部分形状也够了。\n","date":"2025-05-22T00:00:00Z","image":"https://jb-cao.github.io/Cao-blog/p/metanet-shape/index.en_files/figure-html/unnamed-chunk-6-1_hu_e254bb19232848ba.png","permalink":"https://jb-cao.github.io/Cao-blog/p/metanet-shape/","title":"使用MetaNet添加更多节点形状"},{"content":"Motivation SCI论文投稿时，我们要整理好作者和对应的单位，一般用数字上标对应下面的单位信息，然后用一些特殊符号如“#，*”来代表贡献相同的作者或者通讯作者。\n一般一个课题组出来的成果，只有几个作者的情况我们手打一下就好了。但现在的研究更多都是交叉性质的，可能会涉及到很多课题组合作，一些大的研究可能还会有几十个作者和单位，比如下面一篇cell，一页纸都写不完。\n一次手打完，不改了就还好，但这时老师叫你把某个单位顺序改一下，或者新加了个作者和单位，那么上面所有的数字上标都要随之改变，改起来就比较费劲了，还容易出错😂。\n所以我简单写了一个R函数，实现从整理好的作者-单位表格中自动生成符合规范的作者-单位 Rmarkdown文件，然后点击一下knit就可以生成对应的word文件，上标也不需要自己手动设置。如果需要改顺序也是在表格中调整一下重新生成即可，还是比较方便的。\n作者-单位 拿一篇cell文章《Molecular Choreography of Acute Exercise》做例子。\n准备一个表格，至少包含两列列名为Author和Affiliation，注意这里的作者顺序就是文章里想要的顺序，默认的单位顺序是根据作者顺位生成的： 如果要指定单位的顺序，那就再准备一列Affiliation的表格，保持想要的单位顺序： 如果还要添加额外的符号上标，如共一的#和通讯的*，再准备一个两列表格，Author和Note： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 安装最新版的pcutils # devtools::install_github(\u0026#34;Asa12138/pcutils\u0026#34;) library(pcutils) df=readxl::read_excel(\u0026#34;~/Desktop/test_author.xlsx\u0026#34;) pcutils::generate_and_write_author_rmd(df,file = \u0026#34;~/Desktop/test_author.rmd\u0026#34;) # 如果要指定单位的顺序 affiliation_df=readxl::read_excel(\u0026#34;~/Desktop/test_author.xlsx\u0026#34;,sheet = 2) pcutils::generate_and_write_author_rmd(df,file = \u0026#34;~/Desktop/test_author.rmd\u0026#34;, affiliation_df = affiliation_df) #如果要添加额外的符号上标 author_note=readxl::read_excel(\u0026#34;~/Desktop/test_author.xlsx\u0026#34;,sheet = 3) pcutils::generate_and_write_author_rmd(df,file = \u0026#34;~/Desktop/test_author.rmd\u0026#34;, affiliation_df = affiliation_df, author_note = author_note) 此时会输出一个test_author.rmd的文件，然后我们用Rstudio打开后点一下knit键进行编织，就可以得到word文件了：\n上标格式也不用自己麻烦一个一个点了，如果要修改顺序也比较方便。\n作者贡献 CRediT（贡献者角色分类法）是一种高级分类法，该方法将作者的贡献划分为14个类别，并对每个类别的角色详细精确地定义了作者的贡献。\n1 2 3 ## Warning: \u0026#39;xfun::attr()\u0026#39; is deprecated. ## Use \u0026#39;xfun::attr2()\u0026#39; instead. ## See help(\u0026#34;Deprecated\u0026#34;) 贡献者角色（中文） 贡献者角色（英文） 定义 论文构思 Conceptualization 产生想法，构造或演绎发展主要的研究目的。 数据管理 Data curation 为数据的首用和后续复用产生元数据，整理数据，维护研究数据（包括软件或程序）。 形式分析 Formal analysis 使用统计、数学、计算或其他形式分析技术分析或合成研究数据。 获取资助 Funding acquisition 为了项目研究成果能够发表而去争取并获得资助。 调查研究 Investigation 实施研究和执行调查过程，特别是从事实验研究或收集数据和证据。 方法论 Methodology 开发或设计研究用的方法，建立模型。 项目管理 Project administration 为研究活动的策划和执行进行管理和协调。 提供资源 Resources 提供研究材料、试剂、病例、实验室样品、动物、仪器、计算设备资源或其他分析工具。 软件 Software 编程，研发软件，设计计算机程序，实施执行计算机程序及支持算法，测试已有的程序。 指导 Supervision 监督和领导研究活动的策划和执行，包括对核心成员以外的人员进行指导。 验证 Validation 对研究结果、实验或其他研究输出内容的复制和重现进行核实验证，包括整体的和部分的核实验证。 可视化呈现 Visualization 对发表的内容进行准备、创建或表述，特别是内容或数据的可视化展现。 初稿写作 Writing – original draft 对发表的内容进行准备、创建或表述，特别是撰写初稿，包括实质性翻译。 审核与编辑写作 Writing – review \u0026amp; editing 对原始研究团队提出的发表内容进行准备、创建或表述，特别是评论、注释或修改，包括发表前和发表后所发生的这些工作。 很多期刊都会让我们以CRediT的格式展示作者贡献，一般手打也很方便。但有时候会统一将名称进行缩写，这里也提供一个函数用来生成，准备一个两列表：\n1 2 author_contributions=readxl::read_excel(\u0026#34;~/Desktop/test_author.xlsx\u0026#34;,sheet = 4) cat(pcutils::format_credit_contributions(author_contributions, short_name = TRUE)) 1 ## Conceptualization, K.C., K.J.M., F.H., M.P.S.; Data curation, K.C., S.W., K.J.M.; Formal analysis, K.C., S.W., K.J.M., D.H.; Methodology, K.C., S.W., K.J.M., F.H., M.P.S.; Project administration, K.C., F.H., M.P.S.; Supervision, F.H., M.P.S.; Visualization, K.C., S.W., K.J.M., D.H., F.H., M.P.S.; Writing – original draft, K.C., F.H., M.P.S. ","date":"2025-05-06T00:00:00Z","image":"https://jb-cao.github.io/Cao-blog/p/author_affiliation/images/Screenshot%202025-05-06%20at%2017.22.32_hu_fc64b65e95a529c9.png","permalink":"https://jb-cao.github.io/Cao-blog/p/author_affiliation/","title":"论文作者和单位太多？如何快速整理和修改"},{"content":"抗生素耐药性（Antimicrobial Resistance, AMR）是21世纪全球公共卫生面临的重大挑战之一。随着抗生素的广泛使用，耐药菌株和抗生素耐药基因（Antibiotic Resistance Genes, ARGs）在医院环境中迅速扩散，尤其是在重症监护病房（ICU）这样高风险的医疗场所。ICU医护人员因长期暴露于高浓度抗生素和耐药菌的环境中，其肠道微生物群是否受到显著影响，成为一个备受关注的研究课题。2025年发表在《Critical Care》期刊上的一篇多中心、跨区域研究通过宏基因组学技术，系统比较了ICU医护人员与健康对照组的肠道ARG丰度及微生物群组成，揭示了ICU医护人员肠道ARG显著升高的现象。\nPaper Info 标题：Elevated antibiotic resistance gene abundance of ICU healthcare workers, a multicentre, cross-sectional study 译名：多中心横断面研究揭示ICU医护人员抗生素耐药基因丰度升高 期刊：Critical Care (IF：8.8) 发表时间：2025年4月30日 链接：https://doi.org/10.1186/s13054-025-05408-5 引言 抗生素耐药性被世界卫生组织列为全球十大公共卫生威胁之一。据《Lancet》2024年报道，1990年至2021年间，全球因AMR导致的死亡人数持续上升，预计未来几十年将进一步加剧。医院作为抗生素使用最密集的场所，是ARG传播的主要来源。ICU尤为突出，因其患者病情危重、抗生素使用频繁、耐药菌（如ESKAPE病原体：粪肠球菌、肺炎克雷伯菌等）高发，导致环境中的ARG浓度远高于外部环境。\nICU医护人员每天接触高危患者、污染表面及空气中的耐药菌，面临较高的职业暴露风险。先前的研究表明，医护人员可能通过直接接触、空气传播或交叉污染成为耐药菌的携带者。然而，传统研究多依赖细菌培养技术，样本量小，难以全面揭示ARG的传播动态。宏基因组学技术的兴起为研究ARG提供了更精确的工具，使研究人员能够深入分析医护人员肠道微生物群的耐药基因特征。\n该研究提出一个核心问题：ICU医护人员的肠道ARG丰度是否高于健康人群？此外，ICU职业暴露的时长是否与ARG丰度相关？通过多中心、跨区域的样本采集和宏基因组学分析，研究旨在填补这一领域的知识空白，为医院感染防控提供科学依据。\n研究设计与方法 这项前瞻性、多中心、横断面研究在中国浙江和河南的八家医疗中心开展，时间为2024年1月至2月。研究对象包括191名ICU医护人员（医生、护士、护理助理）和99名健康对照组，共290人。健康对照组来自常规体检人群，无医疗相关工作背景。研究通过粪便样本的宏基因组测序，比较两组的肠道ARG丰度、ARG多样性及微生物群组成。\n纳入标准：年龄大于18岁，签署知情同意书。 排除标准：存在胃肠道疾病、恶性肿瘤、精神疾病；近6个月使用广谱抗生素（如万古霉素、头孢吡肟等）；孕妇；健康对照组需无医疗相关工作经历。 研究团队收集粪便样本，提取DNA后使用Illumina NovaSeq X Plus平台进行双末端测序（2×150 bp）。通过Fastp去除低质量读数，Bowtie2过滤人类基因组序列，Kraken2进行分类学分析，RGI结合CARD数据库识别ARG。ARG丰度以每千碱基每百万映射读数（RPKM）标准化，ARG丰富度以识别的ARG总数量化。研究还通过Kraken2和RGI的读数ID匹配，追踪ARG的细菌宿主。\n主要结局为比较ICU医护人员与健康对照组的ARG丰度（以RPKM为指标）。使用广义线性模型（GLM）进行分析，矫正了年龄、性别和BMI等混杂因素。次要结局为探索ICU职业暴露时长与ARG丰度的关系，使用限制性立方样条（RCS）模型。亚组分析和敏感性分析进一步验证结果的稳健性，分析工具包括R软件及其相关包（如pctax、rms）。\n结果 ICU医护人员肠道ARG丰度显著升高 研究发现，ICU医护人员的总ARG丰度显著高于健康对照组（调整后倍数变化=1.22，95%置信区间：1.12-1.34，p\u0026lt;0.001）。具体而言，来源于粪肠球菌、肺炎克雷伯菌和肠杆菌属（包括大肠杆菌）的ARG丰度在医护人员中显著增加。特别值得注意的是，与喹诺酮类抗生素耐药相关的qnrE1基因（log2倍数变化=14.03，p-adj=0.02）以及与β-内酰胺类抗生素耐药相关的ACT-12（log2倍数变化=11.23，p-adj=0.03）和MIR-12（log2倍数变化=11.17，p-adj=0.04）基因在医护人员中显著上调。\nARG多样性与微生物群组成差异 ICU医护人员的ARG α多样性（丰富度和Shannon指数）显著高于对照组（p\u0026lt;0.001，p=0.02），β多样性也存在显著差异（Adonis R²=0.0396，p=0.001）。243个ARG在医护人员中显著上调，而仅9个ARG下调。此外，医护人员的肠道细菌组成显示出更高的α多样性（p=0.04）和β多样性（Adonis R²=0.0419，p=0.001），其中克雷伯菌属（如Klebsiella grimontii，log2倍数变化=5.93，p-adj=0.004）和乳酸乳球菌（log2倍数变化=5.78，p-adj=0.009）显著上调。\n职业暴露时长与ARG丰度无关 出乎意料的是，研究未发现ICU职业暴露时长与ARG丰度之间的显著线性或非线性关系（p for overall=0.96，p for nonlinear=0.84）。这表明ARG丰度的增加可能在医护人员职业生涯的早期即已发生。\n4. 亚组与敏感性分析 性别差异：男性医护人员的ARG丰度与职业暴露的关联更强（β=0.29，p\u0026lt;0.001）相比女性（β=0.13，p=0.03）。 地区差异：河南的医护人员ARG丰度高于浙江（倍数变化=1.20 vs. 1.12）。 职业差异：护理助理的ARG丰度最高（倍数变化=1.33），其次为医生（1.18）和护士（1.08）。 讨论 临床意义 感染防控的新视角：ICU医护人员作为潜在的ARG携带者，可能在医院内外的耐药菌传播中扮演重要角色。研究提示需加强对医护人员的感染防控措施，如优化手部卫生、加强环境消毒。 精准医疗的潜力：宏基因组学技术为监测ARG提供了高分辨率工具，可用于识别高风险人群和制定针对性的干预措施。 职业健康保障：医护人员肠道微生物群的变化可能影响其长期健康，需进一步研究这些变化的临床意义。 公共卫生意义 研究结果支持“One Health”框架，强调人类、动物和环境健康的互联性。医院作为ARG的“热点”，其防控策略应扩展到医护人员和社区。减少不必要的抗生素使用、加强耐药性监测是应对AMR的关键。\n局限性 地域局限：研究仅限于中国人群，结论的普遍性需进一步验证。 因果关系：作为观察性研究，无法确定职业暴露与ARG升高之间的因果关系。 未测混杂因素：如旅行史、住院史等可能影响结果。 临床相关性：ARG的升高是否导致实际感染风险尚不明确。 未来研究方向 纵向研究：通过长期随访，探索ARG丰度变化的动态和影响因素。 全球合作：开展跨国研究，验证不同地区医护人员的ARG特征。 干预措施：测试感染防控策略（如益生菌干预、环境净化）对ARG丰度的影响。 健康影响：研究ARG升高对医护人员健康的潜在影响，如免疫功能或代谢疾病风险。 小结 这项多中心研究揭示了ICU医护人员肠道ARG丰度和微生物群多样性的显著升高，提示职业暴露可能是重要驱动因素。尽管未发现暴露时长与ARG丰度的直接关联，但研究强调了医院环境在耐药基因传播中的关键作用。宏基因组学技术的应用为理解AMR动态提供了新视角，未来需进一步探索其临床和公共卫生意义，以优化感染防控策略，保护医护人员和患者的健康。\nCARD数据库中药物类型整理 为了方便分析，我整合了CARD数据库的描述信息到ReporterScore包中，可以通过以下代码调取：\n1 2 3 4 if(!require(ReporterScore))remotes::install_github(\u0026#34;Asa12138/ReporterScore\u0026#34;) library(ReporterScore) CARDinfo \u0026lt;- load_CARDinfo() head(CARDinfo$ARO_index) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 ## ARO Accession CVTERM ID Model Sequence ID Model ID ## 3005099 ARO:3005099 43314 6143 3831 ## 3002523 ARO:3002523 38923 8144 1781 ## 3002524 ARO:3002524 38924 85 746 ## 3002525 ARO:3002525 38925 4719 1246 ## 3002526 ARO:3002526 38926 228 1415 ## 3002527 ARO:3002527 38927 5510 2832 ## Model Name ## 3005099 23S rRNA (adenine(2058)-N(6))-methyltransferase Erm(A) ## 3002523 AAC(2\u0026#39;)-Ia ## 3002524 AAC(2\u0026#39;)-Ib ## 3002525 AAC(2\u0026#39;)-Ic ## 3002526 AAC(2\u0026#39;)-Id ## 3002527 AAC(2\u0026#39;)-Ie ## ARO Name ## 3005099 23S rRNA (adenine(2058)-N(6))-methyltransferase Erm(A) ## 3002523 AAC(2\u0026#39;)-Ia ## 3002524 AAC(2\u0026#39;)-Ib ## 3002525 AAC(2\u0026#39;)-Ic ## 3002526 AAC(2\u0026#39;)-Id ## 3002527 AAC(2\u0026#39;)-Ie ## Protein Accession DNA Accession AMR Gene Family ## 3005099 AAB60941.1 AF002716.1 Erm 23S ribosomal RNA methyltransferase ## 3002523 AAA03550.1 L06156.2 AAC(2\u0026#39;) ## 3002524 AAC44793.1 U41471.1 AAC(2\u0026#39;) ## 3002525 CCP42991.1 AL123456.3 AAC(2\u0026#39;) ## 3002526 AAB41701.1 U72743.1 AAC(2\u0026#39;) ## 3002527 CAC32082.1 AL583926.1 AAC(2\u0026#39;) ## Drug Class ## 3005099 lincosamide antibiotic;macrolide antibiotic;streptogramin antibiotic ## 3002523 aminoglycoside antibiotic ## 3002524 aminoglycoside antibiotic ## 3002525 aminoglycoside antibiotic ## 3002526 aminoglycoside antibiotic ## 3002527 aminoglycoside antibiotic ## Resistance Mechanism CARD Short Name length Drug_Class ## 3005099 antibiotic target alteration Spyo_ErmA_MLSb 732 MLS ## 3002523 antibiotic inactivation AAC(2\u0026#39;)-Ia 537 Aminoglycoside ## 3002524 antibiotic inactivation AAC(2\u0026#39;)-Ib 588 Aminoglycoside ## 3002525 antibiotic inactivation AAC(2\u0026#39;)-Ic 546 Aminoglycoside ## 3002526 antibiotic inactivation AAC(2\u0026#39;)-Id 633 Aminoglycoside ## 3002527 antibiotic inactivation AAC(2\u0026#39;)-Ie 549 Aminoglycoside 注意CARD数据库中Drug Class，一个ARO可以对应很多种药物类型，不是很方便整合，所以我根据《Assessment of global health risk of antibiotic resistance genes》中的规则新增了一列“Drug_Class”。\nARGs were manually reclassified based on the drugs to which they confer resistance. ARGs referring to penam, cephalosporin, carbapenem, cephamycin, penem and monobactam were grouped into the beta-lactam class. ARGs referring to macrolides, lincosamides and streptogramins were grouped into the MLS class. ARGs referring to more than one drug class were grouped into the multidrug class.\n1 2 3 library(pcutils) gghuan(dplyr::count(CARDinfo$ARO_index,Drug_Class))+ scale_fill_pc() ","date":"2025-05-02T00:00:00Z","image":"https://jb-cao.github.io/Cao-blog/p/critical-care/images/fig1_hu_22838dfac66ffc73.png","permalink":"https://jb-cao.github.io/Cao-blog/p/critical-care/","title":"Critical Care: ICU医护人员肠道抗生素耐药基因显著增加"},{"content":"","date":"2025-04-27T00:00:00Z","permalink":"https://jb-cao.github.io/Cao-blog/p/bgckit-bgc/","title":"BGCkit：组学数据BGC分析流程"},{"content":"Introduction 在基因组学研究中，比较基因组学（Comparative Genomics）是一项核心方法，它通过对不同物种或同一物种不同个体的基因组进行比较，揭示基因的功能、结构和进化历史。在这一领域中，“同线性（synteny）”和“共线性（collinearity）”是关键概念，它们在理解基因组结构的保守性和演化过程中起着重要作用。\n在基因组比较中，“同线性”和“共线性”常被用来描述不同物种或同一物种不同个体之间基因组结构的保守性。同线性指的是在不同基因组中，一组同源基因位于各自染色体上的相似位置，而不考虑这些基因的排列顺序。共线性则进一步要求这些同源基因在染色体上的排列顺序也保持一致。简而言之，共线性是同线性的一种更严格形式。\n根据同线性区域的大小和复杂性，研究人员将其分为“宏同线性（macrosynteny）”和“微同线性（microsynteny）”。宏同线性通常指染色体级别的大尺度保守区域，适用于研究远缘物种之间的基因组结构演化；而微同线性则关注较小的基因簇或基因对之间的保守性，常用于近缘物种或亚种之间的精细比较。\n同线性分析在比较基因组学中具有广泛的应用价值：\n揭示基因组进化历史：通过识别同线性区域，可以推断物种间的基因组重排事件，如倒位、易位、重复和缺失等，从而重建基因组的进化轨迹。\n识别同源基因：同线性分析有助于区分直系同源基因（orthologs）和旁系同源基因（paralogs），这对于功能基因的注释和研究具有重要意义。\n研究全基因组复制事件：在植物等多倍体物种中，同线性分析可用于检测和分析全基因组复制（WGD）事件，理解基因组扩张与物种多样性的关系。\n辅助基因功能预测：通过比较模型生物与目标物种之间的同线性区域，可以推测未知基因的功能，尤其在缺乏实验验证的情况下尤为重要。\n评估基因组组装质量：同线性分析可以作为评估新组装基因组质量的工具，检测可能的组装错误或缺失区域。\n随着高通量测序技术的发展，许多生物信息学工具被开发用于同线性分析和可视化，搜索一下就有一大堆，尤其是可视化工具，所以这里只简单提一下我知道的各种工具，大家可以根据喜好自行选择尝试使用。\n分析软件 同线性分析涉及到全基因组比对，是一个计算密集型的过程。尽管各种软件在输入输出格式上有所差异，但它们的共同目标是识别基因组之间的同线性区块（syntenic blocks），即在不同基因组中保守的基因排列区域。\nMUMmer https://github.com/mummer4/mummer\n简介\nMUMmer 是一个用于快速比对大型序列的开源软件包。它能够高效地比对整个基因组、基因组组装结果以及部分（草图）基因组序列。MUMmer 的最新版本（4.x）引入了新的后缀树算法，进一步提高了比对效率。\n安装\nMUMmer 可在其 GitHub 页面上获取\n1 2 3 4 5 tar -zxvf mummer-4.0.0beta2.tar.gz cd mummer-4.0.0beta2 ./configure --prefix=/data/tengwenkai/software/MUMmer4.0 make make install 或者conda安装：conda install bioconda::mummer\n简单使用\nMUMmer 提供了多个实用工具，其中 nucmer 是最常用的比对脚本，用于标准的 DNA 序列比对。例如，使用 nucmer 对两个基因组进行比对后，可以使用 show-coords 工具查看比对坐标。此外，promer 工具可以基于输入序列的六帧翻译生成比对结果，适用于蛋白质序列的比对。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 nucmer [options] \u0026lt;Reference\u0026gt; \u0026lt;Query\u0026gt; Reference：参考基因组，含有多条序列的FASTA文件名 Query：要匹配的基因组，含有多条序列的FASTA文件名 --mum, --mumreference(默认), --maxmatch：与mumer相同 -b, --breaklen：一个比对尝试延伸的最大距离，默认为200 -c, --mincluster：一个匹配聚类簇的最短长度，默认为65 -D, --diagdiff：一个聚类中两个邻接匹配的最大对角差分，默认5 -d, --diagfactor一个聚类中两个邻接匹配的最大对角差分与gap长度的比值，默认为0.12 --noextend：不执行聚类簇延长步骤，默认关闭 -f, --forward：只使用查询序列的正向链 -g, --maxgap：一个聚类中两个邻接匹配的最大gap长度，默认为90 -l, --minmatch：一个匹配的最短长度，默认为20 -L, --minalign：一个聚类延伸后比对的最短长度，默认为0 -r, --reverse：只使用查询序列的反向互补链 --nosimplify：不简化比对，当使用序列与自身比对来寻找重复时可以选此选项，默认关闭 -p, --prefix：输出结果delta文件的前缀，默认为out --sam-short：保存SAM短格式到文件路径 --sam-long：保存SAM长格式到文件路径 -t, --threads：程序运行使用的核数 1 2 3 4 # 使用MUMmer进行局部比对（适合低相似度基因组） nucmer --prefix=out genome1.fna genome2.fna delta-filter -q -r out.delta \u0026gt; out.filtered.delta # 保留唯一最佳比对 show-coords -rcl out.filtered.delta \u0026gt; out.coords # 输出坐标 MUMmer 的高效性能使其成为进行全基因组比对和同线性分析的有力工具，尤其适用于处理大型基因组数据。\nMCScanX https://github.com/wyp1125/MCScanX\n简介\nMCScanX 是一个用于检测基因组间同线性和共线性关系的工具包。它实现了改进的 MCScan 算法，能够识别同线性区块，并提供多种可视化和分析工具。\n安装\nMCScanX 可在其 GitHub 页面上获取，下载源代码并按照说明进行编译安装。\n1 2 3 unzip MCscanX.zip cd MCScanX make 简单使用\nMCScanX 的使用需要两个主要输入文件：\nBLASTP 比对结果文件（xyz.blast）\n该文件为标准的 BLASTP 输出，格式为 m8。每行表示一对同源基因的比对结果，包含以下字段：\n1 gene1 gene2 identity alignment_length mismatches gap_opens q_start q_end s_start s_end e_value bit_score 示例：\n1 AT1G50920 AT1G50920 100.00 671 0 0 1 671 1 671 0.0 1316 建议使用以下命令生成该文件：\n1 blastall -i query_file -d database -p blastp -e 1e-10 -b 5 -v 5 -m 8 -o xyz.blast 其中，-b 5 -v 5 参数限制每个基因的比对结果为前 5 个，以提高分析的准确性。\n基因注释文件（xyz.gff）\n该文件包含基因在染色体上的位置信息，格式为制表符分隔的四列：\n1 chromosome gene_id start_position end_position 示例：\n1 2 at1 AT1G01010 3631 5899 at1 AT1G01020 5928 8737 注意事项：\nchromosome 字段应使用两字母的物种缩写加染色体编号，例如 Arabidopsis thaliana 的第二染色体应为 at2。 每个基因只能出现一次，重复的基因会导致错误。 该文件可通过解析 GFF3 文件生成。 在进行多个基因组比较时，可将所有物种的 BLAST 输出合并为一个 xyz.blast 文件，所有基因注释信息合并为一个 xyz.gff 文件。\n将 xyz.blast 和 xyz.gff 文件放在同一目录下，使用以下命令运行 MCScanX：\n1 ./MCScanX xyz 其中，xyz 为输入文件的前缀，MCScanX 将自动识别并处理对应的 .blast 和 .gff 文件。\n输出结果解析\n运行完成后，MCScanX 会生成以下主要输出：\nxyz.collinearity 文件\n该文本文件包含识别到的同线性区块信息，每个区块以 ## Alignment 开头，包含区块编号、得分、e-value、基因对数量等信息。示例：\n1 2 3 4 5 ## Alignment 0: score=9171.0 e_value=0 N=187 at1\u0026amp;at1 plus 0-0: AT1G17240 AT1G72300 0 0-1: AT1G17290 AT1G72330 0 ... 0-186: AT1G22340 AT1G78270 3e-174 每行表示一对共线性基因对，最后一列为比对的 e-value。\nxyz.html 目录\n该目录包含多个 HTML 文件，用于可视化同线性区块在染色体上的分布。每个 HTML 文件对应一个参考染色体，展示了该染色体上的基因及其与其他染色体的同线性关系。这些文件可通过网页浏览器查看，便于直观分析。\n此外，MCScanX 提供了多种可视化工具，如 dot plot、circle plot 等，便于用户直观地观察基因组间的同线性关系。\nMugsy https://github.com/kloetzl/mugsy\n简介\nMugsy 是一个用于多个完整基因组比对的工具，特别适用于比对密切相关的基因组。它不需要参考基因组，能够处理混合的草图和完整基因组数据，识别包括重复、重排和大规模序列增减等在内的遗传变异。\n安装\nMugsy 可在其官方网站上获取\n1 2 3 4 5 6 7 wget https://sourceforge.net/projects/mugsy/files/latest/download tar xvzf download #将Mugsy安装路径加到PATH里 vim ~/.bashrc export PATH=\u0026#34;/picb/evolgen/users/gushanshan/software/mugsy/mugsy_1.2.2:$PATH\u0026#34; source ~/.bashrc 或者conda安装：conda install bioconda::mugsy\n简单使用\nMugsy 的输入为多组基因组序列（FASTA 格式）。文件要求：\n一个或多个FASTA文件 每个文件应该包括单个物种的所有序列 FASTA的header中不能包括：或- 模糊字符将被转换成N 使用示例命令：\n1 ./mugsy --directory output_dir genome1.fasta genome2.fasta genome3.fasta 运行后，Mugsy 会在指定的输出目录中生成多个文件，包括比对结果和同线性区块信息。这些结果可用于进一步的比较基因组分析。\n可视化软件 可以用来画synteny图的软件就太多了，各种编程语言都有，还有很多在线网站，风格各异，这里推荐一些，可以根据demo效果或者整理input格式的难度挑选一下：\nR 我用来做可视化最多的工具还是R语言，所以优先介绍几个R包了：\ngggenomes https://thackl.github.io/gggenomes/index.html\ngggenomes是用于比较基因组学的多功能图形包。基于ggplot的语法，非常好上手用，主页提供的demo代码也非常好看：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 library(gggenomes) # to inspect the example data shipped with gggenomes data(package=\u0026#34;gggenomes\u0026#34;) gggenomes( genes = emale_genes, seqs = emale_seqs, links = emale_ava, feats = list(emale_tirs, ngaros=emale_ngaros, gc=emale_gc)) |\u0026gt; add_sublinks(emale_prot_ava) |\u0026gt; sync() + # synchronize genome directions based on links geom_feat(position=\u0026#34;identity\u0026#34;, size=6) + geom_seq() + geom_link(data=links(2)) + geom_bin_label() + geom_gene(aes(fill=name)) + geom_gene_tag(aes(label=name), nudge_y=0.1, check_overlap = TRUE) + geom_feat(data=feats(ngaros), alpha=.3, size=10, position=\u0026#34;identity\u0026#34;) + geom_feat_note(aes(label=\u0026#34;Ngaro-transposon\u0026#34;), data=feats(ngaros), nudge_y=.1, vjust=0) + geom_wiggle(aes(z=score, linetype=\u0026#34;GC-content\u0026#34;), feats(gc), fill=\u0026#34;lavenderblush4\u0026#34;, position=position_nudge(y=-.2), height = .2) + scale_fill_brewer(\u0026#34;Genes\u0026#34;, palette=\u0026#34;Dark2\u0026#34;, na.value=\u0026#34;cornsilk3\u0026#34;) syntenyPlotteR https://github.com/Farre-lab/syntenyPlotteR\n这个包也是用ggplot画的，但是不是ggplot语法，draw.linear函数输出包含线性样式对齐的图像文件。默认情况下，该函数将文件保存到临时目录，可以使用目录参数（即Directory =\u0026ldquo;path/to/to/Directory\u0026rdquo;）覆盖。\n1 2 3 4 5 6 library(syntenyPlotteR) old_wd=getwd() setwd(system.file(\u0026#34;extdata\u0026#34;,package = \u0026#34;syntenyPlotteR\u0026#34;)) # example data draw.linear(\u0026#34;example_linear\u0026#34;, \u0026#34;example_lengths.txt\u0026#34;, \u0026#34;example_alignment_1.txt\u0026#34;, \u0026#34;example_alignment_2.txt\u0026#34;, \u0026#34;example_alignment_3.txt\u0026#34;) setwd(old_wd) macrosyntR https://github.com/SamiLhll/macrosyntR\n这是一个用于在全基因组范围内评估同线性保守性的R软件包。它通过读取正交同源基因表和BED格式的基因组注释文件，自动识别显著保守的连锁群，并基于网络贪婪算法将这些连锁群排序展示在牛津网格图或弦图中。\n准备输入数据\n要开始比较物种，您需要准备以下两类文件：\n正交同源基因表（两列格式）\n• 包含待比较物种之间的正交同源基因对（每行一对）。\n• 可通过工具生成，例如：\n◦ rbhxpress 的输出结果\n◦ OrthoFinder 的结果\nBED 格式的基因组注释文件\n• 列出所有物种的正交同源基因的基因组坐标和序列名称。\n• 关键要求：\n◦ BED 文件中的基因名称必须与正交同源基因表（文件1）的列名匹配。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 library(macrosyntR) # Load table of orthologs and integrate with genomic coordinates : my_orthologs_table \u0026lt;- load_orthologs(orthologs_table = system.file(\u0026#34;extdata\u0026#34;,\u0026#34;Bflo_vs_Pech.tab\u0026#34;,package=\u0026#34;macrosyntR\u0026#34;), bedfiles = c(system.file(\u0026#34;extdata\u0026#34;,\u0026#34;Bflo.bed\u0026#34;,package=\u0026#34;macrosyntR\u0026#34;), system.file(\u0026#34;extdata\u0026#34;,\u0026#34;Pech.bed\u0026#34;,package=\u0026#34;macrosyntR\u0026#34;))) # Draw an oxford grid : p1 \u0026lt;- plot_oxford_grid(my_orthologs, sp1_label = \u0026#34;B.floridae\u0026#34;, sp2_label = \u0026#34;P.echinospica\u0026#34;) p1 # Automatically reorder the Oxford grid and color the detected clusters (communities): p2 \u0026lt;- plot_oxford_grid(my_orthologs, sp1_label = \u0026#34;B.floridae\u0026#34;, sp2_label = \u0026#34;P.echinospica\u0026#34;, reorder = TRUE, color_by = \u0026#34;clust\u0026#34;) p2 # Plot the significant linkage groups : my_macrosynteny \u0026lt;- compute_macrosynteny(my_orthologs) p3 \u0026lt;- plot_macrosynteny(my_macrosynteny) p3 # Call the reordering function, test significance and plot it : my_orthologs_reordered \u0026lt;- reorder_macrosynteny(my_orthologs) my_macrosynteny \u0026lt;- compute_macrosynteny(my_orthologs_reordered) p4 \u0026lt;- plot_macrosynteny(my_macrosynteny) p4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # load data my_orthologs_with_3_sp \u0026lt;- load_orthologs(orthologs_table = system.file(\u0026#34;extdata\u0026#34;,\u0026#34;Single_copy_orthologs.tsv\u0026#34;,package=\u0026#34;macrosyntR\u0026#34;), bedfiles = c(system.file(\u0026#34;extdata\u0026#34;,\u0026#34;Bflo.bed\u0026#34;,package=\u0026#34;macrosyntR\u0026#34;), system.file(\u0026#34;extdata\u0026#34;,\u0026#34;Pech.bed\u0026#34;,package=\u0026#34;macrosyntR\u0026#34;), system.file(\u0026#34;extdata\u0026#34;,\u0026#34;Pyes.bed\u0026#34;,package=\u0026#34;macrosyntR\u0026#34;))) # Change the chromosome names to keep only numbers levels(my_orthologs_with_3_sp$sp1.Chr) \u0026lt;- stringr::str_replace(levels(my_orthologs_with_3_sp$sp1.Chr),\u0026#34;BFL\u0026#34;,\u0026#34;\u0026#34;) levels(my_orthologs_with_3_sp$sp2.Chr) \u0026lt;- stringr::str_replace(levels(my_orthologs_with_3_sp$sp2.Chr),\u0026#34;PEC\u0026#34;,\u0026#34;\u0026#34;) levels(my_orthologs_with_3_sp$sp3.Chr) \u0026lt;- stringr::str_replace(levels(my_orthologs_with_3_sp$sp3.Chr),\u0026#34;chr\u0026#34;,\u0026#34;\u0026#34;) # Plot an automatically ordered chord diagram colored by the linkage groups : plot_chord_diagram(my_orthologs_with_3_sp, species_labels = c(\u0026#34;B. flo\u0026#34;,\u0026#34;P. ech\u0026#34;, \u0026#34;P. yes\u0026#34;), color_by = \u0026#34;LGs\u0026#34;) + theme(legend.position = \u0026#34;none\u0026#34;) # The linkage groups were automatically computed but you can also get them as a table using : my_linkage_groups \u0026lt;- compute_linkage_groups(my_orthologs_with_3_sp) Python plotsr https://github.com/schneebergerlab/plotsr\nPlotsr使用了多个染色体级组件之间的基因组结构注释来产生多个基因组之间同义和结构重排的高质量可视化：\n示例里面用了minimap2对齐基因组，并使用SamTools索引对齐BAM文件，然后用Syri在基因组之间找到同线性和结构重排，最后用Plotsr做可视化。\nJCVI https://github.com/tanghaibao/jcvi\nJCVI 库是一个基于 Python 的多功能工具库，发在了imeta上面，其模块化设计提供了一系列高效工具，涵盖以下核心功能：\n格式解析与数据操作 可视化与图形生成 基因组算法支持 开发与维护理念 我们关注其synteny图的可视化：\npyGenomeViz https://github.com/moshi4/pyGenomeViz\npyGenomeViz 是一款基于 matplotlib 开发的 Python 基因组可视化工具包，专注于 比较基因组学 分析。该工具旨在以简洁美观的方式绘制 多基因组间的特征比对 和 序列相似性关联。\n• 支持输入格式：Genbank / GFF 格式文件\n• 输出格式灵活：可保存为 JPG、PNG、SVG、PDF 或 HTML\n• 交互式可视化：在 Jupyter Notebook 中动态调整与查看\n• 自动化分析集成：可嵌入基因组分析脚本或工作流，实现批量绘图\n（适用于 基因组共线性分析、基因簇比较 和 进化研究 等场景。）\n这个工具主页的介绍也非常详细，可以一步一步学习\nPerl circos https://circos.ca/\n鼎鼎大名的circos，这个值得有空单独介绍了，能画出来的图很夸张。\n网上的教程也非常多，可以跟着官方教程仔细学一遍：https://circos.ca/support/getting_started/。 我们可以通过修改配置文件一步一步的画出自己想要的图。\nGenomeSyn https://github.com/jmsong2/GenomeSyn\n这个软件内置了MUMmer帮忙跑分析，属于是一键出图了，我们也可以自己跑MUMmer筛选位点，出的图效果也不错，但主页说的在线服务已经没有了。\n1 2 3 GenomeSyn -t 3 -g1 rice_MH63.fa -g2 rice_ZS97.fa -cf1 rice_MH63vsZS97.delta.filter.coords GenomeSyn -t 3 -g1 ../data/rice_MH63.fa -g2 ../data/rice_ZS97.fa -cf1 ../data/rice_MH63vsZS97.delta.filter.coords NGenomeSyn https://github.com/hewm2008/NGenomeSyn\nNGenomeSyn是于基于多个基因组共线性关系的可视工具，该软件可以添加多个基因组一起进行分析绘图（可超过12个），各基因组顺序可以自由定制以及添加特殊属性。绘图效果规律鲜明，结果易于呈现出各类共线性，大尺度变异，细部标识特殊基因区域等。\n这里放两个展示其特点的例子：\n在线网站 能实现这类可视化的在线网站也有非常多，有些是生物公司的云平台需要注册一下，我这里提几个免费且无需注册的网站：\npyGenomeViz：https://pygenomeviz.streamlit.app/ ，简单功能实现 chiplot：https://www.chiplot.online/McScanX_synteny_plot.html ，国产，直接接上McScanX结果可视化 SynVisio：https://synvisio.github.io/#/ ，直接接上McScanX结果可视化，各种展示形式 shinyCircos：https://venyao.xyz/shinyCircos/ ，画环形弦图的，觉得circos难用可以试试 \u0026hellip; References https://thisvsthat.io/collinearity-vs-synteny Dewey, C.N. (2019). Whole-Genome Alignment. In: Anisimova, M. (eds) Evolutionary Genomics. Methods in Molecular Biology, vol 1910. Humana, New York, NY. https://doi.org/10.1007/978-1-4939-9074-0_4 ","date":"2025-04-24T00:00:00Z","image":"https://jb-cao.github.io/Cao-blog/p/synteny/images/emales_hu_b46dfbd76b1f2de4.png","permalink":"https://jb-cao.github.io/Cao-blog/p/synteny/","title":"基因组同线性（synteny）分析和可视化"},{"content":"Introduction 在宏基因组学研究中，准确地将组装后的基因组片段（contigs）归属到各自的微生物基因组中，是解析微生物群落功能和生态关系的关键步骤。然而，很多分箱（binning）方法在面对复杂的微生物群落时，常常难以重建出高质量的基因组，且不同工具在不同样本和生态环境中的表现差异显著。\n为了解决这一问题，研究人员开发了DAS Tool（Dereplication, Aggregation and Scoring Tool），这是一种自动化的方法，能够整合多个已有的分箱算法的结果，生成优化的、非冗余的高质量基因组集合。在多个复杂环境样本中，DAS Tool展示了比任何单一分箱工具更强的能力，能够恢复更多接近完整的基因组，包括一些之前未被发现的谱系。本文将介绍使用DAS Tool优化宏基因组分箱结果，提升基因组重建的质量和数量。\nDAS Tool的文章于2018年发表于Nature Microbiology，软件主页：https://github.com/cmks/DAS_Tool，logo也很有意思。\n工作流程 Step 1｜整合多种分箱结果\nDAS Tool 的输入包括：一个宏基因组组装（scaffolds）和来自不同 binning 工具的多个 bin 结果（每种颜色表示一个工具的输出）。这些分箱工具可能依据不同特征（如 GC 含量、k-mer 频率或丰度信息）进行聚类。\nStep 2｜识别单拷贝基因并打分\nDAS Tool 会在 scaffolds 上预测单拷贝标志基因（single-copy marker genes），并以此对每个 bin 进行质量打分（例如完整度和污染度），用于后续筛选。\nStep 3｜合并候选 bin 并去除冗余\n来自不同工具的 bin 可能存在重叠。DAS Tool 会将这些候选 bin 进行去冗余整合，构建一个统一的候选 bin 集合。\nStep 4｜迭代优化与筛选\nDAS Tool 通过迭代方式从所有候选 bin 中优先选择得分最高的，并在每轮迭代中更新剩余 bin 的得分（考虑重复和覆盖情况），最终输出一个非冗余、高质量的 bin 集合。\n这个流程的关键在于：充分融合多个 binning 工具的优点，利用标志基因和打分机制，自动筛选出最优的 bin 组合，有效提升基因组重建的质量和覆盖范围。\n效果评估 DAS Tool在模拟微生物群落中的表现验证 为了验证 DAS Tool 的效果，研究者将其应用于 CAMI challenge 提供的三种复杂度不同的模拟微生物群落数据集（包含 40、132 和 596 个基因组）。使用五种主流 binning 工具（ABAWACA、CONCOCT、MaxBin 2、MetaBAT、ESOM）分别预测分箱，并用 DAS Tool 进行整合优化。\n在高复杂度（596 个基因组）数据集中，DAS Tool 重建的高质量基因组数量（F1 分数 \u0026gt; 0.6）显著高于任何单一工具：\nDAS Tool： 共识菌株 41 个、唯一菌株 299 个 次优 MaxBin 2： 共识菌株 23 个、唯一菌株 253 个 ESOM： 虽对唯一菌株效果尚可（173 个），但对存在菌株变异的基因组恢复能力较差（仅 6 个） 此外，DAS Tool 重建的基因组 F1 分数中位数也优于其它工具，尤其在处理菌株变异时展现出更强的能力。不仅在高复杂度样本中表现优越，在中低复杂度数据集上也优于单一方法。\nDAS Tool在真实环境样本中的应用 Probst 等人曾从高 CO₂ 冷泉系统中构建了一个经过精细人工筛选的基因组分箱集，成为评估 DAS Tool 表现的理想样本。这些数据来自对不同滤膜（3.0 μm 与 0.2 μm）过滤后的样品进行组装，并采用三种 binning 方法 + 人工校正获得结果。\n研究者对原始发表的 bins 及不同 binning 工具（ABAWACA 1.0/1.07、ESOM、CONCOCT、MetaBAT、MaxBin 2）与 DAS Tool 的整合结果进行了对比评估。质量评估采用 CheckM，高质量定义为 \u0026gt;90% 完整度且污染率 \u0026lt;5%。\n主要发现如下：\n使用3种工具整合的 DAS Tool 已超过任一单一方法的效果，但略低于人工精修结果。 使用7种工具整合的 DAS Tool 成果优于原始发表结果： 0.2 μm 样本： DAS Tool 重建 36 个近全基因组，高于原始的 32 个； 3.0 μm 样本： DAS Tool 重建 38 个，高于原始的 31 个； 草稿级基因组数量也全面提升。 当适度放宽污染率阈值时，草稿基因组数量进一步增加。 在真实环境样本中，DAS Tool 同样展现出强大整合能力，尤其当结合更多 binning 工具时，不仅能提高高质量基因组的数量，也能有效替代部分人工精修过程。\n使用方法 安装 1. 最简单的安装方式：使用 conda 1 2 3 4 5 conda config --add channels defaults conda config --add channels bioconda conda config --add channels conda-forge conda install -c bioconda das_tool 但我发现conda安装好了之后也需要下载github主页的db.zip文件并解压，后续运行需指定db目录，不然默认用当前目录下的db：\n1 2 3 4 5 6 # 下载并解压缩DASTool.zip存档: unzip DAS_Tool-1.x.x.zip cd ./DAS_Tool-1.x.x # Unzip SCG database: unzip ./db.zip -d db 2. 手动安装（需满足以下依赖项） R (\u0026gt;= 3.2.3)：https://www.r-project.org R 包： data.table (\u0026gt;= 1.9.6) magrittr (\u0026gt;= 2.0.1) docopt (\u0026gt;= 0.7.1) ruby (\u0026gt;= 2.3.1)：https://www.ruby-lang.org Pullseq (\u0026gt;= 1.0.2)：https://github.com/bcthomas/pullseq Prodigal (\u0026gt;= 2.6.3)：https://github.com/hyattpd/Prodigal coreutils（仅 macOS 需要）：https://www.gnu.org/software/coreutils 以下三种搜索引擎之一： DIAMOND (\u0026gt;= 0.9.14)：推荐，用于大数据集：https://ab.inf.uni-tuebingen.de/software/diamond BLAST+ (\u0026gt;= 2.5.0)：https://blast.ncbi.nlm.nih.gov/Blast.cgi USEARCH (\u0026gt;= 8.1)：http://www.drive5.com/usearch/download.html 注意：USEARCH 免费版仅支持最多 4GB 内存，因此推荐使用 DIAMOND 或 BLAST+。\n1 2 3 4 5 6 7 8 9 # 下载并解压缩DASTool.zip存档: unzip DAS_Tool-1.x.x.zip cd ./DAS_Tool-1.x.x # Unzip SCG database: unzip ./db.zip -d db # Run DAS Tool: ./DAS_Tool -h 1 2 3 4 5 6 $ R \u0026gt; repo=\u0026#39;http://cran.us.r-project.org\u0026#39; #select a repository \u0026gt; install.packages(\u0026#39;data.table\u0026#39;, repos=repo, dependencies = T) \u0026gt; install.packages(\u0026#39;magrittr\u0026#39;, repos=repo, dependencies = T) \u0026gt; install.packages(\u0026#39;docopt\u0026#39;, repos=repo, dependencies = T) \u0026gt; q() #quit R-session 3. 使用 Docker 1 2 cd ./DAS_Tool-1.x.x docker build -t cmks/das_tool . 参数说明 安装完成后，可以通过 DAS_Tool -h 查看可用参数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 DAS_Tool [选项] -i \u0026lt;contig2bin\u0026gt; -c \u0026lt;contigs_fasta\u0026gt; -o \u0026lt;输出前缀\u0026gt; 主要参数： -i, --bins=\u0026lt;contig2bin\u0026gt; 多个 contig-to-bin 表格文件（以逗号分隔） -c, --contigs=\u0026lt;contigs\u0026gt; 组装后的 contig（FASTA 格式） -o, --outputbasename=\u0026lt;前缀\u0026gt; 输出文件名前缀 -l, --labels=\u0026lt;标签\u0026gt; 每个 binning 工具的名称（以逗号分隔） --search_engine=\u0026lt;搜索工具\u0026gt; 用于识别单拷贝基因的搜索工具（diamond/blastp/usearch）[默认：diamond] -p, --proteins=\u0026lt;蛋白文件\u0026gt; 预测蛋白（可选），跳过基因预测步骤（FASTA 格式） --write_bin_evals 输出原始 bin 评估结果 --write_bins 输出最终整合的 bin（FASTA） --write_unbinned 输出未归类的 contigs -t, --threads=\u0026lt;线程数\u0026gt; 并行线程数 [默认：1] --score_threshold=\u0026lt;阈值\u0026gt; bin 筛选的得分阈值（0~1）[默认：0.5] --duplicate_penalty=\u0026lt;重复惩罚\u0026gt; 单拷贝基因重复的惩罚因子（0~3）[默认：0.6] --megabin_penalty=\u0026lt;megabin惩罚\u0026gt; 超大 bin 的惩罚因子（0~3）[默认：0.5] --dbDirectory=\u0026lt;数据库路径\u0026gt; 单拷贝基因数据库路径 [默认：db] --resume 使用之前预测过的单拷贝基因结果 --debug 输出调试信息 -v, --version 查看版本 -h, --help 查看帮助 输入文件准备 1. 多个 binning 工具的输出 [--bins, -i] 每个 binning 工具生成的 contig-to-bin 表格，TSV 格式：\n1 2 3 4 Contig_1 bin.01 Contig_8 bin.01 Contig_42 bin.02 Contig_49 bin.03 不是所有 binning 工具都直接生成此格式。可使用官方提供的脚本 Fasta_to_Contigs2Bin.sh 进行转换，在github主页上：\n1 2 # 示例：将 MaxBin 输出 fasta 文件转为 contigs2bin 表格 ~/biosoft/DAS_Tool/src/Fasta_to_Contig2Bin.sh -i /maxbin/output/folder -e fa \u0026gt; maxbin.contigs2bin.tsv 某些工具如 CONCOCT 输出为 CSV，可用 perl 一行命令转为 TSV：\n1 perl -pe \u0026#34;s/,/\\tconcoct./g;\u0026#34; concoct_clustering_gt1000.csv \u0026gt; concoct.contigs2bin.tsv 2. 组装后的 contig 文件 [--contigs, -c] FASTA 格式，如：\n1 2 3 4 \u0026gt;Contig_1 ATCATCGTCCGCATCGACGAATTCGGCGAACGAGTACCCCTGACCATCTCCGATTA... \u0026gt;Contig_2 GATCGTCACGCAGGCTATCGGAGCCTCGACCCGCAAGCTCTGCGCCTTGGAGCAGG... 3. 可选：预测蛋白序列 [--proteins] 若已有 prodigal 预测结果（.faa 格式），可跳过基因预测步骤。\n运行 DAS Tool 基本命令格式如下：\n1 DAS_Tool -i \u0026lt;binning_results.tsv\u0026gt; -l \u0026lt;binning_labels\u0026gt; -c \u0026lt;scaffolds.fasta\u0026gt; -o \u0026lt;输出前缀\u0026gt; 参数说明：\n-i：多个 binning 工具的 contigs-to-bin TSV 文件（用逗号连接），注意逗号之间绝对不能有空格，不然会引发Docopt报错 -l：与 -i 对应的 binning 工具名称（用逗号连接） -c：组装后 contigs 的 FASTA 文件 -o：输出文件名前缀 示例：\n1 DAS_Tool -i bins.tsv -l metabat,maxbin,concoct -c assembly.fasta -o DAS_Tool_output 输出结果 运行后将生成以下输出文件：\n*_DASTool_summary.tsv：输出 bin 的质量与完整性评估汇总 *_DASTool_contigs2bin.tsv：最终 contigs-to-bin 映射表 *_allBins.eval：若启用 --write_bin_evals，输出输入 bin 的评估结果 DASTool_bins/：若启用 --write_bins，输出整合后的 bin（FASTA 格式） 示例数据与测试 使用 GitHub 提供的 sample_data：\n示例 1：使用 4 个 bin 工具结果运行 DAS Tool 1 2 3 4 5 6 7 8 DAS_Tool -t 4 -i sample_data/sample.human.gut_concoct_contigs2bin.tsv,\\ sample_data/sample.human.gut_maxbin2_contigs2bin.tsv,\\ sample_data/sample.human.gut_metabat_contigs2bin.tsv,\\ sample_data/sample.human.gut_tetraESOM_contigs2bin.tsv \\ --dbDirectory ~/db/DAS_Tool_db \\ -l concoct,maxbin,metabat,tetraESOM \\ -c sample_data/sample.human.gut_contigs.fa \\ -o sample_output2/DASToolRun1 用了4核，对于一个32M的contig文件，用时1min，内存占用200MB。\n示例 2：设置更多参数，跳过基因预测，输出评估结果，输出最终的bins，使用多线程 1 2 3 4 5 6 7 8 9 10 11 12 DAS_Tool -t 4 -i sample_data/sample.human.gut_concoct_contigs2bin.tsv,\\ sample_data/sample.human.gut_maxbin2_contigs2bin.tsv,\\ sample_data/sample.human.gut_metabat_contigs2bin.tsv,\\ sample_data/sample.human.gut_tetraESOM_contigs2bin.tsv \\ --dbDirectory ~/db/DAS_Tool_db \\ -l concoct,maxbin,metabat,tetraESOM \\ -c sample_data/sample.human.gut_contigs.fa \\ -o sample_output2/DASToolRun2 \\ --proteins sample_output2/DASToolRun1_proteins.faa \\ --write_bin_evals \\ --write_bins \\ --score_threshold 0.6 承接MetaWRAP输出结果 MetaWRAP是我们之前介绍过的一个binning流程工具，假如我们一开始已经用MetaWRAP进行了3种工具的binning，现在我们想用DAS_Tool来进行进一步的优化，那么可以用如下命令：\n1 2 3 i=KY01867_1_T006D metawrap binning -o l -t 2 -m 4 -a contigs/contigs_${i}.fasta \\ --metabat2 --maxbin2 --concoct reads/${i}*.fastq 那么在INITIAL_BINNING_${i}文件夹下会有如下文件夹：\nINITIAL_BINNING_KY01867_1_T006D/ ├── concoct_bins ├── maxbin2_bins ├── metabat2_bins └── work_files\n我们使用DAS_Tool进行整合：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 mkdir DAS_Tool_${i} #整理list mkdir tmp/ rm tmp/* find INITIAL_BINNING_${i}/metabat2_bins/ -type f -name \u0026#34;bin.[0-9].fa\u0026#34; -exec cp {} tmp/ \\; ~/biosoft/DAS_Tool/src/Fasta_to_Contig2Bin.sh -i tmp/ -e fa \u0026gt; DAS_Tool_${i}/metabat_contigs2bin.tsv ~/biosoft/DAS_Tool/src/Fasta_to_Contig2Bin.sh -i INITIAL_BINNING_${i}/maxbin2_bins/ -e fa \u0026gt; DAS_Tool_${i}/maxbin_contigs2bin.tsv rm tmp/* cp INITIAL_BINNING_${i}/concoct_bins/bin.*.fa tmp/ ~/biosoft/DAS_Tool/src/Fasta_to_Contig2Bin.sh -i tmp/ -e fa \u0026gt; DAS_Tool_${i}/concoct_contigs2bin.tsv #运行DAS_Tool DAS_Tool -t 4 -i DAS_Tool_${i}/concoct_contigs2bin.tsv,\\ DAS_Tool_${i}/maxbin_contigs2bin.tsv,\\ DAS_Tool_${i}/metabat_contigs2bin.tsv \\ --dbDirectory ~/db/DAS_Tool_db \\ -l concoct,maxbin,metabat \\ -c INITIAL_BINNING_${i}/work_files/assembly.fa \\ -o DAS_Tool_${i}/DASToolRun2 \\ --write_bin_evals \\ --write_bins References Sieber, C.M.K., Probst, A.J., Sharrar, A. et al. Recovery of genomes from metagenomes via a dereplication, aggregation and scoring strategy. Nat Microbiol 3, 836–843 (2018). https://doi.org/10.1038/s41564-018-0171-1 ","date":"2025-04-22T00:00:00Z","image":"https://jb-cao.github.io/Cao-blog/p/binning-4-das-tool-binning/images/workflow_hu_6313fd077daf3954.png","permalink":"https://jb-cao.github.io/Cao-blog/p/binning-4-das-tool-binning/","title":"宏基因组分箱（binning）｜4. DAS Tool优化binning结果"},{"content":"除了之前讲的网络拓扑特征（数学指标）外，网络的稳定性也是生物研究的重点。网络稳定性是理解分子调控，代谢网络，生态系统等稳健性的重要因素。\n我们收集了许多方法在MetaNet中来计算和反映网络的稳定性和复杂性，这些算法都是并行计算的，这可以快得多。所有网络稳定性计算都提供并行版本，使用parallel::detectCores()获取设备核数，并设置threads \u0026gt;1使用并行计算。\n软件主页：https://github.com/Asa12138/MetaNet 大家可以帮忙在github上点点star⭐️，谢谢🙏 详细英文版教程：https://bookdown.org/Asa12138/metanet_book/ 可以从 CRAN 安装稳定版：install.packages(\u0026quot;MetaNet\u0026quot;)\n依赖包 pcutils和igraph（需提前安装），推荐配合 dplyr 进行数据操作。\n1 2 3 4 5 6 library(MetaNet) library(igraph) # ========data manipulation library(dplyr) library(pcutils) 多组网络构建 比较基于不同组的网络稳定性非常重要。\n例如，我们有三组样本：NS、WS、CS，n=6（在实际研究中，n应该更大才能得到有意义的结果），我们可以获得每组的网络并进行比较。\n1 2 3 4 5 data(\u0026#34;otutab\u0026#34;, package = \u0026#34;pcutils\u0026#34;) table(metadata$Group) # check all rows matched all(colnames(otutab) == rownames(metadata)) 我们可以从整个网络中提取三组子网: 1 2 3 4 5 6 7 8 9 10 11 12 13 # extract three-group sub-nets hebing(otutab, metadata$Group) -\u0026gt; otutab_G head(otutab_G) # whole network t(otutab) -\u0026gt; totu c_net_calculate(totu) -\u0026gt; corr c_net_build(corr, r_threshold = 0.65) -\u0026gt; co_net group_net_par \u0026lt;- extract_sample_net(co_net, otutab_G, save_net = \u0026#34;../Group_subnet\u0026#34;) group_nets \u0026lt;- readRDS(\u0026#34;../Group_subnet.RDS\u0026#34;) names(group_nets) 或者为每个组专门构建一个网络： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 data(\u0026#34;otutab\u0026#34;, package = \u0026#34;pcutils\u0026#34;) totu \u0026lt;- t(otutab) # check all rows matched all(rownames(totu) == rownames(metadata)) # Use RMT threshold or not? rmt \u0026lt;- FALSE group_nets \u0026lt;- lapply(levels(metadata$Group), \\(i){ totu[rownames(filter(metadata, Group == !!i)), ] -\u0026gt; t_tmp t_tmp[, colSums(t_tmp) \u0026gt; 0] -\u0026gt; t_tmp c_net_calculate(t_tmp) -\u0026gt; c_tmp if (rmt) { RMT_threshold(c_tmp, verbose = F, out_dir = \u0026#34;test/\u0026#34;) -\u0026gt; tmp_rmt r_thres \u0026lt;- tmp_rmt$r_threshold } else { r_thres \u0026lt;- 0.6 } c_net_build(c_tmp, r_threshold = r_thres, p_threshold = 0.01, delete_single = T) -\u0026gt; n_tmp Abundance_df \u0026lt;- data.frame(\u0026#34;Abundance\u0026#34; = colSums(t_tmp)) c_net_set(n_tmp, Abundance_df, taxonomy %\u0026gt;% select(\u0026#34;Phylum\u0026#34;), vertex_class = \u0026#34;Phylum\u0026#34;, vertex_size = \u0026#34;Abundance\u0026#34;) }) names(group_nets) \u0026lt;- levels(metadata$Group) 网络稳健测试 参考：M. B. WU Jun, Natural Connectivity of Complex Networks. Chinese Physics Letters. 27, 78902–078902 (2010).\n网络的稳健测试（Robust test）是计算自然联通度来进行的，因为它可以反映网络的稳定性。它认为复杂网络的功能和性能取决于当一个网络的部分节点被破坏（或移除）时，该网络保持其连通性的能力。\n来看下图，两个闭环网络。两个网络都含有a-e共5个节点，理论上，两个网络中任意节点间都是相通的，也就是从一个节点出发，无论选择怎样的路径，最终都能到达另一节点。 但是当我们进行节点或边的移除，比如删除ed，左边还能ed2条边相连，右边就要5条边才能连上，移除更多的边时右边的网络就会出现孤立节点。\n自然连通度从复杂网络的内部结构属性出发，通过计算网络中不同长度闭途径数目的加权和来刻画网络中替代途径的冗余性，其数学形式可以从网络邻接矩阵特征谱直接导出，具有明确的物理意义，但比较复杂。 自然连通度关于移除节点或边是单调减的，这意味着自然连通度能够精确刻画网络抗毁性的细微差别，且对于不连通图仍然有效。\n右下角这个例子就是逐步移出网络的节点，观察自然联通度的下降趋势，越平缓的说明稳定性越好\n具体来说，我们可以在删除节点后计算自然连接（一次从网络中删除多个节点，直到指定比例的节点消失）， 自然连通性的下降趋势水平表明了网络在受到一定程度的破坏后的连通性性能。\n1 2 3 #建议“reps”大于99，您可以将“threads\u0026gt;1”设置为使用并行计算。 robust_test(group_nets, partial = 0.5, step = 10, reps = 9, threads = 1) -\u0026gt; robust_res plot(robust_res, mode = 2) 网络群落稳定性 群落稳定性可以用各种指标来表征，如鲁棒性（Robustness）、脆弱性(Vulnerability)和凝聚力。\nRobustness 参考 Yuan, M. M. et al. Climate warming enhances microbial network complexity and stability. Nat. Clim. Chang. 11, 343–348 (2021).\n作者将网络的鲁棒性（Robustness）定义为网络在随机或有针对性的节点删除后对节点丢失的抵抗力。\n为了模拟随机物种去除，随机去除一定比例的节点，为了测试移除的物种对剩余物种的影响，作者计算了节点 i 的丰度加权平均相互作用强度（wMIS）：移除所选节点后，如果 wMISi = 0（与物种 i 相关的所有物种都被移除） ）或 wMISi \u0026lt; 0（物种 i 与其他物种没有足够的互惠关联以使其生存），则节点 i 被视为灭绝/孤立并从网络中删除。整个过程一直持续到所有物种的 wMIS 呈正数为止。 剩余节点的比例被报告为网络鲁棒性。\n1 2 3 #建议“reps”大于99，您可以将“threads\u0026gt;1”设置为使用并行计算。 robustness(group_nets, keystone = F, reps = 99, threads = 1) -\u0026gt; robustness_res plot(robustness_res, p_value2 = T) Vulnerability 参考 Yuan, M. M. et al. Climate warming enhances microbial network complexity and stability. Nat. Clim. Chang. 11, 343–348 (2021).\n为了评估网络内干扰传播的速度，全局效率被视为所有节点对效率的平均值，其通过成对节点之间的最短路径中的边的数量来计算。\n脆弱性(Vulnerability)反映了每个节点对全局效率的相对贡献，由网络中节点的最大脆弱性表示。\n$$ Vulnerability=\\max\\left(\\frac{E-E_i}E\\right) $$\n其中E是全局效率，Ei是去除节点i及其整个链路后的全局效率。图的全局效率计算为所有节点对效率的平均值：\n$$ E=\\frac1{n(n-1)}\\sum_{i\\neq j}\\frac1{d(i,j)} $$ 其中d（i，j）是节点i和j之间的最短路径长度。\n1 2 vulnerability_res \u0026lt;- vulnerability(group_nets, threads = 1) plot(vulnerability_res) Cohesion 参考 C. M. Herren, K. McMahon, Cohesion: A method for quantifying the connectivity of microbial communities (2017), doi:10.1038/ismej.2017.91.\n还有一个指标是cohesion凝聚力指数，通过分别表征群落中物种间的正负共现关系，来了解由正/负物种相互作用或由生态位相似性/差异引起群落连通性跨时间、空间或环境梯度的变化。\n首先从丰度表构建相关性矩阵，然后对它做零模型消除随机效应，这样对于每一个物种，都有与其他所有物种的相关性，然后把其中的正值负值分开取平均，就能得到每个物种的connectedness，再乘上丰度表，就能得到每一个样本的正负凝聚力了。\n$$ \\text{Cohesion}=\\sum_{i=1}^n\\text{abundance}_i\\times\\text{connectednes}s_i $$\n正Cohesion是由两两正相关产生的，可以反映样本中合作行为的程度，而负Cohesion可以表明群落成员之间竞争行为的程度。然后作者认为负：正Cohesion的绝对值越高的的群落更稳定。（Hernandez, D. J., David, A. S., Menges, E. S., Searcy, C. A. \u0026amp; Afkhami, M. E. Environmental stress destabilizes microbial networks. ISME J 15, 1722–1734 (2021).）\n1 2 3 4 5 #建议“reps”大于99，您可以将“threads\u0026gt;1”设置为使用并行计算。 Cohesion(otutab, reps = 9, threads = 1) -\u0026gt; cohesion_res p1 \u0026lt;- plot(cohesion_res, group = \u0026#34;Group\u0026#34;, metadata, mode = 1) + theme_bw() p2 \u0026lt;- plot(cohesion_res, group = \u0026#34;Group\u0026#34;, metadata, mode = 2) p1 + p2 References Yuan, M. M. et al. Climate warming enhances microbial network complexity and stability. Nat. Clim. Chang. 11, 343–348 (2021). M. B. WU Jun, Natural Connectivity of Complex Networks. Chinese Physics Letters. 27, 78902–078902 (2010). C. M. Herren, K. McMahon, Cohesion: A method for quantifying the connectivity of microbial communities (2017), doi:10.1038/ismej.2017.91. Hernandez, D. J., David, A. S., Menges, E. S., Searcy, C. A. \u0026amp; Afkhami, M. E. Environmental stress destabilizes microbial networks. ISME J 15, 1722–1734 (2021). ","date":"2025-04-16T00:00:00Z","image":"https://jb-cao.github.io/Cao-blog/p/metanet-8/images/nc_hu_b18b361e32b2bda1.png","permalink":"https://jb-cao.github.io/Cao-blog/p/metanet-8/","title":"MetaNet：多组学网络分析工具｜8.网络稳定性分析"},{"content":"在复杂网络分析中，模块（module）或社区（community）是指网络中连接更为紧密的子图结构。这些模块通常代表功能相关的节点群组，在生物网络中可能对应特定的功能单元或调控模块。MetaNet工具包提供了全面的功能，本文将详细介绍其核心方法和应用场景。\n软件主页：https://github.com/Asa12138/MetaNet 大家可以帮忙在github上点点star⭐️，谢谢🙏 详细英文版教程：https://bookdown.org/Asa12138/metanet_book/ 可以从 CRAN 安装稳定版：install.packages(\u0026quot;MetaNet\u0026quot;)\n依赖包 pcutils和igraph（需提前安装），推荐配合 dplyr 进行数据操作。\n1 2 3 4 5 6 library(MetaNet) library(igraph) # ========data manipulation library(dplyr) library(pcutils) 网络模块（module） 模块（module）或社区（community）是指包含节点的子图，其中节点之间的连接密度高于它们与图中其他节点的连接密度。用数学语言表达：当任何子图内部的连接数高于这些子图之间的连接数时，我们就说这个图具有社区结构。\n在MetaNet中，可以使用module_net()函数生成具有指定模块数的网络：\n1 2 3 4 set.seed(12) # 生成包含3个模块的网络，每个模块30个节点 test_module_net \u0026lt;- module_net(module_number = 3, n_node_in_module = 30) plot(test_module_net, mark_module = TRUE) 网络科学领域已开发出多种模块检测算法，各有其优势和适用场景：\n短随机游走法：基于随机游走的动态过程识别社区 社区矩阵的主特征向量法：利用矩阵特征向量进行谱聚类 模拟退火法：通过优化模块度指标寻找全局最优解 贪婪模块度优化：局部搜索算法，计算效率较高 \u0026hellip; MetaNet的module_detect()函数集成了这些主流算法，用户可以根据网络特性选择合适的方法。对于大型网络，建议先测试不同算法的运行时间和效果。\n1 2 # 使用快速贪婪算法检测模块 module_detect(co_net, method = \u0026#34;cluster_fast_greedy\u0026#34;) -\u0026gt; co_net_modu 模块筛选合并 实际分析中，我们常关注特定规模的模块。filter_n_module()函数支持多种筛选方式：\n• 按节点数筛选：保留节点数超过阈值的模块 • 按模块ID筛选：指定需要保留的特定模块 • 组合筛选：同时应用多种条件\n网络布局对模块展示效果至关重要，之前介绍了很多g_layout方法都可以在这里用上了。g_layout_circlepack()可生成基于模块的圆形堆积布局：\n1 2 3 4 par(mfrow = c(2, 2), mai = rep(1, 4)) # module detection module_detect(co_net, method = \u0026#34;cluster_fast_greedy\u0026#34;) -\u0026gt; co_net_modu get_v(co_net_modu)[, c(\u0026#34;name\u0026#34;, \u0026#34;module\u0026#34;)] %\u0026gt;% head() 1 2 3 4 5 6 7 ## name module ## 1 s__un_f__Thermomonosporaceae 10 ## 2 s__Pelomonas_puraquae 9 ## 3 s__Rhizobacter_bergeniae 1 ## 4 s__Flavobacterium_terrae 3 ## 5 s__un_g__Rhizobacter 14 ## 6 s__un_o__Burkholderiales 9 1 2 3 4 5 plot(co_net_modu, plot_module = T, mark_module = T, legend_position = c(-1.8, 1.6, 1.1, 1.3), edge_legend = F ) table(V(co_net_modu)$module) 1 2 3 4 5 ## ## 1 10 11 12 13 14 15 16 17 18 19 2 20 21 22 23 24 25 26 27 28 29 3 4 5 6 ## 36 18 35 16 17 12 21 15 6 4 4 24 2 3 2 2 2 2 3 2 3 2 27 23 35 23 ## 7 8 9 ## 33 18 61 1 2 3 4 5 6 7 8 9 10 11 # 保留节点数≥30的模块和ID为10的模块 co_net_modu2 \u0026lt;- filter_n_module(co_net_modu, n_node_in_module = 30, keep_id = 10) plot(co_net_modu2, plot_module = T, mark_module = T, legend_position = c(-1.8, 1.3, 1.1, 1.3)) # change group layout g_layout_circlepack(co_net_modu, group = \u0026#34;module\u0026#34;) -\u0026gt; coors plot(co_net_modu2, coors = coors, plot_module = T, mark_module = T, edge_legend = F) # extract some modules, delete =T will delete other modules. co_net_modu3 \u0026lt;- filter_n_module(co_net_modu, n_node_in_module = 30, keep_id = 10, delete = T) plot(co_net_modu3, coors, plot_module = T) 看看网络的components，一些太小的sub_graphs会影响模块，如果您不关心这些小型组件，则可以过滤掉它们。\n1 table(V(co_net_modu)$components) 1 2 3 ## ## 1 10 11 12 13 2 3 4 5 6 7 8 9 ## 418 2 2 2 2 6 4 2 2 3 2 3 3 1 2 3 4 5 6 co_net_modu4 \u0026lt;- c_net_filter(co_net_modu, components == 1) # re-do a module detection co_net_modu4 \u0026lt;- module_detect(co_net_modu4) g_layout_circlepack(co_net_modu4, group = \u0026#34;module\u0026#34;) -\u0026gt; coors plot(co_net_modu4, coors, plot_module = T) plot_module_tree()函数可展示模块的树状关系，揭示模块间的层次结构。当模块数量过多时，combine_n_module()可将模块合并到指定数量，便于高层次分析。\n1 2 3 4 5 6 7 8 9 # 展示模块树状图 p1 \u0026lt;- plot_module_tree(co_net_modu4, label.size = 0.6) # 将17个模块合并为5个 co_net_modu5 \u0026lt;- combine_n_module(co_net_modu4, 5) p2 \u0026lt;- plot_module_tree(co_net_modu5, label.size = 0.6) library(patchwork) p1+p2 模块pattern分析 在生物网络中，模块常对应功能相关的分子集合。我们还可以使用此网络模块指示具有相似表达/丰度的群集。但是我们应该首先过滤正边，因为模块检测仅考虑拓扑结构而不是边缘类型。过滤正相关边和模块检测后，将找到一些模块，很像是WGCNA里的基因模块，我们还可以使用module_eigen查看每个模块表达模式。\n1 2 3 4 5 6 7 8 data(\u0026#34;otutab\u0026#34;, package = \u0026#34;pcutils\u0026#34;) totu \u0026lt;- t(otutab) # filter positive edges c_net_filter(co_net, e_type == \u0026#34;positive\u0026#34;, mode = \u0026#34;e\u0026#34;) -\u0026gt; co_net_pos co_net_pos_modu \u0026lt;- module_detect(co_net_pos, n_node_in_module = 15, delete = T) g_layout_circlepack(co_net_pos_modu, group = \u0026#34;module\u0026#34;) -\u0026gt; coors1 plot(co_net_pos_modu, coors1, plot_module = T) module_eigen()和module_expression()可计算和可视化模块特征基因及表达模式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # map the original abundance table module_eigen(co_net_pos_modu, totu) -\u0026gt; co_net_pos_modu # plot the expression pattern p1 \u0026lt;- module_expression(co_net_pos_modu, totu, r_threshold = 0.6, facet_param = list(ncol = 4), plot_eigen = T ) + theme(axis.text.x = element_text(size = 5, angle = 90, vjust = 0.5)) # correlate to metadata env \u0026lt;- metadata[, 3:8] p2 \u0026lt;- cor_plot(get_module_eigen(co_net_pos_modu), env) + coord_flip() p1 / p2 + patchwork::plot_layout(heights = c(2, 1.4)) 1 2 3 4 5 6 # summary some variable according to modules. p3 \u0026lt;- summary_module(co_net_pos_modu, var = \u0026#34;Phylum\u0026#34;) + scale_fill_pc() p4 \u0026lt;- summary_module(co_net_pos_modu, var = \u0026#34;node_eigen_cor\u0026#34;) + scale_color_pc(palette = \u0026#34;col2\u0026#34;) p3 + p4 使用links_stat()对边进行汇总，发现大多数边都是从一个模块到同一个模块的（意味着模块检测正常）。\n1 links_stat(co_net_modu2, group = \u0026#34;module\u0026#34;) 拓扑角色分析 在我们确定了网络的这些模块后，可以根据Zi-Pi计算每个节点的拓扑角色。\nWithin-module connectivity (Zi):\n$$ Z_i= \\frac{\\kappa_i-\\overline{\\kappa_{si}}}{\\sigma_{\\kappa_{si}}} $$\n其中$κ_i$是节点i到其模块si中其他节点的链接数，$\\overline{\\kappa_{si}}$是si中所有节点的k的平均值，$\\sigma_{\\kappa_{si}}$是si中κ的标准偏差。\nAmong-module connectivity (Pi):\n$$ P_i=1-\\sum_{s=1}^{N_m}{\\left( {\\frac{\\kappa_{is}}{k_i}} \\right)^2} $$\n其中$\\kappa_{is}$是节点i到模块s中节点的链接数，$k_i$是节点i的总度数。\n参考R. Guimerà, L. Amaral, Functional cartography of complex metabolic networks (2005), doi:10.1038/nature03288.，基于Zi-Pi指标，节点可分为四类拓扑角色：\n外围节点(Peripherals)：Zi\u0026lt;2.5且Pi\u0026lt;0.62 模块枢纽(Module hubs)：Zi\u0026gt;2.5且Pi\u0026lt;0.62 连接节点(Connectors)：Zi\u0026lt;2.5且Pi\u0026gt;0.62 网络枢纽(Network hubs)：Zi\u0026gt;2.5且Pi\u0026gt;0.62 其中除了Peripherals的节点通常被视为网络的关键节点(keystone)，参考 S. Liu, H. Yu, Y. Yu, J. Huang, et al., Ecological stability of microbial communities in Lake Donghu regulated by keystone taxa. Ecological Indicators. 136, 108695 (2022).\n使用zp_analyse拿到模块角色并存储在顶点属性中，然后我们可以使用zp_plot（）可视化。我们可以看到模块中心是模块的中心，而连接器通常是介导不同模块的连接。\n1 2 zp_analyse(co_net_modu4) -\u0026gt; co_net_modu4 get_v(co_net_modu4)[, c(1, 16:21)] %\u0026gt;% head() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ## name components module original_module Ki Zi ## 1 s__un_f__Thermomonosporaceae 1 6 6 3 0.4358899 ## 2 s__Pelomonas_puraquae 1 11 11 15 1.9019177 ## 3 s__Rhizobacter_bergeniae 1 1 1 4 1.0951304 ## 4 s__Flavobacterium_terrae 1 3 3 4 1.8027756 ## 5 s__un_g__Rhizobacter 1 14 14 1 -1.0488088 ## 6 s__un_o__Burkholderiales 1 11 11 17 2.3326783 ## Pi ## 1 0.3750000 ## 2 0.3490305 ## 3 0.5714286 ## 4 0.0000000 ## 5 0.0000000 ## 6 0.1939058 1 2 3 # color map to roles co_net_modu6 \u0026lt;- c_net_set(co_net_modu4, vertex_class = \u0026#34;roles\u0026#34;) plot(co_net_modu6, coors, mark_module = T, labels_num = 0, group_legend_title = \u0026#34;Roles\u0026#34;) 1 2 3 library(patchwork) zp_plot(co_net_modu4, mode = 1) + zp_plot(co_net_modu4, mode = 3) References Koutrouli M, Karatzas E, Paez-Espino D and Pavlopoulos GA (2020) A Guide to Conquer the Biological Network Era Using Graph Theory. Front. Bioeng. Biotechnol. 8:34. doi: 10.3389/fbioe.2020.00034 Faust, K., and Raes, J. (2012). Microbial interactions: from networks to models. Nat. Rev. Microbiol. https://doi.org/10.1038/nrmicro2832. Y. Deng, Y. Jiang, Y. Yang, Z. He, et al., Molecular ecological network analyses. BMC bioinformatics (2012), doi:10.1186/1471-2105-13-113. R. Guimerà, L. Amaral, Functional cartography of complex metabolic networks (2005), doi:10.1038/nature03288. S. Liu, H. Yu, Y. Yu, J. Huang, et al., Ecological stability of microbial communities in Lake Donghu regulated by keystone taxa. Ecological Indicators. 136, 108695 (2022). ","date":"2025-04-15T00:00:00Z","image":"https://jb-cao.github.io/Cao-blog/p/metanet-7/index.en_files/figure-html/unnamed-chunk-5-1_hu_840041755cac7693.png","permalink":"https://jb-cao.github.io/Cao-blog/p/metanet-7/","title":"MetaNet：多组学网络分析工具｜7.网络模块分析"},{"content":"本文我们介绍网络的各种拓扑指标计算和分析。网络拓扑（Network Topology）是指网络中节点与边的连接模式所呈现的全局或局部结构特征。在生物组学研究中，拓扑分析能揭示分子互作网络的功能组织规律，是理解复杂生物系统的关键手段。\n软件主页：https://github.com/Asa12138/MetaNet 大家可以帮忙在github上点点star⭐️，谢谢🙏 详细英文版教程：https://bookdown.org/Asa12138/metanet_book/ 可以从 CRAN 安装稳定版：install.packages(\u0026quot;MetaNet\u0026quot;)\n依赖包 pcutils和igraph（需提前安装），推荐配合 dplyr 进行数据操作。\n1 2 3 4 5 6 library(MetaNet) library(igraph) # ========data manipulation library(dplyr) library(pcutils) 拓扑指标 全局拓扑（Global Topology）描述网络整体连接特性，局部拓扑（Local Topology）聚焦单个节点/边的结构重要性，MetaNet可以对构建好的网络进行多种拓扑指标的计算和分析。\n局部拓扑指标 Connectivity/Degree centrality\n衡量节点直接连接数量的基础指标，反映节点的局部影响力。\nBetweenness centrality\n统计节点出现在所有最短路径中的频率，识别网络中的\u0026quot;桥梁\u0026quot;节点。\nCloseness centrality\n计算节点到其他所有节点的平均最短距离倒数，体现信息传播效率。\nEigenvector centrality\n考虑邻居节点的重要性加权计算，适用于评估依赖高端连接的节点影响力。\nClustering coefficient\n量化节点邻居间的连接紧密程度，揭示网络局部模块化特性。\nEccentricity\n定义节点到网络中最远节点的距离，反映节点的全局位置特征。\nPageRank\n基于随机游走模型迭代计算的节点重要性，适用于有向网络（如基因调控网络）。\nKleinberg\u0026rsquo;s hub/authority centrality\n双向评价节点价值：hub（指向重要节点）和authority（被重要节点指向）。\n更细致的介绍可以看下表，来自MetaNet教程网页：\n全局拓扑指标 Average connectivity/degree\n网络中所有节点连接数的平均值，反映整体连接密度。\nAverage path length/Average geodesic distance\n所有节点对之间最短路径的平均值，衡量网络信息传递效率。\nGlobal efficiency/Geodesic efficiency\n节点间最短路径倒数和的标准化值（0-1），值越高表示信息流动越高效。\nCentralization of degree\n节点度分布的集中程度（0-1），值越高说明网络越依赖少数枢纽节点。\nCentralization of betweenness\n节点介数中心性的方差，反映网络对\u0026quot;桥梁\u0026quot;节点的依赖程度。\nCentralization of closeness\n接近中心性的分布偏态，表征网络核心-边缘结构的强度。\nCentralization of eigenvector centrality\n特征向量中心性的异质性，评估高端连接节点的支配性。\nDensity\n实际边数与最大可能边数的比值（0-1），描述网络的稀疏程度。\nAverage clustering coefficient\n所有节点局部聚类系数的均值，量化网络模块化趋势。\nTransitivity\n三元闭包比例（三角形结构占比），反映网络局部聚集特性。\nNatural connectivity\n基于网络特征谱的鲁棒性指标，值越高表示网络越稳定。\n一些潜在的生物网络分析应用场景：\n指标类型 典型应用场景 计算复杂度 Degree 快速筛选高连接分子 O(n) Betweenness 发现跨模块调控因子 O(n²) PageRank 识别关键调控基因 O(n log n) 指标 典型生物学意义 示例场景 Average path length 代谢物信号传导速度 短路径=快速调控响应 Centralization of degree 关键基因的支配性 转录因子网络分析 Transitivity 蛋白复合体的形成倾向 PPI网络功能模块检测 Natural connectivity 基因网络抗突变能力 疾病相关网络稳定性评估 MetaNet计算 MetaNet提供net_par()函数一键计算网络/节点/边三个层级的拓扑指标：\n1 2 3 4 5 6 7 8 library(MetaNet) library(igraph) # 示例1：获取Walther网络的所有指标（返回列表） make_graph(\u0026#34;Walther\u0026#34;) %\u0026gt;% net_par(mode = \u0026#34;all\u0026#34;) # 示例2：仅获取网络级全局指标 make_graph(\u0026#34;Walther\u0026#34;) %\u0026gt;% net_par(mode = \u0026#34;n\u0026#34;) 参数说明：\nmode：计算范围 \u0026quot;n\u0026quot;：网络级指标（如密度、平均路径长度） \u0026quot;v\u0026quot;：节点级指标（如度中心性、介数） \u0026quot;e\u0026quot;：边级指标（如边介数） \u0026quot;all\u0026quot;：全部指标（返回嵌套列表） 也可以通过c_net_index()计算并存储拓扑指标到网络中，便于后续分析和可视化：\n1 2 3 4 5 6 7 8 # 生成随机网络 go \u0026lt;- erdos.renyi.game(30, 0.25) %\u0026gt;% c_net_update() # 计算拓扑指标并存入网络属性 go \u0026lt;- c_net_index(go) # 查看节点属性表（前6行） head(get_v(go)) # 包含Degree、Betweenness等列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ## name label size v_group shape v_class color Degree ## 1 1 1 1 v_group1 circle v_class1 #a6bce3 12 ## 2 2 2 1 v_group1 circle v_class1 #a6bce3 5 ## 3 3 3 1 v_group1 circle v_class1 #a6bce3 6 ## 4 4 4 1 v_group1 circle v_class1 #a6bce3 10 ## 5 5 5 1 v_group1 circle v_class1 #a6bce3 10 ## 6 6 6 1 v_group1 circle v_class1 #a6bce3 8 ## Clustering_coefficient Betweenness Eccentricity Closeness Hub_score ## 1 0.3030303 28.397972 3 0.02127660 1.0000000 ## 2 0.2000000 6.660256 3 0.01666667 0.3248811 ## 3 0.2666667 6.069444 3 0.01694915 0.4109319 ## 4 0.2000000 28.380145 3 0.02000000 0.7223088 ## 5 0.2666667 21.248995 3 0.02000000 0.7955976 ## 6 0.2857143 11.864627 2 0.02000000 0.6595919 将节点度中心性映射为可视化属性：\n1 2 3 4 5 6 7 8 9 # get a metanet go \u0026lt;- erdos.renyi.game(30, 0.25) go \u0026lt;- c_net_update(go) par(mfrow = c(1, 2)) plot(go, vertex_size_range = c(5, 20), legend = F, main = \u0026#34;Same size\u0026#34;) # calculate topological indexes and store go \u0026lt;- c_net_index(go) head(get_v(go)) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ## name label size v_group shape v_class color Degree ## 1 1 1 1 v_group1 circle v_class1 #a6bce3 5 ## 2 2 2 1 v_group1 circle v_class1 #a6bce3 6 ## 3 3 3 1 v_group1 circle v_class1 #a6bce3 6 ## 4 4 4 1 v_group1 circle v_class1 #a6bce3 5 ## 5 5 5 1 v_group1 circle v_class1 #a6bce3 5 ## 6 6 6 1 v_group1 circle v_class1 #a6bce3 10 ## Clustering_coefficient Betweenness Eccentricity Closeness Hub_score ## 1 0.10000000 10.013921 3 0.01785714 0.4610096 ## 2 0.26666667 6.727020 3 0.01754386 0.6577058 ## 3 0.20000000 10.684066 3 0.01694915 0.5397470 ## 4 0.20000000 8.271461 3 0.01724138 0.4504656 ## 5 0.20000000 8.340112 3 0.01694915 0.4305194 ## 6 0.08888889 41.647508 3 0.02040816 0.8463154 1 2 3 # use vertex.size to indicate degree go \u0026lt;- c_net_set(go, vertex_size = \u0026#34;Degree\u0026#34;) plot(go, vertex_size_range = c(5, 20), legend = F, main = \u0026#34;Size map to degree\u0026#34;) 随机网络 随机网络（Random Network）是网络科学中的一类基础网络模型，其核心特征是网络连接遵循某种随机生成规则。Erdős-Rényi（ER）模型是最著名的代表：\n定义：给定N个节点，每对节点以概率p独立连接\n特性：\n度分布呈泊松分布 $ P(k) \\sim e^{-\\lambda}\\lambda^k/k! $ 平均聚类系数：$C \\approx p $ 平均路径长度：$L \\sim \\ln(N) $ 生物学意义：\n作为\u0026quot;零模型\u0026quot;（null model）用于评估真实生物网络的显著性 帮助识别网络中的非随机结构（如模块、枢纽节点） MetaNet提供两种随机网络生成方法用于网络分析对比：\n单次随机网络生成\n使用rand_net()基于Erdős-Rényi模型生成与目标网络（相同节点数和边数）的随机对照网络： 1 rand_net(co_net) -\u0026gt; random_net 批量生成与统计比较\n通过rand_net_par()生成多个随机网络并计算拓扑指标分布，再使用compare_rand()进行显著性比较： 1 2 3 4 rand_net_par(co_net, reps = 30) -\u0026gt; randp # 生成30个随机网络 net_par(co_net) -\u0026gt; pars # 计算原网络指标 compare_rand(pars, randp, # 指标对比 index = c(\u0026#34;Average_path_length\u0026#34;, \u0026#34;Clustering_coefficient\u0026#34;)) 复杂网络 在组学研究中构建的网络大多属于复杂网络，其核心特征包括无标度性、小世界性、模块化和层次性，具体定义如下所示：\n无标度性验证 使用fit_power()函数拟合网络的度分布幂律曲线：\n1 2 data(\u0026#34;c_net\u0026#34;, package = \u0026#34;MetaNet\u0026#34;) fit_power(co_net) 小世界性量化\n通过smallworldness()计算小世界指数σ： $$ \\sigma=\\frac{C/C_{random}}{L/L_{random}} $$ 其中C和L分别表示实际网络的聚类系数和平均路径长度，$C_{random}$和$L_{random}$为随机网络对应值。当σ\u0026gt;1时，网络具有小世界特性。\n1 smallworldness(co_net) # 示例输出：43.09368 网络的模块分析下一次介绍。\nReferences Koutrouli M, Karatzas E, Paez-Espino D and Pavlopoulos GA (2020) A Guide to Conquer the Biological Network Era Using Graph Theory. Front. Bioeng. Biotechnol. 8:34. doi: 10.3389/fbioe.2020.00034 Faust, K., and Raes, J. (2012). Microbial interactions: from networks to models. Nat. Rev. Microbiol. https://doi.org/10.1038/nrmicro2832. Y. Deng, Y. Jiang, Y. Yang, Z. He, et al., Molecular ecological network analyses. BMC bioinformatics (2012), doi:10.1186/1471-2105-13-113. ","date":"2025-04-14T00:00:00Z","image":"https://jb-cao.github.io/Cao-blog/p/metanet-6/images/node_topo_hu_6567168b7a277b42.png","permalink":"https://jb-cao.github.io/Cao-blog/p/metanet-6/","title":"MetaNet：多组学网络分析工具｜6.网络拓扑指标分析"},{"content":"上一篇推文介绍了MetaNet进行网络可视化以及各种布局方法，本文将介绍一些扩展绘图方法以及兼容工具。\n软件主页：https://github.com/Asa12138/MetaNet 大家可以帮忙在github上点点star⭐️，谢谢🙏 详细英文版教程：https://bookdown.org/Asa12138/metanet_book/ 可以从 CRAN 安装稳定版：install.packages(\u0026quot;MetaNet\u0026quot;)\n依赖包 pcutils和igraph（需提前安装），推荐配合 dplyr 进行数据操作。\n1 2 3 4 5 6 library(MetaNet) library(igraph) # ========data manipulation library(dplyr) library(pcutils) 兼容工具 ggplot2风格 如果你更熟悉ggplot2，可以使用as.ggig()函数将基础R绘图转换为ggplot2风格：\n1 2 as.ggig(multi1_with_anno) -\u0026gt; ggig class(ggig) 1 ## [1] \u0026#34;ggig\u0026#34; \u0026#34;list\u0026#34; 1 plot(ggig) 这样你就可以使用labs()、theme()、ggsave()和cowplot::plot_grid()等函数来制作更好的图形。\nGephi集成 处理大型数据集时，我推荐使用Gephi进行布局，运行比较快且美观。MetaNet提供了通过graphml格式文件与Gephi的接口：\n1 c_net_save(co_net, filename = \u0026#34;~/Desktop/test\u0026#34;, format = \u0026#34;graphml\u0026#34;) 将test.graphml导入Gephi并进行布局，从Gephi导出graphml文件：test2.graphml，然后在MetaNet中重新绘制：\n1 2 3 4 input_gephi(\u0026#34;~/Desktop/test2.graphml\u0026#34;) -\u0026gt; gephi c_net_plot(gephi$go, coors = gephi$coors, legend_number = T, group_legend_title = \u0026#34;Phylum\u0026#34;) Cytoscape集成 Cytoscape是另一个优秀的网络可视化软件，包含许多插件。将test.graphml导入Cytoscape进行布局，然后导出为cyjs文件，MetaNet可以读取：\n1 2 3 4 input_cytoscape(\u0026#34;~/Desktop/test2.cyjs\u0026#34;) -\u0026gt; cyto c_net_plot(co_net, coors = cyto$coors, legend_number = T, group_legend_title = \u0026#34;Phylum\u0026#34;) NetworkD3交互式可视化 NetworkD3可以生成基于JavaScript的交互式网络图，输出对象是适合网页的htmlwidgets：\n1 netD3plot(multi1_with_anno) 扩展绘图 模块图 使用mark_module=T在网络中标记你的模块，下次会具体介绍网络模块分析：\n1 2 test_module_net \u0026lt;- module_net(module_number = 3, n_node_in_module = 30) c_net_plot(test_module_net, mark_module = T,module_label = T,module_label_just=c(0.2,0.8)) pie节点 把网络里的节点直接画成pie图，不用在AI里面一个个拖过去了：\n1 2 3 4 data(\u0026#34;otutab\u0026#34;) data(\u0026#34;c_net\u0026#34;) hebing(otutab, metadata$Group) -\u0026gt; otutab_G head(otutab_G) 1 2 3 4 5 6 7 ## NS WS CS ## s__un_f__Thermomonosporaceae 1218.3333 1227.3333 1912.1667 ## s__Pelomonas_puraquae 2087.6667 873.5000 1241.6667 ## s__Rhizobacter_bergeniae 819.1667 781.3333 1164.8333 ## s__Flavobacterium_terrae 816.1667 944.6667 986.5000 ## s__un_g__Rhizobacter 821.8333 540.6667 953.3333 ## s__un_o__Burkholderiales 972.6667 327.5000 522.6667 1 2 3 4 co_net_f=c_net_filter(co_net,name%in%head(rownames(otutab_G),40)) c_net_plot(co_net_f,pie_value=otutab_G, vertex.shape=c(\u0026#34;pie\u0026#34;), #把你需要展示pie的节点的shape设置为pie pie_legend=T,color_legend=F,vertex_size_range=c(10,18)) 韦恩图网络 当集合里的点数量合适时，韦恩图网络算是个不错的展示方法\n1 2 3 4 data(otutab, package = \u0026#34;pcutils\u0026#34;) tab \u0026lt;- otutab[400:485, 1:3] head(tab) #0代表不存在 1 2 3 4 5 6 7 ## NS1 NS2 NS3 ## s__un_g__Brevundimonas 0 4 0 ## s__un_g__Shinella 0 10 12 ## s__Ramlibacter_henchirensis 0 9 6 ## s__Cystobacter_gracilis 3 4 17 ## s__un_g__Gordonia 0 6 16 ## s__un_f__Nannocystaceae 0 6 0 1 2 venn_net(tab) -\u0026gt; v_net plot(v_net) 两列边列表 1 2 3 4 5 6 twocol \u0026lt;- data.frame( \u0026#34;col1\u0026#34; = sample(letters, 30, replace = TRUE), \u0026#34;col2\u0026#34; = sample(c(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;), 30, replace = TRUE) ) twocol_net \u0026lt;- twocol_edgelist(twocol) c_net_plot(twocol_net, g_layout_polygon(twocol_net),labels_num = \u0026#34;all\u0026#34;) 网络树 1 2 3 4 5 6 7 8 9 data(\u0026#34;otutab\u0026#34;, package = \u0026#34;pcutils\u0026#34;) cbind(taxonomy, num = rowSums(otutab))[1:20, ] -\u0026gt; test df2net_tree(test) -\u0026gt; ttt par(mfrow = c(1, 2)) plot(ttt, edge_legend = F, main = \u0026#34;Tree network\u0026#34;, legend_position = c(left_leg_x = -1.3), edge.arrow.size = 1,edge.arrow.width = 1,rescale=T) plot(ttt, coors = as_circle_tree(), legend = F, main = \u0026#34;Circle tree network\u0026#34;, edge.arrow.size = 0.5,edge.arrow.width = 1,rescale=T) 奥运五环图 1 olympic_rings_net() 这个也是上次讲的分组布局的应用了，g_layout函数布局，用下面的代码就可以绘制：\n1 2 3 4 5 6 7 8 9 10 11 12 13 r \u0026lt;- 1 pensize \u0026lt;- r / 6 rings_data \u0026lt;- data.frame( x = c(-2 * (r + pensize), -(r + pensize), 0, (r + pensize), 2 * (r + pensize)), y = c(r, 0, r, 0, r), color = c(\u0026#34;#0081C8\u0026#34;, \u0026#34;#FCB131\u0026#34;, \u0026#34;#000000\u0026#34;, \u0026#34;#00A651\u0026#34;, \u0026#34;#EE334E\u0026#34;) ) g1 \u0026lt;- module_net(module_number = 5, n_node_in_module = 30) plot(g1, coors = g_layout(g1, layout1 = rings_data[, 1:2], zoom1 = 1.2, zoom2 = 0.5), rescale = FALSE, legend = FALSE, main = \u0026#34;Olympic Rings\u0026#34;, vertex.frame.color = NA, edge.width = 0, vertex.color = setNames(rings_data$color, 1:5), vertex.size = 7 ) References Koutrouli M, Karatzas E, Paez-Espino D and Pavlopoulos GA (2020) A Guide to Conquer the Biological Network Era Using Graph Theory. Front. Bioeng. Biotechnol. 8:34. doi: 10.3389/fbioe.2020.00034 Faust, K., and Raes, J. (2012). Microbial interactions: from networks to models. Nat. Rev. Microbiol. https://doi.org/10.1038/nrmicro2832. Y. Deng, Y. Jiang, Y. Yang, Z. He, et al., Molecular ecological network analyses. BMC bioinformatics (2012), doi:10.1186/1471-2105-13-113. ","date":"2025-04-13T00:00:00Z","image":"https://jb-cao.github.io/Cao-blog/p/metanet-5/index.en_files/figure-html/unnamed-chunk-10-1_hu_4b960fbf3d789897.png","permalink":"https://jb-cao.github.io/Cao-blog/p/metanet-5/","title":"MetaNet：多组学网络分析工具｜5.扩展绘图与兼容工具"},{"content":"之前已经介绍了网络计算，构建以及各种注释了。本文将详细介绍MetaNet中的各种可视化方法，从基础绘图到高级布局技巧。\n软件主页：https://github.com/Asa12138/MetaNet 大家可以帮忙在github上点点star⭐️，谢谢🙏 详细英文版教程：https://bookdown.org/Asa12138/metanet_book/ 可以从 CRAN 安装稳定版：install.packages(\u0026quot;MetaNet\u0026quot;)\n最新的开发版本可以在 https://github.com/Asa12138/MetaNet 中找到：\n1 remotes::install_github(\u0026#34;Asa12138/MetaNet\u0026#34;, dependencies = T) 依赖包 pcutils和igraph（需提前安装），推荐配合 dplyr 进行数据操作。\n1 2 3 4 5 6 library(MetaNet) library(igraph) # ========data manipulation library(dplyr) library(pcutils) 绘图设置 在构建网络时，MetaNet已经设置了一些与可视化相关的内部属性。我们可以使用c_net_set()函数自定义这些属性以满足研究需求。\n如果需要更灵活地自定义网络图，可以使用c_net_plot()函数，它包含许多灵活的绘图参数：\n示例代码，尝试各种设置看看：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 c_net_plot(multi1_with_anno, labels_num = 5, vertex.color = get_cols(11, \u0026#34;col1\u0026#34;), vertex_size_range = c(3, 10), vertex.label.color = \u0026#34;red\u0026#34;, edge_width_range = c(0.5, 3), edge.color = c(\u0026#34;orange\u0026#34;, \u0026#34;green4\u0026#34;), edge.curved = 0.5, legend = T, legend_number = T, group_legend_order = c(\u0026#34;Microbiome\u0026#34;, \u0026#34;Metabolome\u0026#34;, \u0026#34;Transcriptome\u0026#34;), group_legend_title = c(\u0026#34;Phylum\u0026#34;, \u0026#34;Metabolome\u0026#34;, \u0026#34;Transcriptome\u0026#34;), edge_legend_title = \u0026#34;Correlation\u0026#34;, edge_legend_order = c(\u0026#34;positive\u0026#34;, \u0026#34;negative\u0026#34;), size_legend = T, size_legend_title = \u0026#34;Abundance\u0026#34;, width_legend = T, width_legend_title = \u0026#34;abs(r)\u0026#34;, lty_legend = T, lty_legend_title = \u0026#34;Omics relationship\u0026#34;) 使用params_list params_list是c_net_plot()中的一个特殊参数，它是一个包含参数的列表，可以方便地用于绘制一系列具有相同属性的网络图：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 node_colors \u0026lt;- setNames(get_cols(9, \u0026#34;col1\u0026#34;), unique(V(multi1_with_anno)$v_class)) params_list \u0026lt;- list( labels_num = 5, vertex.color = node_colors, vertex_size_range = c(3, 10), vertex.label.color = \u0026#34;red\u0026#34;, edge_width_range = c(0.5, 3), edge.color = c(\u0026#34;orange\u0026#34;, \u0026#34;green4\u0026#34;), edge.curved = 0.5, legend = T, legend_number = T, group_legend_order = c(\u0026#34;Microbiome\u0026#34;, \u0026#34;Metabolome\u0026#34;, \u0026#34;Transcriptome\u0026#34;), group_legend_title = c(\u0026#34;Phylum\u0026#34;, \u0026#34;Metabolome\u0026#34;, \u0026#34;Transcriptome\u0026#34;), edge_legend_title = \u0026#34;Correlation\u0026#34;, edge_legend_order = c(\u0026#34;positive\u0026#34;, \u0026#34;negative\u0026#34;), size_legend = T, size_legend_title = \u0026#34;Abundance\u0026#34;, width_legend = T, width_legend_title = \u0026#34;abs(r)\u0026#34;, lty_legend = T, lty_legend_title = \u0026#34;Omics relationship\u0026#34; ) c_net_plot(multi1_with_anno, params_list = params_list) 1 2 3 4 5 # 构建另一个多组学网络 multi1_with_anno2 \u0026lt;- c_net_filter(multi1_with_anno, v_group %in% c(\u0026#34;Microbiome\u0026#34;, \u0026#34;Metabolome\u0026#34;)) %\u0026gt;% c_net_filter(., e_class == \u0026#34;intra\u0026#34;, mode = \u0026#34;e\u0026#34;) c_net_plot(multi1_with_anno2, params_list = params_list) 网络布局 布局是网络可视化的重要组成部分，一个好的布局可以清晰地呈现信息。\n在MetaNet中，我们使用coors对象来存储布局的坐标。coors是一个具有\u0026quot;name\u0026quot;, \u0026ldquo;X\u0026rdquo;, \u0026ldquo;Y\u0026quot;三列的dataframe。\n基础布局 使用c_net_layout()获取特定布局方法的坐标：\n1 2 c_net_layout(co_net2, method = in_circle()) -\u0026gt; coors c_net_plot(co_net2, coors) 可用的基础布局方法包括：\nigraph布局：in_circle(), nicely(), on_grid(), on_sphere(), randomly(), with_dh(), with_fr(), with_gem(), with_graphopt(), with_kk(), with_lgl(), with_mds() metanet新布局方法：as_line(), as_arc(), as_polygon(), as_polyarc(), as_polycircle(), as_circle_tree(), as_multi_layer(), as_poly_sector() ggraph布局：\u0026ldquo;auto\u0026rdquo;, \u0026ldquo;backbone\u0026rdquo;, \u0026ldquo;centrality\u0026rdquo;, \u0026ldquo;circlepack\u0026rdquo;, \u0026ldquo;dendrogram\u0026rdquo;, \u0026ldquo;eigen\u0026rdquo;, \u0026ldquo;focus\u0026rdquo;, \u0026ldquo;hive\u0026rdquo;, \u0026ldquo;igraph\u0026rdquo;, \u0026ldquo;linear\u0026rdquo;, \u0026ldquo;manual\u0026rdquo;, \u0026ldquo;matrix\u0026rdquo;, \u0026ldquo;partition\u0026rdquo;, \u0026ldquo;pmds\u0026rdquo;, \u0026ldquo;stress\u0026rdquo;, \u0026ldquo;treemap\u0026rdquo;, \u0026ldquo;unrooted\u0026rdquo; 示例代码展示不同布局效果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 go \u0026lt;- erdos.renyi.game(30, 0.25) # get a metanet go \u0026lt;- c_net_update(go) layout_methods \u0026lt;- list( as_star(), as_tree(), in_circle(), nicely(), on_grid(), on_sphere(), randomly(), with_dh(), with_fr(), with_gem(), with_graphopt(), with_kk(), with_lgl(), with_mds(), as_line(), as_arc(), as_polygon(), as_polyarc(), as_polycircle(3), as_circle_tree(), as_multi_layer(2), as_poly_sector() ) names(layout_methods) \u0026lt;- c( \u0026#34;as_star \u0026#34;, \u0026#34;as_tree \u0026#34;, \u0026#34;in_circle \u0026#34;, \u0026#34;nicely \u0026#34;, \u0026#34;on_grid \u0026#34;, \u0026#34;on_sphere \u0026#34;, \u0026#34;randomly \u0026#34;, \u0026#34;with_dh \u0026#34;, \u0026#34;with_fr \u0026#34;, \u0026#34;with_gem \u0026#34;, \u0026#34;with_graphopt \u0026#34;, \u0026#34;with_kk \u0026#34;, \u0026#34;with_lgl \u0026#34;, \u0026#34;with_mds\u0026#34;, \u0026#34;as_line\u0026#34;, \u0026#34;as_arc\u0026#34;, \u0026#34;as_polygon\u0026#34;, \u0026#34;as_polyarc\u0026#34;, \u0026#34;as_polycircle\u0026#34;, \u0026#34;as_circle_tree\u0026#34;, \u0026#34;as_multi_layer\u0026#34;, \u0026#34;as_poly_sector\u0026#34; ) par(mfrow = c(6, 4)) for (i in names(layout_methods)) { plot(go, layout_methods[[i]], legend = F, main = i, labels_num = 0) } 对于每种方法，可以在其中额外添加一些参数： 1 2 3 4 5 6 # get a metanet go \u0026lt;- erdos.renyi.game(30, 0.25) go \u0026lt;- c_net_update(go) plot(go, coors = with_fr()) plot(go, coors = with_fr(niter = 99, grid = \u0026#34;nogrid\u0026#34;)) as_polygon()很有趣，它可以绘制多边形形状的网络，您可以更改多边形的边数:\n变换布局 使用transform_comors可以转换布局，包括缩放，X/Y比，旋转角度，镜像，伪3D效果等：\n1 2 3 4 5 6 7 8 9 c_net_layout(multi1_with_anno)-\u0026gt;coors c_net_plot(multi1_with_anno, transform_coors(coors, scale = 0.8, aspect_ratio = 0.5, rotation = i, mirror_x = T, shear_x = 1) ) 分组布局 除c_net_layout()外，我们还为具有分组变量的网络提供了一种高级布局方法：g_layout()。 使用g_layout()可以轻松控制每个组的位置及其内部布局。g_layout()返回的也是coors对象，这意味着我们可以继续用g_layout()组合，实现疯狂套娃，高度自定义的布局！\ng_layout()在处理多组学网络或模块网络）时，是布局分组变量网络的极佳选择。\n首先，指定分组变量group 设置组间布局layout1，可选： 数据框或矩阵：行名为组名，两列分别为X和Y坐标 函数：c_net_layout()的各种布局方法（默认：in_circle()） 调整layout1的缩放比例zoom1 设置组内布局layout2（使用c_net_layout()的各种布局方法）， 用一个list，为每个组单独指定布局函数或者直接给一个坐标数据框。 调整layout2的缩放比例zoom2，可用向量分别控制各组缩放 设置show_big_layout = T可查看layout1的分布情况 1 2 3 4 5 # 为每个组设置圆形布局 g_layout(multi1_with_anno, group = \u0026#34;v_group\u0026#34;, layout1 = in_circle(), zoom1 = 10, layout2 = in_circle(), zoom2 = 5) -\u0026gt; g_coors plot(multi1_with_anno, coors = g_coors) 1 2 3 4 5 6 # 为每个组设置不同的布局 g_layout(multi1_with_anno, group = \u0026#34;v_group\u0026#34;, layout1 = in_circle(), zoom1 = 10, layout2 = list(in_circle(), with_fr(), as_polygon()), zoom2 = 3:5) -\u0026gt; g_coors plot(multi1_with_anno, coors = g_coors) tkplot手动调整大布局 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 首先获取网络骨架 get_group_skeleton(co_net, \u0026#34;v_class\u0026#34;) %\u0026gt;% clean_igraph() -\u0026gt; s_net # 使用tkplot进行手动调整 x \u0026lt;- igraph::tkplot(s_net) # 在tkplot窗口中移动节点到你喜欢的布局！ da \u0026lt;- igraph::tkplot.getcoords(x) igraph::tkplot.close(x) # 将调整后的坐标传递给layout1 g_layout(co_net, group = \u0026#34;v_class\u0026#34;, layout1 = da, zoom1 = 20, layout2 = in_circle(), zoom2 = c(1, 4, 2, 1, 3, 5)) -\u0026gt; g_coors plot(co_net, coors = g_coors) MetaNet还提供了一些预设的分组布局方法：\ng_layout_circlepack() g_layout_treemap() g_layout_backbone() g_layout_stress() g_layout_polyarc() g_layout_polygon() g_layout_polycircle() g_layout_multi_layer() 伪3D效果 g_layout_poly_sector() 示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 E(co_net)$color \u0026lt;- rep(\u0026#34;grey\u0026#34;, length(E(co_net))) plot(co_net, coors = g_layout_circlepack(co_net, group = \u0026#34;v_class\u0026#34;), legend = F, labels_num = 0, main = \u0026#34;g_layout_circlepack\u0026#34;) plot(co_net, coors = g_layout_polyarc(co_net, group = \u0026#34;v_class\u0026#34;), legend = F, labels_num = 0, main = \u0026#34;g_layout_polyarc\u0026#34;) plot(co_net, coors = g_layout_polycircle(co_net, group = \u0026#34;v_class\u0026#34;), legend = F, labels_num = 0, main = \u0026#34;g_layout_polycircle\u0026#34;) g1 \u0026lt;- module_net(3) plot(g1, coors = g_layout_multi_layer(g1, group = \u0026#34;v_class\u0026#34;, layout = on_grid()), legend = F, labels_num = 0, main = \u0026#34;g_layout_multi_layer\u0026#34; ) spatstat layout 1 2 3 4 5 6 7 8 9 10 11 12 13 14 if(!require(\u0026#34;spatstat\u0026#34;))install.packages(\u0026#34;spatstat\u0026#34;) E(co_net)$color \u0026lt;- rep(\u0026#34;grey\u0026#34;, length(E(co_net))) par(mfrow = c(2, 2)) poly_x \u0026lt;- c(0, 2, 2, 0) poly_y \u0026lt;- c(0, 0, 1, 1) win_poly \u0026lt;- spatstat.geom::owin(poly = list(x = poly_x, y = poly_y)) plot(win_poly) coors1 \u0026lt;- spatstat_layout(co_net, win_poly, type = \u0026#34;random\u0026#34;, mode = \u0026#34;surface\u0026#34;) plot(co_net, coors = coors1) coors1 \u0026lt;- spatstat_layout(co_net, win_poly, type = \u0026#34;regular\u0026#34;, mode = \u0026#34;surface\u0026#34;,order_by=\u0026#34;v_class\u0026#34;) plot(co_net, coors = coors1) coors2 \u0026lt;- spatstat_layout(co_net2, win_poly, type = \u0026#34;random\u0026#34;, mode = \u0026#34;boundary\u0026#34;) plot(co_net2, coors = coors2) 尝试画个五角星⭐️：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 library(spatstat.geom) create_star_window \u0026lt;- function(r_outer = 1, r_inner = 0.4, center = c(0, 0)) { # 创建五角星的10个顶点（外、内交替） theta \u0026lt;- seq(0, 2 * pi, length.out = 11)[-11] # 10个点 theta_outer \u0026lt;- theta[seq(1, 10, 2)] theta_inner \u0026lt;- theta[seq(2, 10, 2)] x \u0026lt;- c(r_outer * cos(theta_outer), r_inner * cos(theta_inner)) y \u0026lt;- c(r_outer * sin(theta_outer), r_inner * sin(theta_inner)) # 重新排序成首尾相连的路径 order_index \u0026lt;- c(1,6,2,7,3,8,4,9,5,10) x \u0026lt;- x[order_index] + center[1] y \u0026lt;- y[order_index] + center[2] # 构建 spatstat 的 owin 窗口 win \u0026lt;- owin(poly = list(x = x, y = y)) return(win) } win_star \u0026lt;- create_star_window() plot(co_net, coors = spatstat_layout(co_net, win_star, order_by=\u0026#34;v_class\u0026#34;)) 甚至可以画成地图：\n1 2 3 4 5 6 7 8 library(rnaturalearth) library(sf) # 获取非洲国家边界（1:50m精度） africa_sf \u0026lt;- ne_countries(continent = \u0026#34;Africa\u0026#34;, scale = 50, returnclass = \u0026#34;sf\u0026#34;) # 可视化 plot(st_geometry(africa_sf), col = \u0026#34;sandybrown\u0026#34;, main = \u0026#34;Africa Outline (1:50m)\u0026#34;, ) 1 plot(co_net, coors = spatstat_layout(co_net, africa_sf, type = \u0026#34;regular\u0026#34;, order_by=\u0026#34;v_class\u0026#34;)) MetaNet使用的是igraph的绘图方式，R的基础绘图，所以需要用pdf,png等设备保存图片。下一节介绍MetaNet和其他绘图方式如ggplot2，D3等的转换，以及MetaNet配合Gephi，Cytoscape等交互式软件使用。\nReferences Koutrouli M, Karatzas E, Paez-Espino D and Pavlopoulos GA (2020) A Guide to Conquer the Biological Network Era Using Graph Theory. Front. Bioeng. Biotechnol. 8:34. doi: 10.3389/fbioe.2020.00034 Faust, K., and Raes, J. (2012). Microbial interactions: from networks to models. Nat. Rev. Microbiol. https://doi.org/10.1038/nrmicro2832. Y. Deng, Y. Jiang, Y. Yang, Z. He, et al., Molecular ecological network analyses. BMC bioinformatics (2012), doi:10.1186/1471-2105-13-113. ","date":"2025-04-12T00:00:00Z","image":"https://jb-cao.github.io/Cao-blog/p/metanet-4/index.en_files/figure-html/unnamed-chunk-13-1_hu_1feb6a74e37c3b32.png","permalink":"https://jb-cao.github.io/Cao-blog/p/metanet-4/","title":"MetaNet：多组学网络分析工具｜4.布局和可视化"},{"content":"上一篇推文已经介绍了使用R包MetaNet进行网络计算和构建，本文将介绍如何对我们构建好的网络进行各种操作，包括添加注释和属性，筛选合并等。\n软件主页：https://github.com/Asa12138/MetaNet 大家可以帮忙在github上点点star⭐️，谢谢🙏 详细英文版教程：https://bookdown.org/Asa12138/metanet_book/ 可以从 CRAN 安装稳定版：install.packages(\u0026quot;MetaNet\u0026quot;)\n最新的开发版本可以在 https://github.com/Asa12138/MetaNet 中找到：\n1 remotes::install_github(\u0026#34;Asa12138/MetaNet\u0026#34;, dependencies = T) 依赖包 pcutils和igraph（需提前安装），推荐配合 dplyr 进行数据操作。\n1 2 3 4 5 6 library(MetaNet) library(igraph) # ========data manipulation library(dplyr) library(pcutils) MetaNet网络对象(metanet)继承自igraph类，因此可以使用所有igraph的函数，可以参考igraph manual 。构建网络的基本流程如下：\n1 2 3 4 5 6 7 8 9 10 11 12 # 加载数据 data(otutab, package=\u0026#34;pcutils\u0026#34;) t(otutab) -\u0026gt; totu # 计算相关性 c_net_calculate(totu, method=\u0026#34;spearman\u0026#34;) -\u0026gt; corr # 构建网络(设置相关系数阈值0.6，p值阈值0.05) c_net_build(corr, r_threshold =0.6, p_threshold = 0.05, delete_single=T) -\u0026gt; co_net # 查看网络类 class(co_net) 1 ## [1] \u0026#34;metanet\u0026#34; \u0026#34;igraph\u0026#34; 网络属性 MetaNet提供了便捷的函数获取网络、节点和边的属性，使用get_*()获取属性表格：\n1 2 # 获取网络整体属性 get_n(co_net) 1 2 ## n_type ## 1 single 1 2 # 获取节点属性(前5行) get_v(co_net) %\u0026gt;% head(5) 1 2 3 4 5 6 7 8 9 10 11 12 ## name v_group v_class size ## 1 s__un_f__Thermomonosporaceae v_group1 v_class1 4 ## 2 s__Pelomonas_puraquae v_group1 v_class1 4 ## 3 s__Rhizobacter_bergeniae v_group1 v_class1 4 ## 4 s__Flavobacterium_terrae v_group1 v_class1 4 ## 5 s__un_g__Rhizobacter v_group1 v_class1 4 ## label shape color ## 1 s__un_f__Thermomonosporaceae circle #a6bce3 ## 2 s__Pelomonas_puraquae circle #a6bce3 ## 3 s__Rhizobacter_bergeniae circle #a6bce3 ## 4 s__Flavobacterium_terrae circle #a6bce3 ## 5 s__un_g__Rhizobacter circle #a6bce3 1 2 # 获取边属性(前5行) get_e(co_net) %\u0026gt;% head(5) 1 2 3 4 5 6 7 8 9 10 11 12 ## id from to weight ## 1 1 s__un_f__Thermomonosporaceae s__Actinocorallia_herbida 0.6759546 ## 2 2 s__un_f__Thermomonosporaceae s__Kribbella_catacumbae 0.6742386 ## 3 3 s__un_f__Thermomonosporaceae s__Kineosporia_rhamnosa 0.7378741 ## 4 4 s__un_f__Thermomonosporaceae s__un_f__Micromonosporaceae 0.6236449 ## 5 5 s__un_f__Thermomonosporaceae s__Flavobacterium_saliperosum 0.6045747 ## cor p.value e_type width color e_class lty ## 1 0.6759546 0.0020739524 positive 0.6759546 #48A4F0 e_class1 1 ## 2 0.6742386 0.0021502138 positive 0.6742386 #48A4F0 e_class1 1 ## 3 0.7378741 0.0004730567 positive 0.7378741 #48A4F0 e_class1 1 ## 4 0.6236449 0.0056818984 positive 0.6236449 #48A4F0 e_class1 1 ## 5 0.6045747 0.0078660171 positive 0.6045747 #48A4F0 e_class1 1 MetaNet网络在构建时会自动设置一些内部属性，这些属性与后续分析和可视化密切相关：\n属性名称 描述 可视化关联 v_group 节点的大分组(通常一个组学数据产生一个分组) 节点形状 v_class 节点的分类或网络模块注释 节点颜色 size 节点的数值属性 节点大小 e_type 边的类型(通常根据相关性分为positive/negative) 边颜色 width 边的数值属性 边宽度 e_class 边的第二类型(通常根据节点分组分为intra/inter) 边线型 网络注释添加 在微生物组学或多组学分析中，我们经常需要将大量注释表格添加到网络对象中，例如物种丰度表、分类学表格等。\nc_net_annotate 可以方便添加注释表格，anno_tab是一个dataframe，如果注释节点，需要有一列name对应node name。如果注释边，需要有一列from和to对应边的起点和终点。\n添加点注释 注释数据框需要包含行名或\u0026quot;name\u0026quot;列，这些标识需要与metanet网络中的顶点名称匹配。使用c_net_annotate(mode = \u0026quot;v\u0026quot;)或等效的anno_vertex()函数时，系统会自动匹配顶点名称并合并表格。\n1 2 3 # 添加分类注释(Phylum级别) c_net_annotate(co_net, anno_tab = taxonomy[\u0026#34;Phylum\u0026#34;], mode=\u0026#34;v\u0026#34;) -\u0026gt; co_net1 get_v(co_net1) %\u0026gt;% head(5) 1 2 3 4 5 6 7 8 9 10 11 12 ## name v_group v_class size ## 1 s__un_f__Thermomonosporaceae v_group1 v_class1 4 ## 2 s__Pelomonas_puraquae v_group1 v_class1 4 ## 3 s__Rhizobacter_bergeniae v_group1 v_class1 4 ## 4 s__Flavobacterium_terrae v_group1 v_class1 4 ## 5 s__un_g__Rhizobacter v_group1 v_class1 4 ## label shape color Phylum ## 1 s__un_f__Thermomonosporaceae circle #a6bce3 p__Actinobacteria ## 2 s__Pelomonas_puraquae circle #a6bce3 p__Proteobacteria ## 3 s__Rhizobacter_bergeniae circle #a6bce3 p__Proteobacteria ## 4 s__Flavobacterium_terrae circle #a6bce3 p__Bacteroidetes ## 5 s__un_g__Rhizobacter circle #a6bce3 p__Proteobacteria 添加边注释 c_net_annotate(mode = \u0026quot;e\u0026quot;)或anno_edge()函数接受相同格式的注释数据框，但会自动匹配\u0026quot;from\u0026quot;和\u0026quot;to\u0026quot;列，方便用户进行网络连接的统计分析。\n1 2 3 4 5 6 7 8 # 创建边注释数据 anno \u0026lt;- data.frame(\u0026#34;from\u0026#34;=\u0026#34;s__un_f__Thermomonosporaceae\u0026#34;, \u0026#34;to\u0026#34;=\u0026#34;s__Actinocorallia_herbida\u0026#34;, new_atr=\u0026#34;new\u0026#34;) # 添加边注释 c_net_annotate(co_net, anno, mode=\u0026#34;e\u0026#34;) -\u0026gt; co_net1 get_e(co_net1) %\u0026gt;% head(5) 1 2 3 4 5 6 7 8 9 10 11 12 ## id from to weight ## 1 1 s__un_f__Thermomonosporaceae s__Actinocorallia_herbida 0.6759546 ## 2 2 s__un_f__Thermomonosporaceae s__Kribbella_catacumbae 0.6742386 ## 3 3 s__un_f__Thermomonosporaceae s__Kineosporia_rhamnosa 0.7378741 ## 4 4 s__un_f__Thermomonosporaceae s__un_f__Micromonosporaceae 0.6236449 ## 5 5 s__un_f__Thermomonosporaceae s__Flavobacterium_saliperosum 0.6045747 ## cor p.value e_type width color e_class lty new_atr ## 1 0.6759546 0.0020739524 positive 0.6759546 #48A4F0 e_class1 1 new ## 2 0.6742386 0.0021502138 positive 0.6742386 #48A4F0 e_class1 1 \u0026lt;NA\u0026gt; ## 3 0.7378741 0.0004730567 positive 0.7378741 #48A4F0 e_class1 1 \u0026lt;NA\u0026gt; ## 4 0.6236449 0.0056818984 positive 0.6236449 #48A4F0 e_class1 1 \u0026lt;NA\u0026gt; ## 5 0.6045747 0.0078660171 positive 0.6045747 #48A4F0 e_class1 1 \u0026lt;NA\u0026gt; 使用igraph方法添加属性 如果您有一个向量，并且确定与网络的顶点名称匹配，则可以使用igraph方法来注释（不建议），边注释向量相同。有关更多详细信息，请参阅igraph手册。\n1 2 3 4 5 # 添加节点属性 V(co_net1)$new_attri \u0026lt;- seq_len(length(co_net1)) # 添加边属性 E(co_net1)$new_attri \u0026lt;- \u0026#34;new attribute\u0026#34; 网络属性设置 c_net_set()函数可以方便地添加多个注释表格并设置网络可视化相关的内部属性。\n为网络添加多个注释表格后，可以通过指定列名来设置以下属性：\nvertex_group：顶点分组（可指定一个或多个列） vertex_class：顶点类别 vertex_size：顶点大小 edge_type：边类型 edge_class：边类别 edge_width：边宽度 系统会自动完成以下设置：\n颜色方案 线条类型 节点形状 图例生成 只需使用plot()函数即可生成基础网络图。如需进一步自定义可视化效果，下一次会详细介绍网络布局和可视化。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # 加载多组学数据 data(\u0026#34;multi_test\u0026#34;, package=\u0026#34;MetaNet\u0026#34;) data(\u0026#34;c_net\u0026#34;, package=\u0026#34;MetaNet\u0026#34;) # 构建多组学网络 multi1 \u0026lt;- multi_net_build(list(Microbiome=micro, Metabolome=metab, Transcriptome=transc)) plot(multi1) # 设置节点分类属性 multi1_with_anno \u0026lt;- c_net_set(multi1, micro_g, metab_g, transc_g, vertex_class=c(\u0026#34;Phylum\u0026#34;,\u0026#34;kingdom\u0026#34;,\u0026#34;type\u0026#34;)) # 设置节点大小属性 multi1_with_anno \u0026lt;- c_net_set(multi1_with_anno, data.frame(\u0026#34;Abundance1\u0026#34;=colSums(micro)), data.frame(\u0026#34;Abundance2\u0026#34;=colSums(metab)), data.frame(\u0026#34;Abundance3\u0026#34;=colSums(transc)), vertex_size=paste0(\u0026#34;Abundance\u0026#34;,1:3)) # 绘制网络 plot(multi1_with_anno) 网络操作 网络过滤/子网络 正确设置网络后，你可能有时候需要分析整个网络的一部分（尤其是在多组学分析中），c_net_filter()可以方便地获取子网络，您可以放置大量的过滤条件（例如dplyr::filter）并获得所需的子网络。\n1 2 3 4 5 6 7 8 # 过滤特定组和边类型 multi2 \u0026lt;- c_net_filter(multi1_with_anno, v_group %in% c(\u0026#34;Microbiome\u0026#34;,\u0026#34;Metabolome\u0026#34;)) %\u0026gt;% c_net_filter(., e_class==\u0026#34;intra\u0026#34;, mode=\u0026#34;e\u0026#34;) # 绘制对比图 par(mfrow=c(2,1)) plot(multi1_with_anno, lty_legend=T, main=\u0026#34;Before filtering network\u0026#34;) plot(multi2, lty_legend=T, main=\u0026#34;After filtering network\u0026#34;) 网络合并 如果你有多个网络并想将它们组合在一起，你可以使用c_net_union()函数：\n1 2 3 4 5 6 data(\u0026#34;c_net\u0026#34;) plot(co_net) plot(co_net2) co_net_union \u0026lt;- c_net_union(co_net, co_net2) plot(co_net_union) 网络骨架提取 若需根据分组统计边的来源和目标，summ_2col函数提供了简便的实现方式。\n参数direct = F表示处理无向关系，此时\u0026quot;a-b\u0026quot;和\u0026quot;b-a\u0026quot;会被合并统计为同一种边类型。\n1 2 3 4 5 6 # 添加Phylum分类注释 c_net_annotate(co_net, select(taxonomy,\u0026#34;Phylum\u0026#34;), mode=\u0026#34;e\u0026#34;) -\u0026gt; co_net1 # 统计Phylum间的连接 df \u0026lt;- get_e(co_net1)[,c(\u0026#34;Phylum_from\u0026#34;,\u0026#34;Phylum_to\u0026#34;)] summ_2col(df, direct=F) %\u0026gt;% arrange(-count) -\u0026gt; Phylum_from_to 1 2 # 桑基图展示 pcutils::my_sankey(Phylum_from_to, dragY=T, fontSize=10, width=600, numberFormat=\u0026#34;,.4\u0026#34;) 1 2 # 环形布局展示 links_stat(co_net1, topN=5, group=\u0026#34;Phylum\u0026#34;, e_type=\u0026#34;all\u0026#34;) 1 2 3 4 5 6 7 8 # 设置Phylum分类 c_net_set(co_net, select(taxonomy,\u0026#34;Phylum\u0026#34;)) -\u0026gt; co_net1 # 提取网络骨架 get_group_skeleton(co_net1, Group=\u0026#34;Phylum\u0026#34;) -\u0026gt; ske_net # 绘制骨架图 plot(ske_net, vertex.label=NA) 网络保存导出 MetaNet支持多种格式的网络导出：\n1 2 3 4 5 6 7 8 # 导出为数据框格式 c_net_save(co_net, filename=\u0026#34;My_net\u0026#34;, format=\u0026#34;data.frame\u0026#34;) # 导出为graphml格式(兼容Gephi等软件) c_net_save(co_net, filename=\u0026#34;My_net\u0026#34;, format=\u0026#34;graphml\u0026#34;) # 从文件加载网络 c_net_load(\u0026#34;My_net.graphml\u0026#34;)-\u0026gt;mynet References Koutrouli M, Karatzas E, Paez-Espino D and Pavlopoulos GA (2020) A Guide to Conquer the Biological Network Era Using Graph Theory. Front. Bioeng. Biotechnol. 8:34. doi: 10.3389/fbioe.2020.00034 Faust, K., and Raes, J. (2012). Microbial interactions: from networks to models. Nat. Rev. Microbiol. https://doi.org/10.1038/nrmicro2832. Y. Deng, Y. Jiang, Y. Yang, Z. He, et al., Molecular ecological network analyses. BMC bioinformatics (2012), doi:10.1186/1471-2105-13-113. ","date":"2025-04-11T00:00:00Z","image":"https://jb-cao.github.io/Cao-blog/p/metanet-3/images/anno_hu_6537b44cfb7f7d8b.png","permalink":"https://jb-cao.github.io/Cao-blog/p/metanet-3/","title":"MetaNet：多组学网络分析工具｜3.网络注释与操作"},{"content":"上一篇推文简单介绍了网络基本概念和用于组学网络分析的R包MetaNet，这里我们具体介绍网络分析第一步，网络计算和构建。\n软件主页：https://github.com/Asa12138/MetaNet 大家可以帮忙在github上点点star⭐️，谢谢🙏 详细英文版教程：https://bookdown.org/Asa12138/metanet_book/ 可以从 CRAN 安装稳定版：install.packages(\u0026quot;MetaNet\u0026quot;)\n最新的开发版本可以在 https://github.com/Asa12138/MetaNet 中找到：\n1 remotes::install_github(\u0026#34;Asa12138/MetaNet\u0026#34;, dependencies = T) 依赖包 pcutils和igraph（需提前安装），推荐配合 dplyr 进行数据操作。\n1 2 3 4 5 6 library(MetaNet) library(igraph) # ========data manipulation library(dplyr) library(pcutils) 预处理 在构建各类组学网络之前，不同组学数据（如微生物组、转录组、代谢组等）需要经过适当的预处理，以确保数据质量并提高网络分析的可靠性。\ntrans函数包含许多归一化方法，适用于预处理不同的组学：\n方法 描述 cpm 百万分计数 minmax 线性转换到(min, max)区间 acpm 百万分计数后进行反双曲正弦转换 log1 log(n+1)转换 total 除以总和 max 除以最大值 frequency 除以总和并乘以非零项数量，使非零项平均值为1 normalize 使边际平方和等于1 range 标准化到(0,1)范围(同minmax(0,1)) rank 用递增秩替换丰度值，零保持不变 rrank 类似rank但使用相对秩，最大为1 pa 将x缩放到存在/不存在尺度(0/1) standardize 缩放到零均值和单位方差 hellinger \u0026ldquo;total\u0026quot;方法的平方根 log Anderson等(2006)建议的对数变换 alr 加性对数比(\u0026lsquo;alr\u0026rsquo;)变换(Aitchison 1986) clr 中心对数比(\u0026lsquo;clr\u0026rsquo;)变换(Aitchison 1986) rclr 稳健clr(\u0026lsquo;rclr\u0026rsquo;)，允许数据包含零 1 trans(otutab, method = \u0026#34;log1\u0026#34;) %\u0026gt;% head() 此外，rm_low()， guolv() ， hebing() 函数可以帮助过滤或聚合组学数据，这些函数在数据清洗和特征选择阶段非常有用。\n成对关系计算 成对关系是网络构建的基础。由于实验数据通常相对稀少，我们主要依赖统计推断来确定成对关系，当然如果你已经有确定的关系了就可以跳过这一部分直接去构建网络即可。目前主要有两种统计方式：\n相似性或相关性：例如Spearman、Pearson、Bray-Curtis等。可以计算配对特征之间的相似性矩阵，并使用随机化数据重复计算显著性。最终在网络中保留有意义的相似性。 回归分析：将特征分为源和目标，使用多元回归计算特征之间的关系。\n还有一些工具使用特殊方法来优化网络构建，如SparCC等。\nCorrelation 相关性是描述两个变量协调运动程度的统计术语。相关性计算是所有组学网络分析软件的第一步，有许多方法可以获取ρ和p值。然而，随着组学数据规模越来越大，一些方法变得非常耗时且计算资源密集。\nMetaNet提供了c_net_calculate()函数，可以快速计算单个表或两个表之间的相关性，返回包含ρ和p值的coor对象。\n1 2 3 4 # 单表计算 t(otutab) -\u0026gt; totu c_net_calculate(totu, method = \u0026#34;spearman\u0026#34;) -\u0026gt; corr corr 1 2 3 ## Correlation table: ## Table dimensions: 485 rows, 485 columns ## Use method: spearman 1 2 3 4 # 双表计算 metadata[,3:10] -\u0026gt; env c_net_calculate(totu, env, method = \u0026#34;spearman\u0026#34;) -\u0026gt; corr2 corr2 1 2 3 ## Correlation table: ## Table dimensions: 485 rows, 8 columns ## Use method: spearman 对于大型输入表，计算可能需要较长时间，可以保存结果稍后读取：\n1 2 3 c_net_calculate(matrix(rnorm(1000*100), ncol=1000), method=\u0026#34;spearman\u0026#34;) -\u0026gt; corr save_corr(corr, \u0026#34;../saved_corr1\u0026#34;) read_corr(\u0026#34;../saved_corr1\u0026#34;) -\u0026gt; corr_new 性能测试表明，计算1000个特征的表相关性约需0.2秒，保存的.corr文件大小约6MB。时间、内存消耗和保存文件大小大致随特征数量的平方线性增加。\nc_net_calculate的计算速度比其他R包快得多，特别是在特征数量很大的情况下：\nDistance 在群落分析中，我们需要理解相异指数(距离)。vegan::vegdist()函数提供了基于丰度计算的广泛距离度量。此外，还有一些包含系统发育数据的距离度量，如\u0026quot;unifrac\u0026rdquo;、\u0026ldquo;beta_mpd\u0026rdquo;、\u0026ldquo;beta_mntd\u0026quot;和\u0026quot;phylosor\u0026quot;等。相似性指数通常是距离指数的倒数或1-distance。\n我们也可以使用c_net_calculate()来计算距离：\n1 2 c_net_calculate(otutab, method=\u0026#34;bray\u0026#34;) -\u0026gt; sim_df sim_df 1 2 3 ## Similarity (1-Distance) table: ## Table dimensions: 18 rows, 18 columns ## Use method: bray 常用的群落不相似性指数包括：\n距离系数 描述 Manhattan 曼哈顿距离计算每个维度中坐标的绝对差之和。适用于具有分类变量或属性的数据。 Euclidean 欧几里得距离计算多维空间中两点之间的直线距离。通常用于连续且没有分类属性的数据。 Canberra 堪培拉距离是曼哈顿距离的加权版本，强调坐标之间微小差异的重要性。常用于生态数据分析。 Clark Clark距离测量两个样本之间不同非零属性的比例。 Bray Bray距离基于丰度绝对差异之和计算样本间不相似性。 Kulczynski Kulczynski距离基于共有属性比例的算术平均值测量样本间相似性。 Jaccard Jaccard距离基于独特属性的比例测量样本间不相似性。常用于生态学中的二元数据。 Gower Gower距离是曼哈顿距离的泛化，适用于包括分类和连续变量的混合数据类型。 AltGower AltGower距离是Gower距离的替代形式，使用替代方法标准化连续变量。 Morisita Morisita距离基于共享属性的频率测量样本间不相似性，强调稀有属性。 Horn Horn距离基于共享属性比例的几何平均值测量样本间不相似性。 Mountford Mountford距离基于共享属性比例的算术平均值的倒数测量样本间不相似性。 Raup Raup距离基于共享属性的概率测量样本间不相似性。 Binomial Binomial距离基于观察共享属性的概率测量样本间不相似性。 Chao Chao距离是Jaccard距离的修正，调整了对稀有物种的欠采样。 Cao Cao距离是Chao距离的修正，加入了物种丰度信息。 Mahalanobis Mahalanobis距离考虑变量间相关性，测量多维空间中两个样本的距离。 Chisq Chisq距离基于分类变量间的卡方距离计算样本间不相似性。 Chord Chord距离基于多维空间中点之间角度计算样本间不相似性。 Hellinger Hellinger距离基于平方根转换丰度的平方差之和的平方根测量样本间不相似性。 Aitchison Aitchison距离是对组成数据的转换，允许在对数比空间中进行欧几里得距离计算。 Robust Aitchison 稳健Aitchison距离是Aitchison距离的稳健版本，减少了数据中异常值的影响。 Unifrac Unifrac距离基于系统发育树中的进化距离测量微生物群落间不相似性。 Beta MPD Beta MPD(平均系统发育距离)基于物种对的平均系统发育距离测量两个群落间的系统发育多样性。 Beta MNTD Beta MNTD(平均最近分类单元距离)基于平均最近分类单元距离测量两个群落间的系统发育周转。 Phylosor Phylosor距离基于系统发育树中共享分支的比例测量群落间不相似性。 Others NetCoMi包中还有一些其他可用于网络构建的方法：\nBiweight Midcorrelation bicor() from WGCNA package\nCCLasso (R code on GitHub)\nCCREPE (ccrepe package)\nSPRING (SPRING package)\ngCoda (R code on GitHub)\npropr (propr package)\nKullback-Leibler divergence (KLD) (KLD() from LaplacesDemon package)\nJeffrey divergence (own code using KLD() from LaplacesDemon package)\nJensen-Shannon divergence (own code using KLD() from LaplacesDemon package)\n网络构建 手动阈值构建 如果已经完成了c_net_calculate()步骤，那么可以通过c_net_build()轻松获得网络(metanet对象，继承自igraph对象)。一些常见属性会自动设置。\n1 2 c_net_build(corr, r_threshold =0.6, p_threshold =0.05, delete_single=T) -\u0026gt; co_net co_net 1 2 3 4 5 6 7 8 9 10 11 12 13 ## =================================== metanet ==================================== ## IGRAPH 179b785 UNW- 483 1513 -- ## + attr: n_type (g/c), name (v/c), v_group (v/c), v_class (v/c), size ## | (v/n), label (v/c), shape (v/c), color (v/c), id (e/n), from (e/c), ## | to (e/c), weight (e/n), cor (e/n), p.value (e/n), e_type (e/c), width ## | (e/n), color (e/c), e_class (e/c), lty (e/n) ## + edges from 179b785 (vertex names): ## [1] s__un_f__Thermomonosporaceae--s__Actinocorallia_herbida ## [2] s__un_f__Thermomonosporaceae--s__Kribbella_catacumbae ## [3] s__un_f__Thermomonosporaceae--s__Kineosporia_rhamnosa ## [4] s__un_f__Thermomonosporaceae--s__un_f__Micromonosporaceae ## [5] s__un_f__Thermomonosporaceae--s__Flavobacterium_saliperosum ## + ... omitted several edges 1 plot(co_net) 对于多表分析，可以使用multi_net_build()计算和构建网络：\n1 2 3 data(\u0026#34;multi_test\u0026#34;, package=\u0026#34;MetaNet\u0026#34;) multi_net_build(list(Microbiome=micro, Metabolome=metab, Transcriptome=transc)) -\u0026gt; multi1 plot(multi1) RMT优化 基于相关性的关联网络方法因其简单的计算过程和噪声容限而最常用。然而，大多数涉及关联网络分析的研究使用任意阈值(通常使用r\u0026gt;0.6, p\u0026lt;0.05)，因此构建的网络是主观的而非客观的。\n这个问题已经通过基于随机矩阵理论(RMT)的方法部分解决，该方法能够从微阵列数据(以及其他组学数据)中自动识别网络构建的适当阈值。(Y. Deng, Y. Jiang, Y. Yang, Z. He, et al., Molecular ecological network analyses. BMC bioinformatics (2012), doi:10.1186/1471-2105-13-113.)\n使用RMT_threshold()，我们可以找到一个合适的r_threshold来构建噪声最小的网络。较大的log_LE、较小的log_LW、较小的log_see、较大的p_ks_test表明r_threshold对于有意义的网络构建更好。可以更改阈值范围以进行更精细的计算。（但其实也很难确定一个非常合适的结果，几个指标指示的也不一致😂，有时候还是跟着文献自定义阈值方便）\n1 2 3 RMT_threshold(corr, out_dir=\u0026#34;../RMT_temp/\u0026#34;, min_threshold=0.5, max_threshold=0.9, step=0.02, verbose=T) -\u0026gt; rmt_res plot(rmt_res) 可以在RMT_threshold()中设置gif=TRUE并获取gif文件，以观察不同r阈值下特征值间距的分布。\n边表格 如果已经从其他方法(数据库)获得了数据的成对关系，可以将其形成边列表并使用c_net_from_edgelist构建网络：\n1 2 3 data(\u0026#34;edgelist\u0026#34;, package=\u0026#34;MetaNet\u0026#34;) dnet \u0026lt;- c_net_from_edgelist(arc_count, direct=T) plot(dnet) 其他 如果已经有其他格式的网络，如pajek、lgl、graphml、dimacs、graphdb、gml和dl，可以使用c_net_load将其读取为metanet对象。也可以使用graph_from_*函数获取igraph对象，然后使用c_net_update将其转换为metanet对象。\n1 2 3 4 5 6 7 8 9 g1 \u0026lt;- graph_from_lcf(12, c(5, -5), 6) class(g1) ## [1] \u0026#34;igraph\u0026#34; plot(g1) c_net_update(g1) -\u0026gt; g2 class(g2) ## [1] \u0026#34;metanet\u0026#34; \u0026#34;igraph\u0026#34; plot(g2) 通过本文介绍的方法，可以了解从组学数据预处理到网络构建的流程，为后续的网络分析和生物学解释奠定基础。MetaNet包提供的这些功能使得组学网络分析变得更加高效。下一篇就将介绍如何给我们构建好的网络进行各种操作，包括添加注释和属性，筛选合并等。\nReferences Koutrouli M, Karatzas E, Paez-Espino D and Pavlopoulos GA (2020) A Guide to Conquer the Biological Network Era Using Graph Theory. Front. Bioeng. Biotechnol. 8:34. doi: 10.3389/fbioe.2020.00034 Faust, K., and Raes, J. (2012). Microbial interactions: from networks to models. Nat. Rev. Microbiol. https://doi.org/10.1038/nrmicro2832. Y. Deng, Y. Jiang, Y. Yang, Z. He, et al., Molecular ecological network analyses. BMC bioinformatics (2012), doi:10.1186/1471-2105-13-113. ","date":"2025-04-10T00:00:00Z","image":"https://jb-cao.github.io/Cao-blog/p/metanet-2/images/pairwise_relationship_hu_383f7ee51bf1717d.png","permalink":"https://jb-cao.github.io/Cao-blog/p/metanet-2/","title":"MetaNet：多组学网络分析工具｜2.网络计算和构建"},{"content":"网络分析是各种组学数据分析的重要组成部分。我在刚接触生信时对这类分析还挺感兴趣的，一边学一边写了个R包MetaNet。因为同类型工具有不少，包括在线网站，交互界面等，也就一直没有推广，主要是给自己用的。但现在整着整着感觉也比较系统了，也有一些别的工具不好实现的功能，想发出来让大家用用看。大家也可以帮忙在github上点点star⭐️，谢谢🙏\n软件主页：https://github.com/Asa12138/MetaNet 详细英文版教程：https://bookdown.org/Asa12138/metanet_book/ ps，我是看到\u0026quot;生信益站\u0026quot;有篇推文翻译了一下我的MetaNet的README文件，收获了近2万阅读量😂想起来搞一下这个。最近可能也会先提交一个preprint。\nIntroduction 网络（Network）或图（Graph）是用于描述复杂系统中元素间相互关系的数学结构，广泛应用于生物学、计算机科学、社会学等领域。网络由节点（Node/Vertex） 和 边（Edge） 组成，其中节点代表系统中的实体（如基因、蛋白质、用户），边表示它们之间的连接关系（如相互作用、通信、调控）。\n基本类型 1. 无向图（Undirected Graph）\n无向图中的连接没有方向性，节点之间的关系是双向的。例如，在社交网络中，两个人成为好友意味着彼此互为邻居。在生物学中，基因共表达网络就是一种典型的无向图，连接表示两个基因的表达水平具有相关性。\n2. 有向图（Directed Graph）\n有向图中的连接带有方向，表示单向关系。例如，在信号通路中，一个蛋白质可能激活或抑制另一个蛋白质，这种调控关系具有明确的指向性。生物学中常用不同箭头样式表示不同类型的调控作用（如激活、抑制）。\n3. 加权图（Weighted Graph）\n加权图的每条连接都有一个权重值，用于表示关系的强度或重要性。例如，在蛋白质相互作用网络中，权重可以反映实验验证的可靠性；在基因共表达网络中，权重可能代表相关性的大小。\n4. 二分图（Bipartite Graph）\n二分图的节点可以分成两组，连接只存在于不同组的节点之间。例如，在药物-靶点网络中，药物和靶点属于不同的组，连接表示某种药物作用于某个靶点。\n5. 多重边图（Multi-edge Graph）\n多重边图允许同一对节点之间存在多条连接。例如，在知识图谱中，两个实体之间可能有多种不同类型的关系（如基因A既调控基因B，又与基因B有物理相互作用）。\n6. 超图（Hypergraph）\n超图的连接可以同时关联多个节点，适用于描述复杂的高阶关系。例如，在代谢网络中，一个生化反应可能涉及多个底物和产物，超图可以更自然地表示这种多分子参与的相互作用。\n7. 树（Tree）\n树是一种特殊的无向图，其中任意两个节点之间只有一条路径相连，且没有环路。例如，进化树描述物种之间的演化关系，基因本体树则用于表示功能分类的层级结构。\n8. 连通图（Connected Graph）\n在连通图中，任意两个节点之间至少存在一条路径。如果网络不连通，则可能由多个独立子图组成，例如某些微生物群落网络可能包含多个互不关联的物种群体。\n9. 完全图（Complete Graph）\n完全图中每对不同的节点之间都有一条连接。虽然在实际生物网络中较少见，但在某些模拟分析中，完全图可以作为理论参考模型。\n10. 团（Clique）\n团是指无向图中一个节点子集，其中每对节点之间都有连接。在蛋白质相互作用网络中，高度紧密的团可能代表蛋白质复合物或功能模块。\n组学应用 在生物医学，尤其是近期的组学研究中，网络可以捕获任何类型的生物实体之间的关联，例如蛋白质，基因，小分子，代谢产物，配体，疾病，药物甚至数据库记录。网络分析提供系统级视角解析复杂机制，覆盖从分子到生态系统的多层次研究，是整合多组学数据的重要方法。\n1. 蛋白质-蛋白质相互作用网络（PPIs） 蛋白质-蛋白质相互作用网络通过实验或计算方法揭示蛋白质间的物理结合或功能协作关系，是研究细胞信号转导、复合体形成和疾病机制的重要工具。例如，癌症相关蛋白通常在PPI网络中呈现高度连接性，帮助识别关键调控节点和潜在药物靶点。\n2. 序列相似性网络（SSNs） 序列相似性网络基于基因或蛋白质序列的相似性构建，用于分析基因家族进化、功能分化和水平基因转移。通过设定相似性阈值，可聚类同源基因并预测新功能，广泛应用于酶家族分类（如P450超家族）和宏基因组数据分析。\n3. 基因调控网络（GRNs） 基因调控网络描述转录因子与靶基因间的调控关系，整合ChIP-seq、RNA-seq等数据以揭示发育、疾病或环境响应中的调控逻辑。例如，干细胞多能性网络中的核心转录因子（如OCT4、SOX2）通过GRN分析被确定为命运决定的关键因子。\n4. 代谢网络（Metabolic Networks） 代谢网络以生化反应为基础，节点代表代谢物，边表示酶催化的反应，用于模拟代谢通量并优化生物合成途径。在微生物工程中，此类网络指导设计高产菌株，如抗生素或生物燃料的微生物生产。\n5. 基因共表达网络（Gene Co-expression Networks） 基因共表达网络通过转录组数据（如RNA-seq）计算基因表达相关性，挖掘功能模块或生物标记物。例如，WGCNA算法可识别与特定性状相关的共表达模块，如植物抗逆性或肿瘤亚型特征基因群。\n6. 物种互作网络（Species Interaction Networks） 物种互作网络（如食物网、共生网络）量化生态系统中物种间的捕食、竞争或互利关系，评估生态稳定性和多样性。网络拓扑分析可预测物种灭绝的级联效应，助力保护生物学研究。\n当然还有其他很多很多重要的生物学研究中的网络了。\n常用工具 Cytoscape是最流行的生物网络可视化分析平台，支持多种网络类型和插件扩展。 Gephi是专注于大规模网络可视化的工具，提供多种布局算法和动态网络分析功能。 igraph是高效的网络分析库，支持R/Python等语言。 STRING是综合蛋白质相互作用数据库，提供实验验证和预测的相互作用数据。 BioGRID是全面的PPI数据库，包含超过100万条蛋白质相互作用记录。 GENIE3基于机器学习算法推断基因调控网络，适用于单细胞RNA-seq数据。 iRegulon整合ChIP-seq和motif数据预测转录调控网络。KEGG Mapper是基于KEGG数据库的代谢网络分析工具。 COBRA Toolbox是MATLAB平台的代谢网络建模工具，支持通量平衡分析。 WGCNA是加权基因共表达网络分析的标准工具。 EcoNet是专为生态网络设计的分析工具。 NetworkX是Python的通用复杂网络分析库。 NetworkAnalyst是在线网络分析平台，支持多种网络类型。 MetaNet MetaNet 是一个专注于生物组学（omics）数据的综合性网络分析 R 包。旨在帮助研究人员快速构建、分析和可视化多组学数据的复杂网络，支持高通量数据的处理（如超过 10,000 个节点的网络）。以下是其主要特点：\n多组学整合分析\n支持多种组学数据（如微生物组、转录组等）的联合网络分析，便于挖掘跨组学关联。\n高效计算\n• 快速计算相关性网络（如物种间互作），通过并行计算加速分析。\n• 优化大数据处理能力，适用于大规模网络。\n可视化与兼容性\n• 提供多种网络布局算法，支持交互式可视化。\n• 可导出至常用工具（如 Gephi、Cytoscape）或与 ggplot2 集成绘图。\n拓扑分析\n计算丰富的网络拓扑指标（包括生态网络稳定性），适用于复杂网络研究。\n安装 可以从 CRAN 安装稳定版：install.packages(\u0026quot;MetaNet\u0026quot;)\n最新的开发版本可以在 https://github.com/Asa12138/MetaNet 中找到：\n1 remotes::install_github(\u0026#34;Asa12138/MetaNet\u0026#34;, dependencies = T) 依赖包 pcutils和igraph（需提前安装），推荐配合 dplyr 进行数据操作。\n1 2 3 4 5 6 library(MetaNet) library(igraph) # ========data manipulation library(dplyr) library(pcutils) 快速使用 下图是 MetaNet 的整体开发框架，包括数据处理，网络构建，网络分析，网络可视化和其他功能，核心是一个继承igraph的metanet对象：\n下面以一个微生物共丰度网络为例（是我最早也是做得最多的分析）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 # 加载示例数据（otu表，来自pcutils包） data(\u0026#34;otutab\u0026#34;, package = \u0026#34;pcutils\u0026#34;) # 转置数据（微生物组分析通常需要行为样本，列为物种/OTU） t(otutab) -\u0026gt; totu # totu: 转置后的矩阵，行=样本，列=物种/OTU # 计算物种间相关性矩阵（使用Spearman秩相关） c_net_calculate( totu, method = \u0026#34;spearman\u0026#34; # 可选\u0026#34;pearson\u0026#34;/\u0026#34;spearman\u0026#34;/\u0026#34;kendall\u0026#34; ) -\u0026gt; corr # corr: 存储相关系数和p值的矩阵 # 构建共现网络（基于阈值筛选） c_net_build( corr, r_threshold = 0.65, # 保留|r| ≥ 0.65的边 p_threshold = 0.05, # 保留p \u0026lt; 0.05的边（统计显著性） delete_single = TRUE # 删除无连接的孤立节点 ) -\u0026gt; co_net # co_net: 生成的metanet网络对象 # 添加网络属性（注释节点信息） co_net \u0026lt;- c_net_set( co_net, taxonomy, # 数据框：物种分类信息（如Phylum列） data.frame(\u0026#34;Abundance\u0026#34; = colSums(totu)), # 节点属性：总丰度 vertex_class = \u0026#34;Phylum\u0026#34;, # 用Phylum分类作为节点颜色分组 vertex_size = \u0026#34;Abundance\u0026#34; # 用Abundance值调整节点大小 ) # 计算网络布局（可视化坐标） coors \u0026lt;- c_net_layout( co_net, method = nicely() # 使用默认美观布局 ) # 绘制网络图（默认显示节点、边和分类颜色） c_net_plot(co_net, coors = coors) 再来一个多组学网络构建：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 data(\u0026#34;multi_test\u0026#34;, package = \u0026#34;MetaNet\u0026#34;) # build a multi-network multi1 \u0026lt;- multi_net_build(list(Microbiome = micro, Metabolome = metab, Transcriptome = transc), r_threshold = 0.6, # 保留|r| ≥ 0.6的边 p_threshold = 0.05) # set vertex_class multi1_with_anno \u0026lt;- c_net_set(multi1, micro_g, metab_g, transc_g, vertex_class = c(\u0026#34;Phylum\u0026#34;, \u0026#34;kingdom\u0026#34;, \u0026#34;type\u0026#34;)) # set vertex_size multi1_with_anno \u0026lt;- c_net_set(multi1_with_anno, data.frame(\u0026#34;Abundance1\u0026#34; = colSums(micro)), data.frame(\u0026#34;Abundance2\u0026#34; = colSums(metab)), data.frame(\u0026#34;Abundance3\u0026#34; = colSums(transc)), vertex_size = paste0(\u0026#34;Abundance\u0026#34;, 1:3) ) plot(multi1_with_anno) 后续我会发推文具体介绍MetaNet分析流程的每个功能模块，大家也可以先直接看详细英文版教程：https://bookdown.org/Asa12138/metanet_book/，我也尽可能为每个函数编写了详细的help文件和examples，欢迎大家提出宝贵意见。\nReferences Koutrouli M, Karatzas E, Paez-Espino D and Pavlopoulos GA (2020) A Guide to Conquer the Biological Network Era Using Graph Theory. Front. Bioeng. Biotechnol. 8:34. doi: 10.3389/fbioe.2020.00034 Faust, K., and Raes, J. (2012). Microbial interactions: from networks to models. Nat. Rev. Microbiol. https://doi.org/10.1038/nrmicro2832. Deng, Y., Jiang, Y., Yang, Y., He, Z., Luo, F., and Zhou, J. (2012). Molecular ecological network analyses. BMC Bioinf. https://doi.org/10.1186/1471-2105-13-113. Girvan, M., and Newman, M.E.J. (2002). Community structure in social and biological networks. Proc. Natl. Acad. Sci. 99, 7821–7826. https://doi.org/10.1073/pnas.122653799. Shannon, P., Markiel, A., Ozier, O., Baliga, N.S., Wang, J.T., Ramage, D., Amin, N., Schwikowski, B., and Ideker, T. (2003). Cytoscape: a software environment for integrated models of biomolecular interaction networks. Genome Res. 13, 2498–2504. https://doi.org/10.1101/gr.1239303. ","date":"2025-03-27T00:00:00Z","image":"https://jb-cao.github.io/Cao-blog/p/metanet-1/images/bio_net_hu_1fd0e9eff4ff51d7.png","permalink":"https://jb-cao.github.io/Cao-blog/p/metanet-1/","title":"MetaNet：多组学网络分析工具｜1.基础介绍"},{"content":"Introduction 在生物信息学分析中，许多软件的中间文件或输出结果是数据库格式，例如 .db 文件。同时，很多生物数据库的存储和下载格式也是数据库格式。因此，掌握数据库的基本操作，不仅有助于数据存储，还能提高数据查询和处理的效率。\nSQLite 是一款轻量级的嵌入式关系型数据库管理系统，它不需要单独的服务器进程，而是直接将数据库存储在单个文件中。SQLite 具有以下特点：\n零配置：无需安装或管理，直接使用。 跨平台：支持 Windows、Linux、Mac 等主流操作系统。 高性能：对于单机应用场景，SQLite 处理速度比 MySQL 和 PostgreSQL 更快。 小体积：核心库只需几百 KB 内存，适用于资源受限的环境。 在数据分析领域，R 语言与 SQLite 结合可以带来以下优势：\n处理超出内存限制的大型数据集。 实现数据的持久化存储。 利用 SQL 进行高效查询和数据操作。 便于不同编程语言之间的数据共享。 本文将介绍 SQLite 的基础使用方法，并讲解如何在 R 语言中操作 SQLite 数据库。\nSQLite 基础使用 SQLite 不需要单独安装，可以直接从官网 https://sqlite.org/下载命令行工具，或者使用编程语言（如 Python、R）的 SQLite 接口。\nSQLite 提供了一系列实用的点命令(dot commands)来管理数据库，这些命令以点(.)开头，下面介绍几个常用的命令：\n.open 命令 .open 命令用于打开或创建数据库文件：\n语法：.open 数据库文件名.db 功能： 如果指定的数据库文件不存在，则会创建一个新的数据库文件 如果数据库已存在，则打开该数据库 示例：.open test.db 打开或创建test.db数据库 .databases 命令 .databases 命令用于显示当前连接的数据库信息：\n语法：.databases 功能： 显示所有附加的数据库 显示每个数据库的文件路径和名称 主数据库通常名为\u0026quot;main\u0026quot; 示例输出： 1 2 3 seq name file --- --------------- ---------------------------------------------------------- 0 main /path/to/your/database.db 其他相关命令 .exit 命令\n语法：.exit 功能：退出SQLite命令行界面 .quit 命令\n语法：.quit 功能：与.exit相同，退出SQLite命令行界面 .help 命令\n语法：.help 功能：显示所有可用的点命令及其简要说明 .tables 命令\n语法：.tables [模式] 功能：列出当前数据库中的所有表，可选使用模式匹配 .schema 命令\n语法：.schema [表名] 功能：显示表的创建语句(DDL)，不指定表名则显示所有表的创建语句 这些点命令为SQLite数据库的管理提供了便捷的操作方式，特别适合在命令行环境下使用。需要注意的是，这些命令不是标准SQL语句，而是SQLite特有的命令行工具命令。\n常用 SQL 语句 SQLite 几乎完全兼容常见的 SQL 语句规范，因此可以直接编写和执行标准的 SQL 语句。\n标准 SQL (Structured Query Language) 语句具有以下主要特点：\n结构化与声明式 非过程化语言：SQL 是声明式语言，用户只需指定\u0026quot;做什么\u0026quot;而非\u0026quot;如何做\u0026quot; 结构化语法：由清晰的关键字、子句和表达式组成 标准化 遵循 ANSI/ISO 标准：有 SQL-86、SQL-89、SQL-92、SQL:1999、SQL:2003、SQL:2008、SQL:2011、SQL:2016 等多个标准版本 跨平台兼容：基本语法在大多数关系型数据库中通用 分类明确 SQL 语句主要分为几大类： DDL (数据定义语言)\n用于定义数据库结构 主要语句：CREATE, ALTER, DROP, TRUNCATE, RENAME 示例：CREATE TABLE employees (id INT, name VARCHAR(50)); DML (数据操作语言)\n用于操作数据 主要语句：SELECT, INSERT, UPDATE, DELETE, MERGE 示例：UPDATE employees SET salary = 5000 WHERE id = 101; DCL (数据控制语言)\n用于权限控制 主要语句：GRANT, REVOKE, DENY 示例：GRANT SELECT ON employees TO user1; TCL (事务控制语言)\n用于事务管理 主要语句：COMMIT, ROLLBACK, SAVEPOINT, SET TRANSACTION 示例：COMMIT; 语法特点 不区分大小写：但通常关键字用大写，标识符用小写 使用分号结束：多数数据库要求语句以分号(;)结尾 可嵌套子查询：支持多层嵌套查询 支持注释：单行(\u0026ndash;)和多行(/* */)注释 功能特点 强大的查询能力：支持复杂条件、多表连接、聚合函数等 数据完整性保障：支持主键、外键、约束等机制 事务支持：ACID特性(原子性、一致性、隔离性、持久性) 视图支持：可以创建虚拟表简化复杂查询 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 -- 创建表 CREATE TABLE users ( id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL, age INTEGER, email TEXT UNIQUE, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ); -- 插入数据 INSERT INTO users (name, age, email) VALUES (\u0026#39;张三\u0026#39;, 25, \u0026#39;zhangsan@example.com\u0026#39;); INSERT INTO users (name, age, email) VALUES (\u0026#39;李四\u0026#39;, 30, \u0026#39;lisi@example.com\u0026#39;); -- 查询数据 SELECT * FROM users WHERE age \u0026gt; 20; SELECT name, age FROM users ORDER BY age DESC LIMIT 5; SELECT COUNT(*) FROM users; -- 更新数据 UPDATE users SET age = 26 WHERE name = \u0026#39;张三\u0026#39;; -- 删除数据 DELETE FROM users WHERE id = 1; SQLite 高级查询 1 2 3 4 5 6 7 8 9 10 11 12 13 14 -- 聚合查询 SELECT age, COUNT(*) FROM users GROUP BY age; -- 多表连接查询 CREATE TABLE orders ( id INTEGER PRIMARY KEY AUTOINCREMENT, user_id INTEGER, amount REAL, FOREIGN KEY(user_id) REFERENCES users(id) ); SELECT users.name, orders.amount FROM users JOIN orders ON users.id = orders.user_id; SQLite 导出表格 使用 SQLite 命令行工具导出 导出为 CSV 格式\n1 2 3 4 5 6 sqlite3 your_database.db .headers on .mode csv .output data.csv SELECT * FROM your_table; .output stdout 导出为 SQL 格式（包含表结构和数据） 1 sqlite3 your_database.db .dump your_table \u0026gt; output.sql 数据库管理工具 如果不习惯使用 SQL 语句操作数据库，可以使用可视化工具，如 DB Browser for SQLite 或 SQLite Expert，这些工具可以方便地：\n创建/删除数据库。 设计表结构。 执行 SQL 查询。 导入/导出数据。 在 R 中操作 SQLite 在 R 语言中操作 SQLite 可以安装 RSQLite 和 sqldf 包：\n1 2 3 4 install.packages(\u0026#34;RSQLite\u0026#34;) library(RSQLite) install.packages(\u0026#34;sqldf\u0026#34;) library(sqldf) RSQLite：提供 R 与 SQLite 之间的接口。 sqldf：允许使用 SQL 查询 R 中的数据框。 连接 SQLite 数据库 1 2 3 4 5 6 7 8 # 创建/连接数据库 con \u0026lt;- dbConnect(SQLite(), \u0026#34;example.sqlite\u0026#34;) # 查看数据库中的表 dbListTables(con) # 读取数据库中的表 dbReadTable(con, \u0026#34;table_name\u0026#34;) 写入数据 1 2 3 4 5 6 7 8 9 # 创建数据框 df \u0026lt;- data.frame( id = 1:3, name = c(\u0026#34;Alice\u0026#34;, \u0026#34;Bob\u0026#34;, \u0026#34;Charlie\u0026#34;), score = c(85, 92, 78) ) # 写入数据库 dbWriteTable(con, \u0026#34;students\u0026#34;, df, overwrite = TRUE) 查询数据 1 2 3 4 5 6 7 # 查询数据库内容 result \u0026lt;- dbGetQuery(con, \u0026#34;SELECT * FROM students WHERE score \u0026gt; 80\u0026#34;) print(result) # 使用参数化查询防止 SQL 注入 query \u0026lt;- \u0026#34;SELECT * FROM students WHERE name = ?\u0026#34; result \u0026lt;- dbGetQuery(con, query, params = list(\u0026#34;Alice\u0026#34;)) sqldf 直接查询 sqldf 允许直接使用 SQL 语句查询 R 数据框，而无需创建 SQLite 数据库。\n1 2 3 4 5 6 7 8 9 10 11 12 library(sqldf) # 创建数据框 df \u0026lt;- data.frame( name = c(\u0026#34;Alice\u0026#34;, \u0026#34;Bob\u0026#34;, \u0026#34;Charlie\u0026#34;), age = c(25, 30, 28), score = c(85, 92, 78) ) # 直接使用 SQL 进行查询 result \u0026lt;- sqldf(\u0026#34;SELECT name, score FROM df WHERE age \u0026gt; 26\u0026#34;) print(result) 关闭数据库连接 操作完成后，务必关闭数据库连接以释放资源：\n1 dbDisconnect(con) SQLite 作为轻量级数据库，在数据存储和查询方面具有极高的灵活性。结合 R 语言的分析能力，可以实现高效的数据处理和自动化工作流。此外，sqldf 提供了一种在 R 语言环境下直接使用 SQL 查询数据框的方式，使得数据分析更加直观高效。\nReferences https://cloud.tencent.com/developer/article/1938211 https://blog.51cto.com/u_16099343/13578231 https://blog.csdn.net/m0_73500130/article/details/142286358 https://www.5axxw.com/questions/simple/2jy747 ","date":"2025-03-26T00:00:00Z","image":"https://jb-cao.github.io/Cao-blog/p/sqlite-r/images/R-C_hu_154d127bd26f14a5.png","permalink":"https://jb-cao.github.io/Cao-blog/p/sqlite-r/","title":"SQLite使用基础以及在R中操作数据库"},{"content":"Introduction 陆生植物将大部分光合作用固定的碳转化为木质纤维素（lignocellulose），这是一种由纤维素（cellulose）、半纤维素（hemicellulose）、果胶（pectin）和木质素（lignin）等聚合物组成的复合物。在植物生命周期中，这种复杂的基质为其提供结构完整性，并抵御植食性动物和病原体的侵害，因此大部分木质纤维素生物质由腐生生物和碎屑食性生物在碎屑食物网中分解。木质纤维素可作为生物燃料生产的原料，但由于纤维素的准结晶性、半纤维素对纤维素微纤维的复杂包覆以及木质素对多糖组分的穿插和包裹，其难以被酶解处理。在工业过程中，通常通过剧烈的化学和物理预处理来克服这种抗降解性，而生物体则能在生理耐受条件下实现木质纤维素的分解。\n降解机制的多样性 生物体通过多种方式降解木质纤维素，包括氧化攻击、半纤维素酶的作用以及动物的机械破坏，这些方式降低了木质纤维素的抗降解性，从而为解聚酶提供了更好的作用条件。碳水化合物活性酶及其底物结合蛋白的信息被整合在CAZy数据库中。近年来，肽模式识别技术被用于基于功能预测将糖苷水解酶（GH）和辅助活性酶（AA）家族分类为亚家族，并为挖掘基因组数据中的新酶提供工具。本文重点关注CAZy分类中的糖苷水解酶（GHs）和辅助活性酶（AAs），后者作为氧化还原酶，常与GHs协同作用。\n纤维素和半纤维素的酶解 在自然界中，纤维素和半纤维素的降解通过多种碳水化合物活性酶的协同作用实现。糖苷水解酶（GHs）是主要酶类，负责切断纤维素和半纤维素中的糖苷键。多糖酯酶通过去除甲基、乙酰基和酚酯基团辅助GHs发挥作用。在某些情况下，多糖裂解酶也参与解聚过程。不同生物类群中，GH酶的组合因物种、进化压力和环境生态位的不同而存在显著差异。例如，丝状真菌主要产生GH7家族酶，而原核生物则依赖GH48家族酶。尽管GH7家族酶曾被认为仅存在于真菌中，但最新研究表明它们也存在于其他真核生物中。尽管该家族酶在序列和结构上具有高度相似性，但其表面性质可能存在显著差异。其他GH家族则表现出更大的序列和功能多样性。\n多糖的氧化解聚 近年来，一种新的氧化酶学机制被发现，用于切断多糖链，这类酶被称为裂解多糖单加氧酶（LPMOs）。其中一些最初被归类为GH61家族纤维素酶，另一些则属于碳水化合物结合模块家族33。目前，降解纤维素的LPMOs被归入AA9家族（主要为真菌酶）和AA10家族（主要为细菌酶）。LPMOs不仅能作用于结晶纤维素，还能降解半纤维素。它们通过平坦活性位点中的铜原子直接氧化攻击聚合物链。此外，非酶解机制如褐腐真菌中的铁依赖芬顿化学反应也能降解纤维素。\n木质素的解聚 木质素是一种异质性烷基芳香族聚合物，由三种甲氧基化程度不同的芳香醇组成。自然界中存在多种木质素修饰策略，但能降解木质素的生物远少于降解纤维素的生物。白腐担子菌和一些木质素降解细菌通过分泌过氧化物酶和漆酶等氧化酶降解木质素，生成一系列异质性芳香族化合物，最终被分泌生物或其他微生物代谢。褐腐真菌虽缺乏木质素降解酶，但利用小分子活性物质解聚木质素，切断丙基侧链并脱甲氧基，随后在其他部位重新聚合，以释放纤维素组分并促进降解。修饰后的木质素不被褐腐真菌代谢，而是残留在土壤中。\n木质纤维素降解生物的多样性 纤维素由多种海洋生物合成，其降解机制可能起源古老。木质素降解的演化则与二叠纪末期有机碳埋藏量的下降同步。陆生植物出现时，生命之树的主要分支已分化，因此木质纤维素降解能力具有多源性，并在生命之树的多个小分支中持续演化。例如，昆虫-原生生物共生关系（促进木质纤维素消化）在侏罗纪晚期出现，而依赖细菌共生的木材消化能力则是双壳类家族Teredinidae和Xylophagainae最后共同祖先的特征。在自然界中，具有互补酶的生物共生体和群落广泛参与生物质的降解。降解过程在多种（有时极端的）环境条件下进行，涉及pH、氧化还原电位、温度和压力的广泛范围，这反映了参与生物的多样性。\n原核生物 近年来，强大的宏组学技术使得从富含木质纤维素的环境（如堆肥）中挖掘原核生物群落的遗传多样性成为可能，从而发现可能在工业条件下表现优异的新型木质纤维素降解酶。通过比较宏转录组分析，研究人员已识别出在高负荷条件下能够降解稻草的堆肥微生物群落中高表达的基因。利用宏基因组学和宏蛋白质学对复杂群落中木质纤维素降解微生物的研究，揭示了群落成员的结构、功能及其在营养供应等环境条件变化下的遗传和功能响应。\n宏组学还为肠道微生物群落的复杂相互关系提供了新见解。白蚁是消化共生的典型例子。在低等白蚁中，细菌和古菌生活在肠道内吞噬木质颗粒的鞭毛虫的细胞质和表面，也存在于粘稠的肠道液体中。拟杆菌门、厚壁菌门、螺旋体门、变形菌门和Elusibacteria是该微生物群的主要成员，参与将生物质转化为甲烷、氢气和乙酸的代谢途径。在低等白蚁Reticulitermes中，通过16S rRNA探针检测到超过4700种细菌系统型。高等白蚁的后肠仅含有原核生物，这些微生物促进经白蚁酶预处理的木质颗粒的分解。后肠液体的纤维素酶活性较低，但与木质颗粒相关的细菌表现出强纤维素酶活性。\n一些土壤细菌被证实能够氧化木质素，主要属于放线菌门、α-变形菌门或γ-变形菌门，其中一些也存在于白蚁肠道和钻木昆虫中。近年来，原核生物中木质素降解酶的研究取得进展，染料脱色过氧化物酶家族的酶在革兰氏阳性放线菌Rhodococcus jostii RHA1、Amycolatopsis sp. 75iv2和革兰氏阴性γ-变形菌Pseudomonas fluorescens Pf-5中显示出对Mn(II)和β-芳基醚木质素模型化合物的氧化活性。细菌漆酶在链霉菌A3(2)中被证明是酸沉淀木质素生成所必需的。此外，Sphingobium SYK-6中的谷胱甘肽依赖性β-醚酶已被表征，但其在木质纤维素降解中的作用仍需进一步研究。\n古菌也存在于堆肥和白蚁肠道中，但其木质纤维素降解机制研究较少。一些古菌能在高温下降解木质纤维素，例如在Pyrococcus中发现的GH12内切葡聚糖酶。古菌中已鉴定出五个可能氧化木质素的漆酶基因，其中三个属于盐杆菌目，一个属于热变形菌目。\n海洋中的自由生活木质降解原核生物分为隧道细菌和侵蚀细菌，其植物细胞壁降解模式不同。隧道细菌为革兰氏阴性杆菌，侵蚀细菌属于黄杆菌-噬纤维菌群。由于两者均未在纯培养中生长，其独立作用机制尚不清楚，但其降解速率较真菌缓慢，主要降解纤维素和半纤维素，而对木质素的改变较小。深水中的木材会招募特定的耐压细菌群落，这些群落与以木材为食的钻孔动物粪便中的细菌明显不同。\n单细胞真核生物和原生生物 一些自由生活的原生生物被发现具有内源性纤维素酶。黏菌Dictyostelium的基因组编码一种推测的GH7纤维二糖水解酶，而绿藻Chlamydomonas则利用内切葡聚糖酶降解胞外纤维素。甲藻Alexandrium产生一种与白蚁共生菌相似的纤维素酶，但其功能可能更倾向于辅助细胞分裂而非消化。然而，致病性卵菌Phytophthora则分泌一系列针对半纤维素和纤维素的细胞壁降解酶，包括GH家族1、5、6、7、10以及AA9和AA10的成员。低等白蚁的肠道中寄宿多达19种鞭毛虫类原生生物，这些原生生物吞噬木质颗粒，并在其消化液泡中含有多种酶，如内切葡聚糖酶、GH7纤维二糖水解酶、β-葡萄糖苷酶、木聚糖酶、甘露糖苷酶和阿拉伯糖苷酶。\n真菌 生物质降解真菌依赖复杂的降解机制，主要包括两类过程：一是直接酶解（如纤维二糖水解酶的作用），二是生成氧化性物质（如自由基）作用于生物质。随着对担子菌门基因组研究的新进展，传统上分类为白腐菌或褐腐菌的真菌可能不再完全符合这些类别，因为其代谢物表达和降解模式存在渐变。然而，在典型的白腐菌降解中，真菌主要采用酶解攻击模式。由于降解酶体积过大，无法穿透完整的细胞壁，白腐菌仅从木质纤维素表面开始攻击。白腐菌使用的酶包括完整的纤维素酶，以及能够氧化木质素成分的酶，如木质素酶、锰过氧化物酶、多功能过氧化物酶或漆酶，或这些酶的组合。一些白腐菌还被发现具有大量LPMO基因。\n褐腐菌从白腐菌的祖先中多次独立演化而来，在这些进化过程中，木质素降解酶系统和关键纤维素酶逐渐丢失。至少三个褐腐菌目（Gloeophyllales、Polyporales和Boletales）演化出螯合剂介导的芬顿（CMF）系统，替代了大部分纤维素酶机制，从而提供了一种高效的生物质解聚和生物修饰途径。CMF系统是生物系统中唯一基于氧自由基化学的底物降解机制，能够在距离生物体数微米的位置进行非酶解降解。CMF系统的高效性被认为使褐腐菌在生态位竞争中占据优势，例如在针叶木材降解中取代了白腐菌。\n一些子囊菌也能降解木材细胞壁，形成沿S2基本纤维方向排列的菱形腔链，导致软腐。软腐真菌已知能产生完整的纤维素酶，但其木质素降解能力存在争议，据报道其分泌的未指定胞外过氧化物酶和氧化酶功能较白腐菌更为有限。\n动物 许多无脊椎动物表达内源性纤维素酶。植物寄生线虫、蟑螂和白蚁是最早被证实携带纤维素酶基因的动物，但近年来，这些基因（主要属于GH5、9和45家族）也在其他类群中被明确发现，如其他昆虫、腹足类、甲壳类和环节动物。由于许多昆虫或甲壳类缺乏类似反刍动物和白蚁的大型消化肠道腔室来培养肠道共生微生物，因此这些草食性和碎屑食性动物需要依赖内源性纤维素酶。它们通过口器或外壳对底物进行机械破碎，部分克服了木质纤维素的抗降解性。\n钻木双壳类（如船蛆）通过外壳的研磨作用摄入木质颗粒。它们缺乏显著的肠道微生物群，而是在鳃的特化细胞内寄宿γ-变形菌内共生体。在船蛆Bankia setacea中，这些细菌产生的木质纤维素降解酶被选择性运输到肠道，包括GH家族5、6、9、10、11、45和53以及碳水化合物酯酶家族1、3、4、6和15的代表，以及AA10家族的LPMOs。这种细菌与消化部位的分离可能使宿主能够捕获释放的糖类，而无需与肠道微生物群竞争。内共生细菌还被证明能够在体内固氮，从而补充木材中有限的有机氮源。船蛆的深海近缘类群Xylophagainae具有类似的共生和降解机制，但能够在极端压力下运作。在摄食陆地植物碎屑的双壳类Corbicula的消化腺和晶杆中，也检测到内源性GH9、10和45酶，但其晶杆在高度木质化底物降解中的作用尚待阐明。\n在白蚁中，内源性纤维素酶（由唾液腺和中肠产生）与后肠中鞭毛虫和细菌产生的微生物酶协同作用，后者还通过氧化降解木质素基质部分接触纤维素纤维。其他无脊椎动物中内源性酚氧化酶样酶在木质素降解中的作用尚不明确，但近期研究表明活化血蓝蛋白可能参与酚氧化。甲壳类中被证实具有内源性半纤维素酶（如昆布多糖酶），而在白蚁中，半纤维素酶（如木聚糖酶、半乳聚糖酶）主要来自细菌，尽管甘露聚糖酶活性被归因于白蚁的共生原生生物。\n大多数白蚁依赖肠道微生物群，有时这些微生物甚至存在于鞭毛虫的细胞或细胞核内。而大白蚁亚科则在其巢穴中培养担子菌Termitomyces，该真菌产生多种能够水解复杂多糖的GHs。白蚁工蚁携带能够消化真菌释放的寡糖的细菌。\n食木甲壳类Chelura（端足类）和Limnoria（等足类）产生属于多个CAZy家族的内源性酶，其中GH5、7和9成员在消化腺转录组中最为显著。它们是已知唯一产生GH7酶的后生动物，其消化道缺乏常驻微生物，因此不具备白蚁中复杂的肠道化学结构。这些动物具有类似酶反应器的肠道，为研究酶功能提供了一个不受微生物相互作用干扰的理想模型。\n木质纤维素消化在脊椎动物中是一种罕见的饮食策略，但少数陆生（如河狸、熊猫和豪猪）和水生脊椎动物在其正常饮食中摄入大量木质纤维素。除熊猫外，尚不清楚这是否为专性食木性，而熊猫对其饮食的适应性出人意料地差。目前正在研究促进脊椎动物木质纤维素消化的微生物组。新热带淡水生态系统中的鲶鱼科鱼类（如Panaque spp.）是食木性动物。通过16S rRNA基因分析发现，P. nigrolineatus的胃肠道拥有一个包含纤维素降解和固氮微生物近缘种的微生物群落。该群落中的纤维素降解细菌已被表征，并发现其与固氮菌在脊椎动物胃肠道内共生。\nCAZy数据库 官网: CAZy\nCAZy（Carbohydrate-Active Enzymes，碳水化合物活性酶）数据库是一个专门收录与碳水化合物降解、修饰和合成相关酶的综合性数据库。它基于酶的功能和结构特征，将碳水化合物活性酶分为多个家族，包括糖苷水解酶（Glycoside Hydrolases, GHs）、糖基转移酶（Glycosyl Transferases, GTs）、多糖裂解酶（Polysaccharide Lyases, PLs）、碳水化合物酯酶（Carbohydrate Esterases, CEs）以及辅助活性酶（Auxiliary Activities, AAs）。这些酶在木质纤维素降解、生物质转化以及工业生物技术中具有重要作用。\nCAZy数据库通过系统化的分类和注释，为研究人员提供了丰富的基因和酶功能信息。例如，糖苷水解酶（GHs）家族包含多种能够切断纤维素和半纤维素中糖苷键的酶，而辅助活性酶（AAs）家族则包括氧化还原酶，常与GHs协同作用以增强降解效率。CAZy数据库不仅收录了已知酶的序列和结构信息，还提供了基于基因组和宏基因组数据的预测工具，帮助研究人员识别新型碳水化合物活性酶。\n在木质纤维素降解研究中，CAZy数据库被广泛应用于基因功能注释和酶家族分类。通过结合宏基因组学、宏转录组学和宏蛋白质组学数据，研究人员可以挖掘环境中微生物群落的遗传潜力，识别具有工业应用价值的新型酶。例如，利用CAZy数据库，科学家能够快速筛选出参与纤维素、半纤维素和木质素降解的关键酶基因，并进一步研究其功能和应用潜力。\ndbCAN 官网: dbCAN\ndbCAN（Database for automated Carbohydrate-active enzyme ANnotation）是一个专门用于自动化注释碳水化合物活性酶（CAZymes）的数据库和工具集。它基于CAZy数据库的分类框架，结合了多种计算方法，能够快速、准确地从基因组、宏基因组或蛋白质组数据中识别和注释CAZymes。dbCAN的目标是为研究人员提供一个高效的工具，帮助他们挖掘和分析与碳水化合物代谢相关的基因和酶。\n主要特点与功能 基于CAZy分类框架\ndbCAN延续了CAZy数据库的分类体系，将碳水化合物活性酶分为六大类：糖苷水解酶（GHs）、糖基转移酶（GTs）、多糖裂解酶（PLs）、碳水化合物酯酶（CEs）、辅助活性酶（AAs）以及碳水化合物结合模块（CBMs）。这种分类方式便于研究人员快速理解酶的功能和分类。\n自动化注释工具\ndbCAN提供了一套自动化注释工具，包括：\nHMMER：基于隐马尔可夫模型（HMM）的搜索工具，用于识别CAZymes家族。 DIAMOND：一种快速的序列比对工具，用于初步筛选CAZymes。 Hotpep：基于短肽模式的搜索工具，用于补充HMMER和DIAMOND的结果。\n这些工具可以单独或联合使用，以提高注释的准确性和全面性。 用户友好的在线平台\ndbCAN提供了一个在线平台，用户可以通过上传基因组或蛋白质序列文件，快速获得CAZymes的注释结果。平台支持多种输入格式，并生成详细的注释报告，包括酶家族分类、功能预测和序列比对信息。\n数据库更新与扩展\ndbCAN定期更新，与CAZy数据库保持同步，确保注释结果的准确性和时效性。此外，dbCAN还整合了其他相关数据库的信息，如UniProt和PDB，为用户提供更全面的酶功能信息。\n基因组与宏基因组分析：dbCAN广泛应用于基因组和宏基因组数据中CAZymes的挖掘，帮助研究人员识别与碳水化合物降解、修饰和合成相关的基因。 功能驱动研究：通过dbCAN注释，研究人员可以快速筛选出特定功能的酶家族，进一步研究其催化机制和底物特异性。 References Dashora, K. et al. Leveraging multiomics approaches for producing lignocellulose degrading enzymes. Cell. Mol. Life Sci. 79, 132 (2022). Andlar, M. et al. Lignocellulose degradation: an overview of fungi and fungal enzymes involved in lignocellulose degradation. Eng. Life Sci. 18, 768–778 (2018). Cragg, S. M. et al. Lignocellulose degradation mechanisms across the tree of life. Curr. Opin. Chem. Biol. 29, 108–119 (2015). ","date":"2025-03-13T00:00:00Z","image":"https://jb-cao.github.io/Cao-blog/p/lignocellulose/images/fig2_hu_9db5353ebce4bcba.png","permalink":"https://jb-cao.github.io/Cao-blog/p/lignocellulose/","title":"功能基因探索：木质纤维素（lignocellulose）降解"},{"content":"Introduction 在进化过程中，细菌发展出多种机制以应对不同的环境压力，如酸性、温度和抗生素等。其中，酸性环境是细菌最常面临的极端条件之一。耐酸细菌是一类能够在pH 2.0至5.0（也有说6.0的）的强酸性环境中生存的极端微生物（另外还有生长的最适pH在4以下的微生物叫嗜酸微生物，它们不仅耐酸，还依赖酸性环境生长）。这些酸性环境可能由自然过程（如酸性矿山排水、海洋火山喷口和酸性硫泉）或人类活动（如工业废水排放）形成。工业废水中含有大量有机物、悬浮固体和氨氮，其低pH值为耐酸细菌的生存提供了条件。\n耐酸细菌通过多种机制适应酸性环境，包括生理适应、代谢响应和质子消耗机制。在生理适应方面，细菌通过改变细胞膜组成和流动性来减少质子的内流。例如，降低不饱和脂质的浓度，并通过环丙烷脂肪酸磷脂合成酶修饰磷脂尾结构。此外，外膜蛋白（OMPs）可通过多磷酸盐或尸胺被阻断，而HdeA和HdeB等伴侣蛋白则能在酸性压力下释放底物蛋白。在大肠杆菌中，Hsp31伴侣蛋白和DNA结合蛋白Dps也在酸性压力下保护DNA的完整性。\n在代谢响应方面，细菌通过质子外排和质子消耗机制应对酸性压力。例如，大肠杆菌K-12在轻度酸性压力下通过氧化电子传递链介导质子外排。此外，细胞膜在细菌适应极端环境中起关键作用，溶质通过ATP驱动的初级运输或质子动力驱动的次级运输系统跨膜运输。某些耐酸细菌（如大肠杆菌和丙酸杆菌）甚至能在pH 2.5的极端条件下存活数小时，主要通过进入稳定期并激活多种耐酸机制来实现。\n耐酸细菌的机制在工业生物过程、有机酸生产、微生物燃料电池和工业废水生物处理中具有广泛应用。工业废水中含有大量有机物和有毒重金属，直接排放会对环境和人类健康造成严重危害。传统的化学处理方法（如混凝、沉淀和氧化）存在污泥产生、副产物生成和化学品消耗高等问题，而生物修复则是一种更环保的替代方案。耐酸细菌通过生物吸附、生物积累、生物降解和生物沉淀等机制修复酸性矿山排水或污染污泥中的重金属和石油烃化合物（如邻二甲苯、苯和甲苯）。\n非典型环境 耐酸细菌是一类能够在pH 5.0及以下的极端酸性环境中繁衍生息的极端微生物。这些酸性环境可能由自然过程（如酸性矿山排水、海洋火山喷口和酸性硫泉）或人类活动（如工业革命后的工业废水排放）形成。\n耐酸细菌的非典型环境与生态系统 耐酸细菌主要存在于硫或黄铁矿氧化形成的pH低于5.0的酸性环境中。硫和亚铁在耐酸细菌的作用下分别被氧化为硫酸和三价铁。酸性黄铁矿区域常见于煤矿和硫矿周围，这些区域通常具有较高的硫化物浓度。由于重金属含量高而有机质含量低，这些区域的pH可低至1.0。参与硫酸盐氧化反应的极端耐酸细菌包括Sulfobacillus thermosulfidooxidans、Thiobacillus acidophilus和Thiobacillus thiooxidans等。此外，海底火山区域和热液喷口释放的大量还原硫也为耐酸细菌提供了适宜的生存环境。在金属氧化物中，锌和铜的硫化物最为丰富，而耐酸细菌如Acidithiobacillus、Ferrimicrobium、Sulfobacillus、Acidimicrobium和Leptospirillum等能够氧化铁和硫化物矿物。\n工业废水、农业用地和市政排放的污染物通常含有高浓度的有机物和无机物（如重金属、异生物质、微塑料以及硝酸盐、磷酸盐和总氮），这些污染物导致废水pH降低，从而形成极端酸性环境。Acidophilus、Brevibacterium、Leptospirillum、Stenotrophomonas和Thermogymnomonas等极端耐酸细菌能够在低pH废水中生存。研究表明，酸性矿山排水、海洋火山喷口、酸性硫泉和工业废水是耐酸细菌的主要栖息地。\n耐酸细菌在微生物生态中的作用 由于酸性环境中溶解有机碳浓度较低，耐酸细菌通常被认为是寡营养型生物。在深矿等无阳光环境中，化能自养型耐酸细菌通过氧化硫化物和铁矿物生存。例如，Leptospirillum ferrooxidans在铁循环中起关键作用，它是一种专性化能自养菌，能够好氧氧化铁。在酸性矿山中，Ferroplasma、Leptospirillum和Acidithiobacillus等属的细菌广泛存在，其基因组测序显示存在编码固氮酶的基因。\n废水中的重金属是导致低pH的主要原因，而耐酸细菌通过产生脲酶中和酸性环境。脲酶通过生成氨（NH₃）与细胞内质子结合，从而降低细胞内pH。工业废水中的氨去除包括硝化和反硝化两个步骤：化能自养细菌将氨转化为亚硝酸盐（NO₂⁻）和硝酸盐（NO₃⁻），随后硝酸盐通过反硝化过程转化为氮气（N₂）。耐酸细菌的氮源主要包括氨、亚硝酸盐、硝酸盐和其他溶解有机氮化合物。硝酸盐还原为氨的过程涉及两个独立的酶促反应：NADH₂-硝酸还原酶催化NO₃⁻还原为NO₂⁻，铁氧还蛋白-亚硝酸还原酶催化NO₂⁻还原为NH₃，这一过程需要大量能量。\n耐酸的细胞机制 耐酸细菌在稳定期能够在低pH环境中存活数小时。为了适应极端酸性环境，多种细菌进化出了不同的细胞机制。当细菌暴露于酸性环境时，外膜和周质空间首先受到损害，因为外膜直接接触外部环境。在压力响应下，膜生物能量学、质子渗透和脂质生理学发生改变，从而降低膜的流动性和质子的通透性。细菌的耐酸细胞机制包括细胞膜修饰、F₁F₀-ATPase质子泵、生物膜形成、碱生成（脲酶活性）以及大分子的保护和修复。\n细胞膜修饰 外膜结构的改变主要发生在脂肪酸链或头基组成上。通过多磷酸盐或尸胺阻断外膜蛋白（OMPs），可以进一步减少质子的内流。例如，多磷酸盐阴离子（polyP）阻断PhoE3孔蛋白，而尸胺阻断OmpC3和OmpF3孔蛋白。在Picrophilus oshimae中，刚性单层膜和庞大的异戊二烯核心使其对质子不渗透。耐酸细菌通过改变脂肪酸的组成或结构来调节膜流动性。例如，环丙烷脂肪酸磷脂合成酶（CFAS）降低不饱和脂质的浓度，并对不饱和磷脂尾进行甲基化。\n为维持pH稳态，耐酸细菌利用反向膜电位。在Acidithiobacillus thioxidans和Acidithiobacillus ferrooxidans中，丰富的次级转运蛋白（如H⁺-ATPase、同向转运蛋白和反向转运蛋白）帮助维持pH稳态。Picophilus torridus和Thermoplasma acidophilum则通过利用跨膜质子电化学梯度进行主动运输来调节酸性环境。膜通道的大小和通透性也是维持pH稳态的重要机制。例如，在Acidithiobacillus ferrooxidans中，当pH从3.5降至1.5时，外膜蛋白Omp40上调，其外部L3环调节孔蛋白入口的大小和离子选择性。\n有机酸（如乙酸和乳酸）对耐酸细菌有害，因为这些质子化酸能够轻易通过细胞膜。Picophilus torridus的基因组揭示了编码有机酸降解途径的基因，包括丙酰-CoA合成酶、两种乙酰-CoA合成酶和乳酸-2-单加氧酶，这些酶将乳酸转化为丙酮酸。\n伴侣蛋白与DNA保护 HdeA和HdeB是两种周质伴侣蛋白，能够耐受酸性压力。HdeA的主要功能是防止酸诱导的蛋白质积累，并帮助蛋白质溶解和复性。HdeB具有类似功能。在大肠杆菌中，热休克伴侣蛋白Hsp31在酸性压力下结合并稳定未折叠的蛋白质中间体，随后允许蛋白质自发复性或依赖ATP的伴侣蛋白辅助复性。在酸性环境中，DNA结合蛋白Dps保护DNA免受损害。\nF₁F₀-ATPase质子泵 质子动力势（PMF）是细胞内质子梯度的体现，由细胞质与外部环境之间的电荷分离产生。依赖PMF的质子泵是细菌耐酸系统的重要组成部分，在维持pH稳态中起关键作用。在酸性环境中，H⁺的积累降低细胞内pH，随后质子泵开始消耗ATP。通过F₁F₀-ATPase进入细胞的质子在末端氧化酶处还原分子氧，导致代谢活动暂停。例如，Sulfolobus acidocaldarius通过F₁F₀-ATPase将质子排出细胞，从而在酸性环境中生存。在多种耐酸细菌（如Streptococcus pneumoniae和Lactobacillus acidophilus）中，F₁F₀操纵子因酸性pH的刺激而被转录。Streptococcus mutans则通过上调F₁F₀-ATPase应对酸性压力。因此，耐酸细菌通过F₁F₀-ATPase质子泵催化ATP水解，排出过量H⁺，从而耐受外部酸性环境并维持pH稳态。\n生物膜形成 许多细菌通过形成生物膜（biofilm）以社区形式附着在表面，从而抵御酸性压力。生物膜形成是一种独特的耐酸机制，涉及细胞群体间的信号交流。在某些细菌中，生物膜对酸性环境具有强耐受性，而其浮游细胞则对酸性敏感。生物膜之所以能够耐受酸性压力，是因为某些蛋白质仅在生物膜形成时表达。例如，在Pseudomonas aeruginosa中，vfr和gacA基因调控luxR同源基因lasR，后者激活lasI表达，生成3-oxo-C12-HSL，与受体蛋白LasR结合形成复合物，从而调控生物膜形成。负调控因子rsaL则抑制lasR表达。这种LasR蛋白-AHL复合物正向驱动与生物膜形成、致病性和次级代谢相关的多个结构基因的表达。\n在Streptococcus mutans中，luxS合成并分泌AL2，同时抑制irvA的转录。然而，当细胞遭遇酸性压力时，irvA基因的表达显著增加，进而抑制mutA和mutR的转录。Streptococcus mutans的群体感应系统通过调控生物膜形成实现耐酸性。ABC转运蛋白编码基因comAB的产物切割comC基因的产物，生成群体感应肽（CSP）。当CSP达到临界浓度时，传感器激酶ComD（由comD编码）磷酸化comE，启动替代σ因子comX的转录。在Streptococcus pneumoniae中，磷酸化的comE激活两个特异性操纵子comAB和comCDE，以及comX基因，后者诱导遗传竞争性和其他依赖细胞密度的表型。\n碱生成——脲酶活性 耐酸细菌通过胞外代谢产生碱性化合物来中和酸性环境。脲酶将尿素水解为氨和二氧化碳（CO₂）。脲酶通过生成氨与细胞内的质子结合，从而降低细胞内pH，起到中和酸性的作用。脲酶系统由ureIABCEFGD操纵子组成，耐酸细菌通过调控这一系统在pH低至2.5的环境中存活。例如，在Helicobacter pylori和Streptococcus salivarius中，ureI基因帮助将尿素从外部转运至细胞质。因此，脲酶通过生成碱性产物氨，保护细胞免受酸性环境的损害。Streptococcus sanguis和Streptococcus suis也依赖脲酶活性抵御酸性压力。此外，苹果酸乳酸发酵是Streptococcus mutans和Oenococcus oeni产生碱的另一种方式，其在细胞质内通过碱生成过程应对酸性压力，同时生成并排出CO₂。因此，碱生成机制是耐酸细菌在酸性环境中生存的有效策略。\n大分子的保护与修复 在酸性压力条件下，膜蛋白的稳定性至关重要。特定蛋白质在酸性环境中被诱导，以保护DNA和其他蛋白质。例如，dps蛋白通过形成笼状结构结合铁并减少过氧化氢的毒性来保护DNA，而recA则在DNA修复和激活SOS响应中起关键作用。Oenococcus oeni的热休克蛋白Lo18通过减少蛋白质聚集来增强细菌的耐酸性，从而稳定膜结构并保护蛋白质。Ffh蛋白参与膜内蛋白质转运途径，并帮助蛋白质向细胞外运输。此外，多种伴侣蛋白（如DnaK、DnaJ、GroEL、GroES、GrpE、Clp蛋白酶和EF-Tu）在酸性压力下作为分子伴侣参与蛋白质修复。\nDNA损伤的修复则依赖于uvrABCD、DNA聚合酶和DNA连接酶。例如，在Streptococcus mutans中，uvrA在pH 5.0的酸性压力下修复DNA损伤。Escherichia coli的DnaK和Deinococcus radiodurans的IrrE也参与酸性压力下的DNA修复机制。在Bacillus caldontenax中，uvrA和uvrB协同识别并修复DNA损伤。\n耐酸的遗传机制 除了细胞层面的相互作用，耐酸细菌还通过耐酸基因适应酸性环境。这些基因调控的耐酸机制包括四种依赖吡哆醛-5\u0026rsquo;-磷酸（PLP）的氨基酸脱羧酶酸耐受系统：谷氨酸依赖酸耐受系统（GDAR）、精氨酸依赖酸耐受系统（ADAR）、赖氨酸依赖酸耐受系统（LDAR）和鸟氨酸依赖酸耐受系统（ODAR）。这些系统协同作用，确保耐酸细菌在极端低pH环境中的代谢和生长。\n谷氨酸依赖酸耐受系统（GDAR） GDAR系统由gadA和gadB基因编码的两种Gad酶以及gadC基因编码的谷氨酸/γ-氨基丁酸（GABA）反向转运蛋白组成。GadC将细胞外的质子化谷氨酸转运至细胞内，同时将细胞内的GABA转运至细胞外。通过谷氨酸与GABA的交换，细胞内质子被消耗，从而提高细胞内pH，保护细胞免受酸冲击。在Lactobacillus reuteri中，GadC通过交换GABA和谷氨酸发挥作用。此外，GadC还将谷氨酰胺转运至细胞内，在酸激活的ybaS基因帮助下转化为谷氨酸和氨。在Escherichia coli中，ybaS基因编码的谷氨酰胺酶将L-谷氨酰胺转化为L-谷氨酸，并通过生成氨中和H⁺。GDAR系统在pH低至2.0的极端酸性环境中对多种耐酸细菌的生存至关重要。\n精氨酸依赖酸耐受系统（ADAR） ADAR系统在酸性条件下（通常pH∼5.0）被最大程度诱导，主要存在于厌氧环境中生长的耐酸细菌中。该系统由adiA基因编码的胞质可诱导精氨酸脱羧酶、adiY基因编码的调控蛋白以及adiC基因编码的反向转运蛋白组成。精氨酸通过AdiC进入细胞，在AdiA的催化下转化为胍丁胺，随后胍丁胺被转运至细胞外。这一交换过程消耗细胞内质子，从而保护细胞。在Escherichia coli中，AdiC通过交换精氨酸和胍丁胺发挥作用。此外，ADAR系统还受ArcD反向转运蛋白调控，精氨酸通过ArcD进入细胞，经精氨酸脱亚胺酶（ADI）代谢为氨和瓜氨酸，最终生成ATP。在Streptococcus pyogenes中，ADAR系统是抵御酸性压力的主要机制。\n赖氨酸依赖酸耐受系统（LDAR） LDAR系统在pH 5.5的厌氧条件下被诱导，由cadBA操纵子组成，包括cadA和cadB基因，受cadC基因产物调控。CadC通过与赖氨酸特异性渗透酶LysP的相互作用诱导cadBA操纵子。在Escherichia coli中，CadC通过LysP间接感知赖氨酸。赖氨酸通过CadB进入细胞，在CadA的催化下转化为尸胺，随后被CadB转运至细胞外。在Edwardsiella tarda中，cadBA操纵子帮助细菌在低pH环境中生存。\n鸟氨酸依赖酸耐受系统（ODAR） ODAR系统在低pH条件下诱导speF和potE基因。鸟氨酸通过PotE进入细胞，转化为腐胺后被转运至细胞外。在Escherichia coli中，PotE通过交换鸟氨酸和腐胺发挥作用。这些脱羧酶在特定低pH范围内表现出最佳酶活性，例如gadA/gadB在pH 1.7-2.8范围内，adiA在pH 4.9-5.2范围内，ldcI在pH 5.7，speF在pH 6.5。因此，耐酸细菌在pH 4.0-7.0范围内表现出强酸应激响应，酶活性随pH升高而降低。\n耐酸基因与细菌的进化与多样性 为适应高度酸性环境，不同耐酸细菌发展出多种耐酸机制。耐酸基因从1924年发现的Streptococcus mutans逐渐进化而来。在酸性环境中，细胞质酸化导致蛋白质和DNA结构损伤，进而诱导蛋白修复伴侣DnaK和信号识别基因ffh的表达，增加氨基酸代谢和氨生成，并上调H⁺-ATPase和DNA损伤修复蛋白RecA。此外，Streptococcus mutans通过群体感应系统irvA和luxS调控生物膜形成，增强耐酸性。在Streptococcus pyogenes中，ADAR系统和F₁F₀-ATPase是主要的耐酸机制。Salmonella enterica则通过ADAR和LDAR系统在低pH环境中生存。cadBA操纵子在arc操纵子之后进化，参与赖氨酸脱羧和精氨酸脱羧机制。近年来，更复杂的耐酸操纵子（如gad操纵子）被广泛发现，这些系统通过水平基因转移和重组进化，从简单系统逐渐发展为广泛分布的复杂系统。\n耐酸细菌在工业与生物修复中的应用 耐酸细菌的耐酸机制在工业生物过程和工业废水处理（如矿山废水和石油泄漏）中具有广泛应用（Feng等，2021）。这些机制还可用于提高有机酸的生产效率。开发有效的工具以增强耐酸机制，对扩大工业耐酸细菌的应用至关重要。\n工业生物过程与生物发电中的耐酸菌株 耐酸细菌在工业生物过程中发挥重要作用。例如，在乳酸发酵过程中，Lactobacillus通过大分子修复和谷氨酰胺酶依赖的酸耐受系统应对酸性压力。低pH激活谷氨酸脱羧酶系统，增加γ-氨基丁酸（GABA）的生成，从而筛选高效乳酸菌。Lactobacillus reuteri通过GadA/GadB将谷氨酸转化为GABA，并由GadC转运至细胞外。此外，Lactobacillus lactis通过减少细胞内质子、消耗H⁺和改变细胞膜成分来耐受酸性环境。分子伴侣GroES和GroEL蛋白以及murG、gshA和gshB基因通过遗传工程提高其耐酸性。\n在乙酸和丁酸生产中，发酵细菌如Clostridium tyrobutyricum和Acetobacter pasteurianus通过gadA、gadB、gadC和uvrA等基因抵御酸性压力。RNA-Seq转录组学分析揭示了Acetobacter pasteurianus通过yro2、mrh1、COX20、PEP3和RTT109等基因修饰细胞膜并保护细胞。丙酸生产菌Propionibacteria acidipropionici则通过GDAR和ADAR系统以及atpA基因编码的F₁F₀-ATPase质子泵维持pH稳态，从而提高丙酸产量。\n废水处理与生物发电 耐酸细菌广泛用于处理市政污水、农业用地和工业废水。此外，它们还可用于生物发电。微生物燃料电池（MFC）是一种生物电化学装置，利用耐酸细菌催化废水中的可降解化合物生成生物电。在MFC中，耐酸细菌位于阳极室，氧化废水中的有机和无机底物，生成二氧化碳、质子和电子。质子通过质子交换膜传递至阴极，电子通过外部电路传递至阴极，最终还原氧气。Acidithiobacillus和Ferroplasma等菌株在pH 1.5-3.0范围内以四硫酸盐为电子供体产生生物电。然而，MFC的发电效率受高内电阻限制，需通过系统架构的优化提高电力输出。\n在生物修复中的应用 耐酸细菌在生物修复中广泛应用，尤其是在酸性压力条件下。生物修复是指细菌将有害有机物质矿化或转化为无毒物质，进而参与自然生物地球化学循环的过程。酸性矿山排水（AMD）含有高浓度的铝、铅、砷和锌等重金属，其高酸性进一步溶解其他金属和类金属，增加矿物溶解。耐酸细菌如Clostridium spp. 和Desulfovibrio spp. 通过上流式厌氧污泥床反应器修复酸性矿山排水，其中Desulfovibrio spp. 利用F₁F₀-ATPase质子泵排出细胞内H⁺以耐受酸性环境。\n废水中的有机污染物和有毒重金属可通过耐酸细菌的酶促反应降解。水解酶、脱氢酶、脱卤酶、蛋白酶和脂肪酶等代谢酶将有机污染物转化为无毒代谢物，实现环境友好型降解。耐酸细菌还可通过生物吸附、生物积累、生物转化和生物沉淀等机制修复重金属污染。例如，生物膜形成的耐酸细菌在去除金属方面更为高效，其胞外聚合物（EPS）通过带负电荷的功能基团吸附金属阳离子。Desulfovibrio desulfuricans产生的EPS有助于锌的生物吸附和生物沉淀，而Lysinibacillus sphaericus RTA-01则通过纳米吸附去除水溶液中的Cr⁶⁺。\n硫酸盐氧化和硫酸盐还原耐酸细菌分别参与生物浸出和生物沉淀过程。Acidithiobacillus ferrooxidans和Acidithiobacillus thiooxidans等细菌通过生物浸出将低品位铁矿石中的金属氧化为低毒可溶性化合物。Clostridium spp. 和Desulfovibrio spp. 的混合培养物可高效去除铜、镉和镍等重金属。Pseudomonas aeruginosa通过产生金属螯合剂（如铁载体）提高金属溶解性。\n耐酸细菌还可用于处理工业废水。Acidophilus、Brevibacterium、Leptospirillum和Stenotrophomonas等极端耐酸细菌可用于酸性矿山排水的生物处理。Lysinibacillus sphaericus RTA-01和Bacillus pumilus CTO-05可去除橡胶加工废水中的硝酸盐和磷酸盐。基因复制和耐酸基因的插入有助于提高细菌的生物修复能力。\n多环芳烃（PAHs）是酸性废水中的常见污染物。Acidocella sp.和Acidiphilium facilis可在pH 2.0的极端条件下降解甲苯、萘、菲和蒽等石油烃。Pseudomonas putida也可用于降解邻二甲苯、苯和甲苯等化合物。生物修复效率受温度、pH、营养物可用性、溶解氧和电子受体等多种因素影响。ybaS、cfa、dnaK和rpoS等耐酸基因在PAHs的降解中起关键作用。因此，提高耐酸基因的表达是增强生物修复和降解效率的关键。\n通过工程酸耐受性基因提高酸耐受性 通过基因工程技术改造耐酸基因，可显著提高细菌的耐酸性。基因组改组和原生质体融合是高效的技术手段。例如，Propionibacterium acidipropionici通过紫外线诱变和原生质体融合，获得耐酸菌株，丙酸产量提高了65%。Lactococcus lactis通过表达Escherichia coli的谷胱甘肽合成酶和Propionibacterium freudenreichii的海藻糖生物合成途径，增强了耐酸性。Propionibacterium acidipropionici工程化atpA基因，利用F₁F₀-ATPase泵出过量质子，维持细胞内pH；Propionibacterium jensenii ATCC 4868引入arcA、arcC、gadB、gdh和ybaS基因，提高了丙酸生产效率。\n耐酸基因的引入为细菌提供了额外的耐酸机制，基因工程菌株在生物修复和有机污染物降解中具有重要应用。未来需进一步探索耐酸基因的作用，并利用先进基因工程技术进行深入表征，以实现工业废水、重金属和有机污染物的高效、可持续生物修复。\nReferences Mallick, S., Das, S. Acid-tolerant bacteria and prospects in industrial and environmental applications. Appl Microbiol Biotechnol 107, 3355–3374 (2023). https://doi.org/10.1007/s00253-023-12529-w Mirete, S., Morgante, V., González-Pastor, J.E. (2017). Acidophiles: Diversity and Mechanisms of Adaptation to Acidic Environments. In: Stan-Lotter, H., Fendrihan, S. (eds) Adaption of Microbial Life to Environmental Extremes. Springer, Cham. https://doi.org/10.1007/978-3-319-48327-6_9 Guan, N., Liu, L. Microbial response to acid stress: mechanisms and applications. Appl Microbiol Biotechnol 104, 51–65 (2020). https://doi.org/10.1007/s00253-019-10226-1 Lund PA, De Biase D, Liran O, Scheler O, Mira NP, Cetecioglu Z, Fernández EN, Bover-Cid S, Hall R, Sauer M, O\u0026rsquo;Byrne C. Understanding How Microorganisms Respond to Acid pH Is Central to Their Control and Successful Exploitation. Front Microbiol. 2020 Sep 24;11:556140. doi: 10.3389/fmicb.2020.556140. PMID: 33117305; PMCID: PMC7553086. ","date":"2025-03-12T00:00:00Z","image":"https://jb-cao.github.io/Cao-blog/p/acid/images/fig1_hu_c3edc6960e3d9113.png","permalink":"https://jb-cao.github.io/Cao-blog/p/acid/","title":"微生物的耐酸机制研究"},{"content":"Introduction 在宏基因组学的研究领域中，对病毒序列宿主的预测已经成为一项极具挑战性但又至关重要的任务。病毒是一种非细胞生命形态的微生物，它们必须依赖宿主细胞才能进行繁殖和生存。然而，在复杂的生态环境中，病毒所感染的宿主往往是未知的。病毒宿主预测就是通过各种技术手段和方法，利用病毒基因组中的信息来推测其可能感染的宿主（如细菌等微生物）的过程。\n目前已有的宿主预测方法已经有很多了，比如2022年前就有以下工具：\n名称 模型 描述 预测水平 WIsH 马尔可夫模型 针对潜在宿主基因组训练了一个同质的马尔可夫模型，并计算原核生物基因组作为查询病毒宿主的可能性。 属 PHP 高斯混合模型 利用 - mers频率（可反映病毒和宿主共享的密码子使用模式）来训练高斯混合模型。 属 HoPhage 深度学习模型和马尔可夫链算法 使用每个候选宿主基因组的编码序列（CDS）构建马尔可夫链模型，然后计算查询噬菌体片段感染候选宿主基因组的可能性。还使用深度学习模型，并最终将深度学习模型的结果与马尔可夫模型的结果整合用于宿主预测。 属 VPF-Class 基于序列匹配的模型 利用从IMG/VR系统下载的病毒蛋白家族（VPFs）来估计查询病毒与已知宿主病毒之间的相似性。 属 RaFAH 随机森林模型 使用MMseqs2生成蛋白质簇并构建轮廓隐马尔可夫模型（HMMs）。然后，使用HMM比对输出的特征训练多类别随机森林模型。 属 HostG 图卷积网络（GCN） 利用病毒和原核生物之间共享的蛋白质簇创建知识图谱，并训练GCN进行预测。 属 PHIST 基于比对的模型 基于病毒和宿主基因组之间的精确匹配来预测病毒的宿主原核生物。 种 PredPHI 卷积神经网络（CNN） 利用蛋白质序列中的化学成分信息（如氨基酸丰度）训练CNN进行宿主预测。 种 PHIAF 生成对抗网络（GAN）和卷积神经网络（CNN） 使用来自DNA和蛋白质序列的特征（如 - mers频率和分子量）训练CNN进行宿主预测，并应用GAN从已知的病毒 - 宿主相互作用生成伪病毒 - 宿主对以扩充数据集。 种 vHULK 多层感知机模型（MLP） 将宿主预测表述为一个多类别分类问题，输入为病毒，标签为原核生物，模型使用的特征是针对噬菌体蛋白家族pVOGs数据库的蛋白质轮廓比对结果。 种 DeepHost 卷积神经网络（CNN） 设计了一种基因组编码方法，使用 - mers特征将各种长度的基因组编码成3D矩阵，并训练CNN模型进行宿主预测。 种 VHM-net 马尔可夫随机场 利用马尔可夫随机场框架，通过结合病毒和原核生物之间的多种特征（如CRISPRs、WIsH的输出得分、BLASTN比对等）来预测病毒是否感染目标原核生物。 种 CHERRY 图卷积编码器和解码器用于链接预测 将宿主预测问题表述为多模态图中的链接预测问题，并设计了用于宿主预测的编码器 - 解码器结构。多模态图将不同类型的特征（包括蛋白质组织、CRISPR、序列相似性和 - mers频率）集成到节点和边中，边连接来自标记（训练）和未标记（测试）数据的病毒和原核生物。 种 主要原理 （一）基于比对的方法\n基于病毒间相似性或病毒与原核生物基因组相似性 这类方法主要利用病毒之间或病毒与原核生物基因组之间的相似性来实现宿主识别。例如，VPF - Class方法，它利用从IMG/VR系统下载的病毒蛋白家族（VPFs）。通过计算查询病毒与已知宿主病毒之间的VPFs相似性，根据与VPFs的比对结果，就能对查询的每个病毒片段（contig）给出宿主预测结果。 PHIST方法则是利用病毒基因组与原核生物基因组之间的序列匹配来进行宿主预测。它通过识别病毒和原核生物基因组共有的 - mers（长度为k的连续核苷酸序列），从而估计病毒 - 原核生物对形成真实相互作用（即感染关系）的概率。 利用CRISPR的比对预测 一些原核生物会通过CRISPR（成簇的规律间隔的短回文重复序列）记录病毒感染信息以预防再次感染。部分基于比对的工具利用这一特性来预测宿主。比如使用BLAST（基本局部比对搜索工具）等方法，通过搜索原核生物和病毒之间的短序列匹配来预测宿主。然而，这种方法存在一定的局限性，因为只有2 - 10%的测序原核生物含有CRISPRs，而且很多病毒与原核生物注释或预测的CRISPRs没有比对结果，所以无法利用这一信号进行宿主预测。 （二）基于学习的方法\n基于序列特征构建模型 机器学习和深度学习学习基于学习的方法更加灵活，大多数这类方法是学习基于序列的特征用于宿主预测。 例如，WIsH方法会针对潜在宿主基因组训练一个同质的马尔可夫模型。该模型随后计算一个原核生物基因组作为查询病毒宿主的可能性，并将可能性最高的原核生物指定为宿主。 vHULK方法将宿主预测表述为一个多类别分类问题，其中输入是病毒，标签是原核生物。它在其深度学习模型中使用的特征是针对噬菌体蛋白家族pVOGs数据库的蛋白质轮廓比对结果。 RaFAH方法不使用公共数据库，而是使用MMseqs2软件生成蛋白质簇并构建轮廓隐马尔可夫模型（HMMs）。然后，它利用HMM比对输出的特征并训练一个多类别随机森林模型。 HoPhage是另一个基于多类别分类模型的宿主预测工具，它使用深度学习和马尔可夫链算法。它通过利用每个候选宿主基因组的编码序列（CDS）构建马尔可夫链模型，计算查询噬菌体片段感染候选宿主基因组的可能性，然后还使用一个深度学习模型，并最终将深度学习模型与马尔可夫模型的结果整合以预测宿主。 基于 - mers频率和相关蛋白的特征预测 PHP方法利用 - mers频率，因为它可以反映病毒和宿主共享的密码子使用模式来预测宿主。 DeepHost和PHIAF也利用基于 - mers的特征来训练卷积神经网络进行宿主预测。 基于受体结合蛋白（RBPs）的特征预测 Boeckaerts等人构建学习模型时使用从受体结合蛋白（RBPs）提取的特征进行宿主预测。不过，这一方法存在局限性，因为在所有病毒中注释RBPs并不容易，该作者仅收集了与九个宿主相关的RBPs，所以这个工具只能预测非常有限的宿主物种。 构建知识图谱或整合多种特征预测 HostG利用病毒和原核生物之间共享的蛋白质簇创建知识图谱，并训练图卷积网络进行预测。虽然它预测的准确性较高，但只能预测到属水平的主机。VHM - Net结合了病毒和原核生物之间的多种特征，如CRISPRs、WIsH的输出得分、BLASTN比对得分等。 近几年也有更多方法不断被发表出来，很难评判哪个软件最好用最准确，大家可以挑选最适合自己数据和研究问题的工具。这篇文章简要介绍一下几个我用过的软件。\nVPF-Class：基于病毒蛋白家族的病毒分类分配和宿主预测 VPF-Class是一种基于病毒蛋白家族（VPFs）信息的工具，用于对未培养病毒进行分类和宿主预测。它通过将病毒蛋白质分配到已分类的VPFs中，实现了在多个分类级别（包括Baltimore分类系统、病毒科和属）上的自动化分类和宿主预测。VPF-Class在RefSeq数据库中表现出高准确性，属级别的分类准确率接近100%，宿主预测准确率为86.4%。该工具无需下载或选择参考数据库，避免了映射过程中的偏差，使其更易于使用。VPF-Class适用于宏基因组研究、病毒发现和病毒生态学研究，帮助研究人员在没有培养条件的情况下识别新的病毒序列并预测其宿主。\n在VPF-Class中，主要步骤包括：\nVPFs的分类和宿主预测：首先，对VPFs进行分类，并根据其与已知病毒的同源关系进行宿主预测。\n病毒基因组的分类和宿主预测：利用分类后的VPFs对未培养病毒基因组进行分类和宿主预测。\n交叉验证和VPFs的第二轮分类：通过比较未培养病毒的分类结果来更新VPFs的分类信息，以提高分类的准确性。\n病毒基因组的分类和评分：为每个病毒基因组提供分类和宿主预测结果，并计算相应的置信度评分。\n安装使用 在GitHub上的biocom-uib/vpf-tools项目中，提供了两种安装方法：使用Docker和从源代码构建（但是我的服务器上直接没有sudo权限，docker也用不了，stack也装不了😂，只能在自己的电脑上安装了）。以下是详细的安装步骤：\n方法1：使用Docker\n1 2 3 4 5 6 7 8 docker volume create vpf-data docker run --rm -it \\ -v \u0026#34;vpf-data:/opt/vpf-tools/vpf-data\u0026#34; \\ -v \u0026#34;$PWD/seqs:/opt/vpf-tools/input-sequences:ro\u0026#34; \\ -v \u0026#34;$PWD/outputs:/opt/vpf-tools/outputs:rw\u0026#34; \\ bielr/vpf-tools \\ vpf-class -i seqs/test.fna -o outputs/test-classified 我尝试将本地的docker转换为HPC上的singularity来运行：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 在 Docker 环境下转换 sif docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \\ -v $PWD:/output quay.io/singularity/docker2singularity \\ bielr/vpf-tools docker save -o vpf-tools.tar bielr/vpf-tools singularity build vpf-tools.sif docker-archive://vpf-tools.tar mkdir -p $PWD/vpf-data docker run --rm -v \u0026#34;$PWD/vpf-data:/opt/vpf-tools/vpf-data\u0026#34; bielr/vpf-tools cp -r /opt/vpf-tools/vpf-data/ # 在singularity环境运行 # 把vpf-tools.sif和vpf-data文件夹拷贝到HPC上 singularity exec --bind \u0026#34;$PWD/vpf-data:/opt/vpf-tools/vpf-data\u0026#34; \\ --bind \u0026#34;$PWD/seqs:/opt/vpf-tools/input-sequences:ro\u0026#34; \\ --bind \u0026#34;$PWD/outputs:/opt/vpf-tools/outputs:rw\u0026#34; \\ vpf-tools.sif \\ vpf-class -i seqs/test.fna -o outputs/test-classified 方法2：从源代码构建\n安装Stack： 使用以下命令安装Stack（适用于Mac OS和Linux，未在Windows上测试）：\n1 curl -sSL https://get.haskellstack.org/ | sh 克隆仓库： 克隆vpf-tools仓库：\n1 2 git clone https://github.com/biocom-uib/vpf-tools cd vpf-tools 编译工具： 使用Stack编译所有目标：\n1 stack build 第一次编译可能需要一些时间，因为Stack还需要安装GHC并编译所有依赖项。\n运行工具： 编译完成后，可以通过在命令前加上stack exec --来运行工具，例如：\n1 stack exec -- vpf-class --help 实验性支持OpenMPI： 如果需要使用OpenMPI，可以在构建时添加--flag vpf-class:+mpi标志，然后像其他程序一样使用mpirun运行工具。\n补充材料\n分类文件： 可以在这里找到VPF的分类文件，包括index.yaml。\n单个数据文件： 可以在这里下载单个数据文件，选择“VPF classification”选项卡。\nHMMER模型文件： 最新的包含VPF HMMER模型的文件可以从IMG/VR下载（注意：链接可能已失效，可以在这里找到一个副本）。将final_list.hmms解压到数据目录中，与index.yaml相邻。\n常见问题 HMMERNotFound： 确保HMMER安装正确，并且可以通过$PATH访问。如果不在$PATH中，可以使用--hmmer-prefix指定路径。\nProdigalNotFound： 确保Prodigal已安装，并且可以通过$PATH访问。如果不在$PATH中，可以使用--prodigal指定可执行文件的位置。\nStack安装问题： 如果在安装过程中遇到问题，请参考Stack文档以确保所有依赖项都满足。（还挺难搞的😂）\nConda环境问题： 由于一些用户报告了Stack和Conda的问题，建议避免在Conda污染的环境中安装Stack。\nCherry：图编码器模型准确预测病毒-原核宿主相互作用 在微生物群落中，感染细菌和古菌的原核病毒是关键参与者。预测原核病毒的宿主有助于解码微生物之间的动态关系。然而，实验方法无法跟上高通量测序技术产生的噬菌体序列的快速积累，因此需要计算方法来进行宿主预测。尽管取得了一些有希望的结果，但由于已知相互作用的限制和大量测序噬菌体的数量，计算宿主预测仍然是一个挑战。目前最先进的方法在物种水平上的准确率只能达到43%。\n在这项工作中，研究者将宿主预测问题表述为一个知识图中的链接预测问题，整合了多种基于蛋白质和DNA的序列特征。研究者实现的工具名为CHERRY，可以应用于预测新发现病毒的宿主，并识别感染目标细菌的病毒。研究者展示了CHERRY在这两种应用中的实用性，并将其性能与其他11种流行的宿主预测方法进行了比较。据研究者所知，CHERRY在识别病毒-原核生物相互作用方面具有最高的准确性。它在物种水平上超越了所有现有方法，准确率提高了37%。此外，CHERRY在短片段上的表现比其他工具更稳定。\n安装使用 CHERRY 是一个用于预测病毒与原核生物基因组相互作用的 Python 库。使用 Conda 安装：\n克隆仓库：\n1 git clone https://github.com/KennthShang/CHERRY.git 创建并激活 Conda 环境：\n1 2 3 cd CHERRY conda env create -f CHERRY.yaml -n cherry conda activate cherry 准备数据库： 由于 GitHub 文件大小限制，数据库文件被压缩为 .bz2 格式。需要解压这些文件：\n1 2 3 4 5 6 cd dataset bzip2 -d protein.fasta.bz2 bzip2 -d nucl.fasta.bz2 cd ../prokaryote gunzip * cd .. 激活环境： 每次使用 CHERRY 之前，确保激活 cherry 环境：\n1 conda activate cherry 使用 输入文件： 输入文件应该是一个包含病毒序列的 FASTA 文件。研究者提供了一个示例文件 test_contigs.fa。\n运行命令： 使用以下命令进行宿主预测：\n1 python run_Speed_up.py [--contigs INPUT_FA] [--len MINIMUM_LEN] [--model MODEL] [--topk TOPK_PRED] --contigs INPUT_FA：输入的 FASTA 文件（默认为 test_contigs.fa）。 --len MINIMUM_LEN：仅对长度大于等于指定长度的序列进行预测（默认为 8000）。 --model MODEL：使用预训练参数或重新训练的参数进行预测（默认为 pretrain）。 --topk TOPK_PRED：输出前 K 个预测结果（默认为 1）。 示例：\n1 python run_Speed_up.py --contigs test_contigs.fa --len 8000 --model pretrain --topk 1 输出文件： 输出文件格式为 CSV 文件（final_prediction.csv），包含每个病毒的预测结果。列 contig_name 是输入文件的访问号。\n生成分类树： 使用以下命令将预测结果转换为完整的分类树：\n1 python run_Taxonomy_tree.py [--k TOPK_PRED] 需要指定 k 来生成树，输出文件为 Top_k_prediction_taxonomy.csv。\n扩展病毒-原核生物相互作用数据库 如果有比预训练模型更多的病毒-原核生物相互作用信息，可以添加它们来训练自定义模型：\n添加病毒基因组： 将病毒基因组添加到 nucl.fasta 文件中，并运行 python refresh.py 以生成新的 protein.fasta 和 database_gene_to_genome.csv 文件。\n添加宿主分类信息： 在 dataset/virus.csv 中添加宿主分类信息。表头为：\nAccession（病毒） Superkingdom Phylum Class Order Family Genus Species（必填） 添加原核生物基因组： 将原核生物基因组放入 prokaryote/ 文件夹，并在 dataset/prokaryote.csv 中添加条目。\n重新训练模型： 使用 retrain 作为 --mode 参数运行程序：\n1 python run_Speed_up.py --mode retrain 预测感染特定原核生物的病毒 输入文件：\n将原核生物基因组放入 new_prokaryote/ 文件夹。 提供一个包含病毒序列的 FASTA 文件。 在 database/prokaryote.csv 中添加分类信息。 运行命令： 使用以下命令进行预测：\n1 python run_Speed_up.py [--mode MODE] [--t THRESHOLD] --mode MODE：切换模式为预测病毒或宿主（prokaryote 或 virus）。 --t THRESHOLD：预测病毒的置信度阈值，阈值越高，精度越高（默认为 0.98）。 示例：\n1 python run_Speed_up.py --contigs test_contigs.fa --mode prokaryote --t 0.98 输出文件： 输出文件格式为 CSV 文件，包含每个病毒的预测结果。列 prokaryote 是给定原核生物基因组的访问号，列 virus 是可能感染这些基因组的病毒列表。\n常见问题 如果程序输出错误（通常是由于机器配置问题）：\n1 Error: mkl-service + Intel(R) MKL: MKL_THREADING_LAYER=INTEL is incompatible with libgomp.so.1 library. 可以尝试在运行 run_Speed_up.py 之前执行以下命令：\n1 export MKL_SERVICE_FORCE_INTEL=1 如果不想上面这样安装到本地或者很难运行成功，可以使用作者提供的在线网站phabox（https://phage.ee.cityu.edu.hk/phabox），可以直接上传文件进行预测。还是比较方便且运行较快的。\nIPEV：深度学习鉴定原核/真核病毒衍生序列 上面👆的CHERRY是只能鉴定潜在的原核生物宿主，而IPEV可以准确预测原核/真核病毒，可以作为一个扩充。\n通过病毒样颗粒富集获得的病毒组包含原核和真核病毒来源的片段混合物。准确识别和分类这些元素对于理解它们在微生物群落中的作用和功能至关重要。然而，病毒基因组的快速突变率对开发高性能分类工具提出了挑战，可能会限制下游分析。\n研究者提出了一种新颖的方法 IPEV，用于区分病毒组中的原核和真核病毒。该方法结合了二维卷积神经网络，利用三核苷酸对的相对距离和频率进行识别。IPEV 的交叉验证评估显示其在独立测试集上的精度处于领先地位，与现有方法相比，在查询病毒与已知病毒序列相似性低于 30% 的情况下，F1 分数显著提高了约 22%。此外，IPEV 在海洋和肠道病毒组样本上的准确性优于基于序列比对注释的其他方法。IPEV 相较于现有方法在同一计算配置下最多减少了 1,225 倍的运行时间。研究者还利用 IPEV 分析纵向样本，发现肠道病毒组比以往观察到的持久个人病毒组展现出更高的时间稳定性，为个体肠道病毒组的韧性提供了新的见解。\nIPEV 是一种高性能、用户友好的工具，帮助生物学家在病毒组中识别和分类原核和真核病毒。该工具可在 IPEV GitHub 仓库 或 Docker Hub 获取。IPEV 基于 Python3.8.6 和 TensorFlow 2.3.1 构建，通过并行处理和算法优化，能够快速获得计算结果。\n安装使用 IPEV 是一个用于识别病毒组数据中原核和真核病毒序列的深度学习软件工具。以下是安装和使用 IPEV 的详细步骤：\n方法一：从 GitHub 使用\n克隆仓库：\n1 git clone https://github.com/basehc/IPEV.git 创建新环境（推荐以避免与现有包冲突）：\n使用 Conda： 1 2 conda create -n your_env_name python=3.8.6 conda activate your_env_name 使用 virtualenv： 1 2 python3 -m venv /path/to/new/virtual/environment source /path/to/new/virtual/environment/bin/activate 设置操作环境： 进入项目目录并安装必要的依赖项：\n1 2 cd IPEV python -m pip install -r requirements.txt 方法二：从 Docker Hub 使用\n拉取镜像：\n1 docker pull dryinhc/ipev_v1 运行容器： 打开一个新的终端窗口并运行以下命令以启动基于镜像的容器：\n1 docker run -it --rm dryinhc/ipev_v1 传输数据文件： 在新的终端窗口中，将数据文件传输到容器内：\n1 docker cp data.fasta dryinhc/ipev_v1:/app/tool/ 在容器内运行程序： 切换到容器内并运行程序：\n1 2 3 docker exec -it \u0026lt;container_id\u0026gt; /bin/bash cd tool python run.py data.fasta 退出容器： 按 Ctrl+D 或输入 exit 退出容器。\n使用 基本使用： 进入 IPEV 目录并运行示例文件：\n1 2 cd ./IPEV python run.py example.fasta 去除非病毒序列： IPEV 提供了一个功能来过滤掉病毒组数据中的非病毒成分。使用以下命令启用该功能（默认为关闭）：\n1 python run.py example.fasta -filter yes 序列评分文件：程序会生成一个 TSV 文件，包含每个序列的最终评分，存储在以当前日期和时间命名的文件夹中。\n评分直方图：程序还会创建一个直方图，显示不同评分在 FASTA 文件中序列中出现的频率。\n为了节省时间，最好将所有序列放在一个单独的 FASTA 文件中，这样程序可以更快地处理。\n如果需要去除非病毒序列，请确保在运行时使用 -filter yes 参数。\nReferences Joan Carles Pons, David Paez-Espino, Gabriel Riera, Natalia Ivanova, Nikos C Kyrpides, Mercè Llabrés, VPF-Class: taxonomic assignment and host prediction of uncultivated viruses based on viral protein families, Bioinformatics, Volume 37, Issue 13, July 2021, Pages 1805–1813, https://doi.org/10.1093/bioinformatics/btab026 Jiayu Shang, Yanni Sun, CHERRY: a Computational metHod for accuratE pRediction of virus–pRokarYotic interactions using a graph encoder–decoder model, Briefings in Bioinformatics, Volume 23, Issue 5, September 2022, bbac182, https://doi.org/10.1093/bib/bbac182 Hengchuang Yin, Shufang Wu, Jie Tan, Qian Guo, Mo Li, Jinyuan Guo, Yaqi Wang, Xiaoqing Jiang, Huaiqiu Zhu, IPEV: identification of prokaryotic and eukaryotic virus-derived sequences in virome using deep learning, GigaScience, Volume 13, 2024, giae018, https://doi.org/10.1093/gigascience/giae018 ","date":"2025-03-05T00:00:00Z","image":"https://jb-cao.github.io/Cao-blog/p/virus-host/images/IPEV_hu_edf3f79347556902.png","permalink":"https://jb-cao.github.io/Cao-blog/p/virus-host/","title":"宏基因组中病毒序列的宿主预测"},{"content":"Introduction 在生物信息学（生信）研究领域，数据处理和分析任务日益复杂，对计算资源的需求也越来越高。为了提高研究效率、确保环境一致性和可重复性，容器技术应运而生。Docker和Singularity作为两种主流的容器解决方案，在生信领域得到了广泛应用。本文将简单介绍这两种容器的基本概念、使用方法，至少在面对一些提供了Docker安装方式的软件（有可能其他安装方法都报错😂）时可以作为使用的一个选择。\n容器是一种轻量级的虚拟化技术，它允许在单个操作系统实例上运行多个隔离的应用程序。容器将应用程序及其所有依赖项（如库、配置文件等）打包成一个独立的运行环境，称为容器。这种技术使得应用程序可以在不同的环境中一致地运行，而无需担心底层基础设施的差异。\n特点 轻量级：容器共享宿主机的操作系统内核，因此相比传统的虚拟机，容器需要更少的系统资源，启动更快，资源占用更少。 隔离性：容器提供了一定程度的隔离，每个容器都有自己的运行环境，互不干扰。这种隔离是通过操作系统级别的虚拟化技术实现的，如Linux的cgroups和namespaces。 可移植性：由于容器包含了运行应用程序所需的所有依赖项，因此可以在不同的环境（开发、测试、生产等）中无缝迁移和部署。 可扩展性：容器可以快速启动和停止，这使得它们非常适合用于动态扩展应用程序的规模，以应对变化的负载需求。 资源控制：可以为每个容器分配特定的CPU、内存和存储资源，确保应用程序的性能和稳定性。 版本控制和一致性：容器镜像可以被视为应用程序的“快照”，可以通过版本控制工具进行管理。这有助于确保在不同环境中部署的应用程序保持一致。 Docker Docker是目前最流行的容器技术，广泛应用于云计算和开发测试环境，由Docker公司（原名dotCloud）于2013年推出。Docker通过容器技术，将应用程序及其所有依赖项打包到一个独立的单元中，使其能够在任何环境中一致地运行。它通过Docker镜像和容器的概念，实现了应用的快速部署和管理。然而，Docker在高性能计算（HPC）环境中的应用受到一些限制，如权限管理、资源限制等。\nDocker的基本组件 Docker镜像（Image）：一个只读的模板，包含运行应用程序所需的所有文件和依赖项。镜像是构建容器的基础。 Docker容器（Container）：基于镜像创建的可运行实例。容器可以被启动、停止、删除等操作。 Docker仓库（Registry）：用于存储和分发Docker镜像的地方。Docker Hub是最常用的公共仓库，用户也可以搭建私有仓库。 Docker引擎（Engine）：Docker的核心组件，负责构建、运行和管理容器。 基本使用方法 安装Docker 在安装Docker之前，请确保系统满足Docker的最低要求。以下是在常见操作系统上安装Docker的简要步骤：\nUbuntu：\n1 2 sudo apt-get update sudo apt-get install docker-ce docker-ce-cli containerd.io CentOS：\n1 2 3 sudo yum install -y docker sudo systemctl start docker sudo systemctl enable docker macOS：下载并安装Docker Desktop for Mac。\nWindows：下载并安装Docker Desktop for Windows。\n验证安装 安装完成后，可以通过以下命令验证Docker是否安装成功：\n1 docker --version 基本命令 拉取镜像 从Docker Hub或其他仓库拉取镜像：\n1 docker pull ubuntu:latest 查看本地镜像 列出本地已有的镜像：\n1 docker images 运行容器 基于镜像创建并运行一个容器：\n1 docker run -it --name my_ubuntu ubuntu:latest /bin/bash -i：保持容器的标准输入打开。\n-t：分配一个伪终端。\n--name：指定容器的名称。\n查看运行中的容器\n列出当前正在运行的容器：\n1 docker ps 查看所有容器（包括停止的）：\n1 docker ps -a 停止和删除容器 停止容器：\n1 docker stop my_ubuntu 删除容器：\n1 docker rm my_ubuntu 删除镜像 删除本地镜像：\n1 docker rmi ubuntu:latest Dockerfile简介 Dockerfile 是一个用于定义如何构建Docker镜像的文本文件。通过编写Dockerfile，可以自动化构建过程，确保镜像的一致性和可重复性。以下是一个简单的Dockerfile示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # 使用官方Ubuntu镜像作为基础 FROM ubuntu:latest # 更新包列表并安装常用软件 RUN apt-get update \u0026amp;\u0026amp; apt-get install -y \\ python3 \\ python3-pip \\ \u0026amp;\u0026amp; rm -rf /var/lib/apt/lists/* # 设置工作目录 WORKDIR /app # 复制当前目录下的文件到容器的/app目录 COPY . /app # 安装Python依赖 RUN pip3 install --no-cache-dir -r requirements.txt # 暴露端口 EXPOSE 5000 # 设置容器启动时执行的命令 CMD [\u0026#34;python3\u0026#34;, \u0026#34;app.py\u0026#34;] 构建和运行自定义镜像 在包含Dockerfile的目录下，使用以下命令构建镜像：\n1 docker build -t my_python_app . -t：指定镜像名称及标签。 .：指定Dockerfile所在的路径。 构建完成后，运行容器：\n1 docker run -d -p 5000:5000 --name my_running_app my_python_app -d：后台运行容器。 -p：将宿主机的端口映射到容器的端口。 Singularity Singularity是一种开源的容器化技术，专为科学计算、高性能计算（HPC）和大规模计算工作流程设计。它允许用户将应用程序、环境和依赖项打包到一个独立的、可移植的单个文件中，称为SIF（Singularity Image Format）容器镜像。这使得用户可以在不同的系统上无缝地运行相同的容器，包括在没有root权限的环境中运行。\n基本使用方法 安装Singularity\nSingularity可以通过源码、包管理器或Conda等方式安装。以下是通过包管理器安装的示例：\n1 2 3 4 5 # Ubuntu sudo apt-get update \u0026amp;\u0026amp; sudo apt-get install -y singularity-container # CentOS sudo dnf install -y singularity 拉取镜像\n1 singularity pull docker://ubuntu:latest 运行容器\n1 singularity run ubuntu_latest.sif 进入容器交互模式\n1 singularity shell ubuntu_latest.sif 查看容器信息\n1 singularity inspect ubuntu_latest.sif Docker转化Singularity容器 Docker和Singularity都是流行的容器技术，但在设计目标、使用场景和功能上有一些关键区别。\n设计目标\nDocker：最初设计用于开发、测试和部署微服务，强调快速部署和资源隔离。Docker广泛应用于企业级应用和开发测试环境。 Singularity：专为高性能计算（HPC）和科学计算设计，强调在无root权限环境下的安全性和可移植性。Singularity广泛应用于HPC中心和大规模计算工作流程。 安全性\nDocker：默认以root用户运行容器，存在一定的安全风险。虽然可以通过用户命名空间等技术提高安全性，但配置较为复杂。 Singularity：默认以非root用户运行容器，避免了root权限带来的安全问题。它提供了更强的安全保障，适合在多用户HPC环境中使用。 资源管理\nDocker：在资源管理方面较为灵活，但需要用户手动配置资源限制，如内存和CPU的使用。 Singularity：在资源管理方面更加简单直观，支持自动化的资源分配和管理，适合大规模计算任务。 可移植性\nDocker：Docker镜像可以在不同的操作系统和平台上运行，但在HPC环境中可能会遇到兼容性问题。 Singularity：Singularity容器具有更高的可移植性，能够在不同的HPC系统和云平台上无缝运行。 使用场景\nDocker：适合微服务架构、持续集成和持续交付（CI/CD）、跨平台部署等场景。 Singularity：适合高性能计算（HPC）、科学计算、大规模数据分析和需要高效利用资源的场景。 我们实验室的集群就是不允许使用Docker但能用Singularity的。所以有时候要尝试自己将Docker转化Singularity容器：\n将Docker容器转化为Singularity容器是一种常见的操作，因为Singularity提供了更灵活和安全的容器化解决方案，特别是在高性能计算（HPC）环境中。以下是将Docker容器转化为Singularity容器的几种方法：\n方法一：使用本地现有的Docker镜像 查找Docker镜像ID：\n在运行Docker的主机上，使用docker images命令查找所需的Docker镜像ID。 创建Docker镜像的tarball文件：\n使用docker save命令将Docker镜像保存为一个tarball文件。例如： 1 docker save \u0026lt;IMAGE_ID\u0026gt; -o \u0026lt;IMAGE_NAME\u0026gt;.tar 拷贝tarball文件：\n使用scp或其他文件传输工具将tarball文件拷贝到运行Singularity的主机上。 将tarball转换为Singularity镜像：\n在Singularity主机上，使用singularity build命令将tarball文件转换为Singularity镜像。例如： 1 singularity build --sandbox \u0026lt;SINGULARITY_IMAGE_NAME\u0026gt; docker-archive://\u0026lt;PATH_TO_TARBALL\u0026gt; 运行Singularity沙箱镜像：\n使用singularity shell或singularity exec命令进入Singularity容器并执行命令。 方法二：使用Docker容器仓库中的镜像 如果Docker镜像已经上传到Docker Hub或其他Docker托管存储库中，可以直接下载并转化为Singularity容器。\n从Docker Hub下载：\n使用singularity build命令从Docker Hub下载并构建Singularity镜像。例如： 1 singularity build \u0026lt;SINGULARITY_IMAGE_NAME\u0026gt;.sif docker://godlovedc/lolcow 从Quay下载：\n同样，可以从Quay或其他Docker托管存储库下载并构建Singularity镜像。例如： 1 singularity build \u0026lt;SINGULARITY_IMAGE_NAME\u0026gt;.sif docker://quay.io/biocontainers/samtools:1.17--hd87286a_1 方法三：使用Dockerfiles 从Singularity 4.1版本开始，可以直接从Dockerfiles构建OCI-SIF映像。\n编写Dockerfile：\n编写一个Dockerfile，定义所需的基础镜像和命令。 构建Singularity镜像：\n使用singularity build命令从Dockerfile构建Singularity镜像。例如： 1 singularity build --oci \u0026lt;SINGULARITY_IMAGE_NAME\u0026gt;.oci.sif \u0026lt;Dockerfile\u0026gt; 运行Singularity镜像：\n使用singularity run命令运行构建的Singularity镜像。 通过这些方法，可以将Docker容器轻松地转化为Singularity容器，从而在需要更高安全性和灵活性的环境中使用。\n参考文献： https://cloud.tencent.com/developer/news/1351431 https://www.showapi.com/news/article/66c4d6274ddd79f11a08c187 https://segmentfault.com/a/1190000044706625 ","date":"2025-03-05T00:00:00Z","image":"https://jb-cao.github.io/Cao-blog/p/docker-singularity/images/docker_hu_31ad446a8d9e59a5.webp","permalink":"https://jb-cao.github.io/Cao-blog/p/docker-singularity/","title":"容器（Docker \u0026 Singularity）使用入门"},{"content":"Introduction 随着基因组挖掘技术的进步，生物合成基因簇（BGCs）的研究已成为天然产物发现的核心环节。目前，超过20万个公开的微生物基因组中蕴藏着丰富的化学多样性信息。然而，现有的工具在处理大规模BGCs时，常因基于网络的聚类方法效率低下而面临瓶颈。\nBiG-SLiCE（Biosynthetic Gene clusters - Super Linear Clustering Engine） 应运而生，这是一款专为高效聚类大规模BGCs而设计的工具。它通过将BGCs映射到欧几里得空间，以近乎线性的方式将BGCs分组为基因簇家族（GCFs）。在短短10天内，BiG-SLiCE成功分析了来自209,206个微生物基因组和宏基因组组装基因组（MAGs）的1,225,071个BGCs，并构建了全球次级代谢多样性的分布图谱，揭示了未被开发的生物合成潜力。此外，BiG-SLiCE还提供了“查询模式”，能够快速将新测序的BGCs归类到已有的GCFs中，并配备了强大的可视化引擎，便于用户探索数据。这一工具不仅加速了天然产物的发现，还为构建全球可搜索的BGC网络奠定了基础。\nBiG-SLiCE的开源地址：https://github.com/medema-group/bigslice\nBGCs（以及GCFs）与催化酶及其编码途径产生的化合物直接相关，因此可以作为探索微生物次级代谢化学空间的代理。通过编目所有已测序微生物基因组中的GCFs，可以全面了解现有的化学多样性，并为未来的先导化合物发现提供方向。例如，可以重点关注具有新颖潜力的物种，或识别已知抗生素生产BGC的天然变体。然而，进行此类全球分析需要能够处理海量数据的聚类算法。尽管过去五年中工具的处理能力有所提升（从2014年的11,000–33,000个BGCs到2019年的73,260个），但与当前可用数据量相比仍显不足。截至2020年3月27日，antiSMASH-DB和IMG-ABC两大BGC数据库共包含565,096个BGCs，预测自85,221个细菌基因组。若考虑未覆盖的基因组和宏基因组，这一数字将更大。例如，NCBI RefSeq数据库中的约180,000个细菌基因组可能产生超过1,000,000个BGCs。\n处理如此大规模的数据集，即使是目前最快的工具（如BiG-SCAPE）在36核CPU上也需要约37,000小时运行时间，这在实际中几乎不可行。主要瓶颈在于构建相似性网络和聚类分析时使用的成对BGC比较方法，其时间复杂度为O(n²)。因此，迫切需要一种能够更好适应基因组数据增长的替代方法。为此，研究者开发了BiG-SLiCE（Biosynthetic Genes Super-Linear Clustering Engine），它将BGCs映射到欧几里得空间，采用分区聚类算法，时间复杂度接近线性[∼O(n)]，从而能够快速分析大规模BGC数据集，实现真正全球化的GCF分析。\n为了实现大规模分析，BiG-SLiCE在设计时将可扩展性和速度作为首要目标。与之前的工具BiG-SCAPE（能够敏感捕捉BGCs之间域结构和序列相似性的细微差异）不同，BiG-SLiCE能够在36核CPU、128GB内存的机器上，以不到一周的时间处理超过120万个BGCs的输入数据，同时保持足够的灵敏度以区分输入BGCs中的关键生物合成“信号”。此外，为了便于用户探索和分析结果，BiG-SLiCE还提供了交互式、易于使用的可视化输出，且对软硬件要求极低。\nInstallation 安装方法非常简单，用以下两种选一个即可\n从PyPI安装（稳定版） 1 pip install bigslice 从源码安装（开发版——仅适用于熟悉操作的用户） 1 pip install git+https://github.com/medema-group/bigslice.git 然后下载最新的HMM模型（约271MB压缩文件）\n1 download_bigslice_hmmdb 如果感觉下载太慢了，也可以手动下载：https://github.com/medema-group/bigslice/releases/download/v2.0.0rc/bigslice-models.2022-11-30.tar.gz，下载后重命名为bigslice_models.tar.gz放到whcih download_bigslice_hmmdb的统一目录下再运行即可，就会跳过下载步骤。\n最后检查安装是否成功\n1 bigslice --version 成功安装后，将显示如下信息：\n1 2 3 4 5 6 ============== BiG-SLiCE version 2.0.0 HMM databases version: bigslice-models-2022-11-30 Biosynthetic-pfam md5: 37495cac452bf1dd8aff2c4ad92065fe Sub-pfam md5: 2e6b41d06f3c318c61dffb022798091e ============== Usage BiG-SLiCE 运行模式 [模式1] 聚类分析 解析输入数据集，构建GCF模型（BIRCH聚类），并根据指定阈值（T）进行成员分配。\n参数说明：\n-i|--input_folder \u0026lt;folder_path\u0026gt;：输入文件夹路径，需包含 datasets.tsv 文件及数据集子文件夹。 --resume：继续上一次的聚类运行（不要与 --input_folder 同时使用）。 --complete：构建GCF模型时，仅使用完整的BGCs（antiSMASH \u0026gt; 4.2 标注为 on_contig_edge = False 的BGCs）。 --threshold：用于GCF模型构建（BIRCH算法）和成员分配的聚类阈值（T）。与 --threshold_pct 互斥，使用 -1 关闭此参数（默认：300）。 --threshold_pct：基于数据间成对距离的随机采样计算聚类阈值（T），取第N百分位值作为阈值。与 --threshold 互斥，使用 -1 关闭此参数（默认：-1）。 [模式2] GCF查询 基于[模式1]生成的GCF模型，从输入文件夹中的BGC GenBank文件中提取特征并进行成员分配。\n参数说明：\n--query \u0026lt;folder_path\u0026gt;：输入文件夹路径，需包含所有BGC的GenBank文件（支持antiSMASH4的 clusterXXX.gbk、antiSMASH5的 regionXXX.gbk 或MIBiG ≥ 2.0的 BGCXXXXXXX.gbk）。 --query_name：为查询运行指定唯一名称，便于在输出可视化中追踪。 [模式1+2] 通用参数 适用于聚类和查询模式的参数。\n参数说明：\n--run_id：指定运行ID进行查询（或继续聚类），而非使用最新运行（可在输出可视化中查看运行ID列表）。 --n_ranks \u0026lt;N_RANKS\u0026gt;：为每个BGC的成员分配过程取N个最佳GCF匹配（默认：5）。 --program_db_folder \u0026lt;PROGRAM_DB_FOLDER\u0026gt;：HMM库路径（默认：/mnt/local_scratch/kauts001/general-env/bin/bigslice-models）。 CPU/RAM优化 -t|--num_threads：并行运行的作业数（默认：56）。 --hmmscan_chunk_size：将 biosyn_pfam 扫描拆分为每组N个BGCs的块（默认：100）。 --subpfam_chunk_size：将 sub_pfam 扫描拆分为每组N个BGCs的块（默认：100）。 --extraction_chunk_size \u0026lt;EXTRACTION_CHUNK_SIZE\u0026gt;：将特征提取拆分为每组N个BGCs的块（默认：100）。 --scratch：不将Sqlite3数据库加载到内存中（降低RAM使用，但可能降低速度）。 [Misc] 其他可选参数： -h, --help 显示帮助信息。 --export-tsv \u0026lt;folder_path\u0026gt; 将现有的预计算输出数据导出为TSV格式文件（指定目标文件夹路径）。 --program_db_folder PROGRAM_DB_FOLDER 指定HMM库的路径（默认路径：/share/home/jianglab/pengchen/miniconda3/envs/antismash_5.2.0/bin/bigslice-models）。 --version 显示BiG-SLiCE的版本信息。 Example 可以使用提供的示例输入文件夹进行“最小化”测试运行：\n下载https://github.com/medema-group/bigslice/tree/master/misc/input_folder_template这个文件夹，里面只有1个dataset，1个genome，2个gbk。\n1 bigslice -i input_folder_template/ test_out/ 这里我遇到了一个问题：\n1 AttributeError: \u0026#39;pyhmmer.plan7.TopHits\u0026#39; object has no attribute \u0026#39;query_accession\u0026#39; 应该是pyhmmer的版本问题，我尝试安装v0.10.7版本后解决：\n1 pip install pyhmmer==0.10.7 通过以上步骤，可以轻松安装并运行 BiG-SLiCE，开始大规模 BGC 聚类分析！我测试了运行了2min，消耗内存160MB\nInput files 为了充分利用BiG-SLiCE的强大功能，其输入的BGC文件需要按数据集和基因组的结构进行组织。一个典型的输入文件夹可能如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 input_folder/ │ ├── datasets.tsv │ ├── dataset_1/ │ ├── genome_1A/ │ │ ├── genome_1A.region001.gbk │ │ ├── genome_1A.region002.gbk │ │ └── ... │ ├── genome_1B/ │ └── ... │ ├── dataset_2/ │ ├── genome_2A/ │ └── ... │ ├── dataset_3/ │ ├── genome_3A/ │ └── ... │ └── taxonomy/ ├── taxonomy_dataset_1.tsv ├── taxonomy_dataset_2.tsv └── ... datasets.tsv 文件 该文件需要严格命名为 datasets.tsv，并放置在输入文件夹的根目录中。它是一个描述所有BGC元数据的文件，BiG-SLiCE使用它来解析输入文件夹中的所有BGC数据。该文件应该是一个以制表符分隔的文件（.tsv），每一行按以下顺序包含以下内容： •\t数据集名称 •\t数据集文件夹的路径（相对于输入文件夹根目录的路径） •\t分类信息文件路径（见 \u0026lt;taxonomy_X.tsv\u0026gt; 文件） •\t数据集描述\n以 # 开头的行将被解析器跳过，因此可以用来定义表头等。可以从代码库下载一个模板 datasets.tsv 文件作为起始点。\n\u0026lt;dataset_X\u0026gt; 文件夹 数据集是BiG-SLiCE中用来分组基因组和BGCs的灵活分类方案。例如，可以根据样本来源将Metagenome-Assembled Genomes（MAGs）归为一个数据集，也可以根据原始文献将基因组和MAGs归类，用于元分析研究。每个数据集文件夹下应直接包含基因组文件夹。\n\u0026lt;genome_X\u0026gt; 文件夹与 \u0026lt;genome_X.regionXXX.gbk\u0026gt; 文件 这些文件夹是由antiSMASH运行产生的输出文件夹，包含 \u0026lt;genome_name\u0026gt;.regionXXX.gbk（antiSMASH 5）或 \u0026lt;genome_name\u0026gt;.clusterXXX.gbk（antiSMASH 4）文件。此外，MIBiG \u0026gt;= 2.0格式的文件（名为 BGCXXXXXXX.gbk，可以通过“Download GenBank summary file”获取）也被BiG-SLiCE接受。请确保不修改这些命名格式，因为BiG-SLiCE依赖它们快速区分集群文件（clustergbks）和常规基因组文件。\n\u0026lt;taxonomy_X.tsv\u0026gt; 文件 虽然可以从antiSMASH 5（和MIBiG \u0026gt;= 2.0）生成的cluster genbank文件中提取分类信息（因为这些文件保留了原始基因组的注释），但这些信息并没有统一的方式来为提供的分类名（通常是分号分隔的 ;）指定等级（如：界、门、纲、目、科、属、种等）。为了确保最佳的注释质量和分析结果，BiG-SLiCE要求用户为每个数据集手动提供分类学元数据（如果可能的话），并以制表符分隔的文件（.tsv）格式包含以下内容（按照此顺序）：\n1 2 3 4 5 6 7 8 Genome folder name (ends with \u0026#39;/\u0026#39;) Kingdom / Domain name Class name Order name Family name Genus name Species name Organism / Strain name 为了确保所有数据集中的分类名称一致，建议使用相同的参考数据库为分类名称指定等级。为了帮助用户自动化这一过程，BiG-SLiCE提供了一些Python脚本，可以基于原始输入基因组（而非集群基因组文件）使用GTDB工具包为分类信息赋予等级（此脚本仅适用于完整的古菌和细菌基因组，下载脚本）。如果基因组来自NCBI RefSeq/GenBank（即具有GCF_*或GCA_*号的基因组），可以使用此脚本从GTDB API提取分类信息。\nOutput 输出文件夹结构：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 test_out/ ├── app │ ├── config.py │ ├── controllers │ ├── __init__.py │ ├── __pycache__ │ ├── run.py │ ├── static │ └── views ├── LICENSE.txt ├── requirements.txt ├── result │ ├── cache │ ├── data.db │ └── tmp └── start_server.sh 直接这样的输出db文件是很难查看的，新版介绍可以用--export-tsv导出表格，\n1 bigslice test_out/ --export-tsv test_out/result_tsv 但是目前有AttributeError: 'tuple' object has no attribute 'values'的报错，官方还没解决。但是可以自己使用sqlite3对结果的data.db文件进行查看和文件导出。\n或者使用用户交互输出：\nBiG-SLiCE的输出文件夹包含处理后的输入数据（以SQLite3数据库文件的形式）以及一些脚本，这些脚本支持一个小型的Web应用程序来可视化这些数据。要运行该可视化引擎，按照以下步骤操作：\n安装Web应用的依赖包： 首先，确保安装了所需的依赖包。运行以下命令来安装requirements.txt中列出的所有依赖： 1 pip install -r \u0026lt;output_folder\u0026gt;/requirements.txt 启动Flask服务器： 然后，通过以下命令启动Flask服务器： 1 bash \u0026lt;output_folder\u0026gt;/start_server.sh \u0026lt;port(可选)\u0026gt; 默认情况下，服务器会在端口5000上启动。如果需要自定义端口，可以在命令中指定端口号。\n打开浏览器访问： 启动服务器后，浏览器将显示如下信息： Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)\n在浏览器中输入 http://0.0.0.0:5000 即可访问Web应用进行数据可视化。\n通过上述步骤，您可以轻松启动BiG-SLiCE的可视化应用，查看处理结果和数据分析图表，如下图所示：\nBGC Atlas 上次提到过的BGC Atlas，那个数据库用的就是BiG-SLiCE的输出结果。该数据库可供下载的有这几个文件：\ncomplete-bgcs.tar.gz A tarball containing the GBK files for only the complete BGC (3.5GB).\nall-bgcs.tar.gz A tarball containing the GBK files for all BGCs (13GB).\nbigslice_2.0.0_T0.4_16April.tar.gz A tarball containing the BiG-SliCE clustering of complete BGCs (2.0 GB).\natlas_17_07_2004.sql The sql dump of the BGC-Atlas database (2.0 GB).\nbigslice_2.0.0_T0.4_16April.tar.gz文件解压后就是BiG-SLiCE的输出文件夹，里面有result文件夹，里面有data.db文件，这个就是BiG-SLiCE处理后的数据库文件。\n另外atlas_17_07_2004.sql里面有所有用到的宏基因组metadata，但它是个PostgreSQL database dump，作为文本文件可以直接打开，但不好转换为数据库或是表格，需要用一下postgresql。\n使用案例 比如我们自己产生的BGC想要和BGC Atlas进行比较，就可以用[模式2] GCF查询：\n1 bigslice --query gbk_files/ --query_name test_MAGs bigslice_2.0.0_T0.4_16April/ -t 8 然后就会在big_slice_test_out目录下产生一个report文件夹（如果原来没有的话），report文件夹下可以找到自己本次运行的结果。可以考虑用户交互输出或用数据库软件查看结果。\n主要是查看distance（membership_value）这一列，按默认定义的话\u0026lt;0.4才可以认为我们的query和数据库已有的部分聚成了GCF。\n然后我们可以查看相应的GCF中有哪些BGCs以及所对应的metadata：\n比如我们的BGC和BGC Atlas中的GCF 13734的distance\u0026lt;0.4，可以认为也是GCF 13734的一员，然后快速的方法是去官网查询https://bgc-atlas.cs.uni-tuebingen.de/bgcs?gcf=13734，可以看到一共有258条核心BGC，我们可以下载相应的metadata（一次最多1000条），然后和我们的进行比较分析。\n但上述方法只适合查询的BGC不多的情况，很多的话最好还是考虑用代码处理atlas_17_07_2004.sql文件，获取metadata，需要使用postgresql进行处理：\n假设你已经会用并成功运行了postgresql（有点难）\n1 2 3 4 5 6 # 运行 brew services start postgresql # 创建 createdb -U asa atlas_db # 导入 psql -U asa -d atlas_db -f atlas_17_07_2004.sql 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 # 查看表 atlas_db=# \\dt List of relations Schema | Name | Type | Owner --------+-------------------------+-------+------- public | antismash_runs | table | asa public | antismash_runs_bk | table | asa public | assembly2biome | table | asa public | assembly2longestbiome | table | asa public | bigscape_clustering | table | asa public | bigscape_networks | table | asa public | bigslice_gcf | table | asa public | bigslice_gcf_membership | table | asa public | biomes | table | asa public | mgnify_asms | table | asa public | mgnify_asms_old | table | asa public | mibig_membership | table | asa public | protoclusters | table | asa public | protoclusters_bk | table | asa public | regions | table | asa public | regions_backup | table | asa public | regions_bk | table | asa public | sample_metadata | table | asa public | sample_metadata_old | table | asa (19 rows) atlas_db=# SELECT * FROM assembly2longestbiome limit 10; assembly | longest_biome --------------+------------------------------------------------- MGYA00002187 | root:Host-associated:Animal:Digestive system MGYA00002188 | root:Environmental:Terrestrial:Soil:Forest soil MGYA00002318 | root:Host-associated:Animal:Digestive system MGYA00002319 | root:Host-associated:Animal:Digestive system MGYA00002320 | root:Host-associated:Animal:Digestive system MGYA00003147 | root:Host-associated MGYA00003148 | root:Host-associated MGYA00004354 | root:Environmental MGYA00004355 | root:Environmental MGYA00004356 | root:Environmental (10 rows) 1 2 #导出csv psql -U asa -d atlas_db -c \u0026#34;COPY assembly2longestbiome TO STDOUT WITH CSV HEADER\u0026#34; \u0026gt; assembly2longestbiome.csv 然后就可以查看csv并和自己的数据整合分析。\nReference Satria A Kautsar, Justin J J van der Hooft, Dick de Ridder, Marnix H Medema, BiG-SLiCE: A highly scalable tool maps the diversity of 1.2 million biosynthetic gene clusters, GigaScience, Volume 10, Issue 1, January 2021, giaa154. https://doi.org/10.1093/gigascience/giaa154\n","date":"2025-02-27T00:00:00Z","image":"https://jb-cao.github.io/Cao-blog/p/big-slice-bgcs/images/bgc_intro_hu_f0edb9cb1296086d.png","permalink":"https://jb-cao.github.io/Cao-blog/p/big-slice-bgcs/","title":"使用BiG-SLiCE高效聚类大规模BGCs"},{"content":"Introduction 抗生素耐药性是对人类健康和疾病临床治疗日益严重的全球性威胁。在过去十年中，已在所有环境中检测到抗生素抗性基因(ARG)，包括自然、工程和临床及栖息地。包括抗生素的临床使用在内的人为活动，被广泛认为是ARGs传播的主要驱动力。很早之前也写过一篇介绍抗生素，ARG以及相应生信分析方法的文章，这里想要介绍一下几篇全球尺度的ARG相关研究，他们已经整理好的数据还可以作为自己研究数据的背景参考。\nARG的全球健康风险评估 这是一篇2022年发表在NC上的文章《Assessment of global health risk of antibiotic resistance genes》，研究者使用4572个宏基因组数据集来揭示2561个ARG及其宿主在全球栖息地的分布和传播。他们实施了一个框架，通过考虑四个指标（人类可及性、流动性、人类致病性和临床可用性）来定量评估每个ARG和样本的健康风险。有23.78%的ARGs对健康构成威胁，尤其是那些具有多重耐药性的ARGs。\n这篇NC用来鉴定ARG的方法是RGI工具+CRAD数据库跑reads，应该是比较常见的做法，文章也提供了所有sample的metadata以及鉴定出来的ARG丰度表，都在https://figshare.com/articles/dataset/Supplementary_Tables/19189652里，可以搞下来和自己的数据比较。\nARG分布的全球模式 研究者用4572个宏基因组样本展示ARG分布全球模式，样本源于空气、水生、陆地、工程、人类和其他宿主六类栖息地。从中依据综合抗生素研究数据库确定2561个ARG，可抵抗24种药物类别抗生素，2401个仅对一种药物耐药，160个对多种药物耐药，25个ARG在超75%样本中被发现，近一半ARGs在不同栖息地共享，表明人为活动对ARGs全球传播很关键。\n人为活动影响ARGs传播方面，按总体人口密度将采样点分两组，高强度活动区域ARG总丰度和特定抗性基因显著更高，不同ARGs与人为活动相关性不同影响其对人类健康风险，后续从人类可及性、流动性、人类致病性和临床可用性四个指标评估ARGs健康风险。\n在ARGs的人类可及性上，检查人类与其他三个主要栖息地共享的ARG，建筑环境与人类栖息地共享最多，多数为多药和β - 内酰胺类药物抗性，确定人类栖息地中ARG的平均丰度和流行率后计算人类可及性，发现只有一小部分ARGs对人类高度可及并有潜在风险。\n对于ARG宿主和移动遗传元件（MGEs）在不同栖息地的分布，实施严格质量标准提高ARGs宿主识别准确性，确定7555个MAG为ARG宿主，个体ARGs宿主在不同生境差异显著，多数宿主特定于一个栖息地，人工和人类相关栖息地宿主不如自然栖息地多样，可能是人为活动选择性压力所致 。\nARG的健康风险评估 研究者分析ARGs特征以确定其人类可及性、流动性和人类致病性，进而评估其从环境转移到人类并推动耐药病原体进化的潜力，还通过系统评估ARGs对人类健康的风险确定其临床相关性。全球抗生素使用数据显示青霉素和头孢菌素这两种β - 内酰胺类抗生素使用最多，在检测到的2561个ARG中，对临床可用抗生素耐药性的基因占比较大。\n研究者用四个计算指标（人类可及性、流动性、人类致病性和临床可用性）评估每个ARG的整体健康风险，除临床可用性外其他指标仅涵盖约一半ARG ，计算风险指数RI = HA × MO × HP × CA 。结果表明抗生素使用增加了ARGs对人类健康的风险并可能导致临床感染治疗失败，属于Q1的ARG数量显著多于其他等级，Q3和Q4的ARGs很少被病原体基因组携带，证明了健康风险评估工作的有效性。基于四个主要栖息地（水生、陆地、工程、与人类相关）发现与人类相关的栖息地构成抗生素耐药性的最高风险 。\n城市微生物群落和ARG的全球宏基因组图谱 《A global metagenomic map of urban microbiomes and antimicrobial resistance》，这是一项关于全球公共室内环境（公共交通工具）微生物图谱的重要研究，于2021年发表在Cell上。\n研究呈现了一个全球地图集，涵盖60个城市公共交通系统的4728个宏基因组样本，是全球首个系统性城市微生物生态系统目录。该图谱包含注释的微生物菌株地理空间信息、功能特征、抗菌素耐药性标记及遗传元素，有10928种病毒、1302种细菌、2种古菌以及838532种未在参考数据库发现的CRISPR序列。研究发现4246种已知城市微生物，97%的样本中有31种不同于人类共生生物的物种；不同城市抗菌素耐药性基因的类型和密度差异明显；城市因气候和地理差异呈现出独特的微生物分类特征。这些结果构成高分辨率全球宏基因组图谱，有助于发现生物体和基因，凸显公共卫生和法医应用潜力，还为城市抗菌素耐药性负担提供了新的视角。\n城市微生物群特征 研究者调查全球城市环境微生物种类分布，发现分类群流行率双峰分布，据此定义亚核心组、外围组和真正核心类群，确定1145种微生物构成亚核心城市微生物群、31种为真正核心微生物群，亚核心群主要是细菌，全球城市常见三个细菌门为变形杆菌、放线杆菌和厚壁菌门。\n虽几乎所有样本都有核心城市微生物群，但城市间在分类和定位上有差异，计算Jaccard距离并使用UMAP降维可视化，发现亚群大致对应气候而非地表类型，功能代谢剖面有地理空间差异，时间可能影响分类变化。MAVRIC分析表明城市是影响分类组成的最重要因素，其次是地区，对分类数据进行PCA分析，两个显著主成分与城市气候有关，样本相似性有邻域效应。\n全球范围内，多数样品含放线菌门、拟杆菌门、厚壁菌门和变形菌门，不同大陆相对丰度有别，功能途径在各大陆间更稳定，抗菌素耐药性种类因大陆而异。比较样本分类剖面和功能剖面距离，分类图谱平均Jensen-Shannon divergence高于功能。\n创建GeoDNA和MetaGraph用于搜索原始序列，训练随机森林分类器预测样本来源，对培训集中未出现的城市特征预测表明城市特异性分类特征可预测样本来源，且城市特有的分类群分布不均，制定分数反映分类群在城市中的流行程度，其分布呈区域和城市双峰分布 。\nARG形成了不同的clsuter 抗生素多样性和AMR的量化是全球抗生素管理的关键，仅从基因序列预测抗生素耐药性有挑战，检测准确性取决于抗生素类别。作为全球城市环境中抗生素耐药性调查的第一步，研究者用MegaRES本体和比对软件将reads映射到已知抗生素耐药性基因，用20类抗生素耐药基因的RPKM量化其相对丰度，2210份样本中部分序列与AMR基因对齐，但无一致的AMR基因核心集。\n常见抗生素耐药基因类别有大环内酯类等，其中MLS仅在部分样本中发现，还量化了耐药基因的可能机制，常见三种耐药机制在一些样本中未发现。抗生素耐药基因丰度普遍低于功能基因，但一些样本含众多不同AMR基因序列，高AMR多样性集群在城市中分布不均，不同城市情况有差异。\n检测到AMR基因的病例平均深度表明整体分布不受读取深度显著影响，训练随机森林模型预测城市分类，其准确率优于随机概率但远低于分类预测器，因AMR基因更具移动性，可能代表较弱的城市特异性特征。此前研究表明质粒可携带大量AMR基因，生态竞争可致同一样本多个类群产生耐药性，在城市环境中研究较少。\n研究者鉴定相同样本中出现的AMR基因簇，测量基因对间Jaccard距离并聚类，发现三个大基因群和许多小基因群，这些集群常由多抗性类别基因组成且大型集群基因更多。对数据集中所有抗性基因集进行稀疏分析（泛抗性组），发现其与被检测物种发现率相似，呈现开放斜率，未来分析可能发现更多抗性基因。此外，AMR基因在地理位置相近样本中表现出邻域效应，同一城市样本的AMR基因组间Jaccard距离随距离增大而增大，总体影响微弱但显著 。\n土壤ARG的全球生物地理学及预测 这是2022年发表在Science Advances上的《Global biogeography and projection of soil antibiotic resistance genes》，该研究生成了一张全球土壤抗生素抗性基因丰度图，其中确定的微生物宿主、农业活动和人为因素解释了印度、东亚、西欧和美国的抗生素抗性基因热点。研究者的结果突显了来自携带抗生素抗性基因的土壤临床病原体的健康威胁，并确定了在全球范围内控制土壤抗生素抗性的重点地区。\n这篇文章用的也是比较常用的软件ARG-OAP跑的reads，应该也是可以方便整合自己的数据的。\n土壤ARG的空间格局 研究者的1088个土壤观测结果显示，共有23种抗生素抗性基因类型和558个亚型。样本中平均有12.42种基因类型和49.24个亚型，多为编码多重耐药性、MLS、万古霉素和膦胺霉素的基因，最常检测到的亚型是mexF 。抗生素抗性基因归一化丰度平均为121.20 ppm，主要由多重耐药性基因主导。\n通过PERMANOVA分析，不同栖息地抗生素抗性基因组成存在显著差异，农业栖息地丰度较高，不同大陆间也有明显差异，澳大利亚最丰富，且从低纬度到极地丰度呈增加趋势。研究者鉴定出9种可移动遗传元件类型和157个亚型，有助于土壤抗生素抗性基因的存在和持久性。其总归一化丰度平均为55.26 ppm，转座酶占主导。抗生素抗性基因归一化丰度与多种可移动遗传元件显著相关。\n土壤微生物归一化丰度平均为232,179.53 ppm，细菌是主导分类群，变形菌门在门水平上占优，放线菌门次之 。研究者鉴定出携带抗生素抗性基因或可移动遗传元件的微生物占总物种的20.97%，但归一化丰度仅1.36%。这些微生物宿主涵盖多个分类层级，其组成与土壤微生物群落组成有差异，在各分类水平上都有不同表现，且抗生素耐药微生物组中一些物种是多重耐药基因和转座酶的核心宿主，抗生素抗性基因及其微生物宿主、可移动遗传元件及其微生物宿主之间均呈正相关 。\n土壤ARG的地理驱动因素 为研究土壤抗生素抗性基因丰度空间模式的地理机制，研究者将潜在环境约束整合到16个主成分中，抗生素抗性基因丰度变异性主要受与人类活动相关主成分（57.52%）控制，代表人类输入、畜牧业和农业污染的贡献，气候和植被（17.18%）及土壤养分（7.07%）主成分贡献较小，且气候和植被因素影响相互关联。\n分析表明抗生素抗性基因丰度与多数人为因素呈正向关联，如畜牧业生产随其丰度增加而显著增加，土壤养分增加在中等范围内会提高丰度，气候参数影响较复杂，温度降低丰度减少，降水增加丰度增加。\n通过结构方程模型检查地理属性对抗生素抗性基因归一化丰度的因果效应，发现其影响通过微生物因素介导，人为因素引入携带相关基因和元件的微生物间接提高丰度，气候变量也通过土壤养分等多种因素间接影响。\n研究者利用169个空间协变量，基于四种机器学习算法预测土壤抗生素抗性基因归一化丰度，经优化后随机森林最优，构建了0.083°分辨率的归一化丰度图谱，显示西欧、东亚、南亚和美国东部等地丰度最高，高纬度地区也有较高丰度，与纬度梯度一致，应用变异系数量化不确定性，在西伯利亚等地显示较高不确定性，但模型表现稳健。\nReferences Zhang, Z. et al. Assessment of global health risk of antibiotic resistance genes. Nat. Commun. 13, 1553 (2022). Danko, D. et al. A global metagenomic map of urban microbiomes and antimicrobial resistance. Cell 184, 3376-3393.e17 (2021). Zheng, D. et al. Global biogeography and projection of soil antibiotic resistance genes. Sci. Adv. 8, eabq8015 (2022). ","date":"2025-02-27T00:00:00Z","image":"https://jb-cao.github.io/Cao-blog/p/global-arg/images/global1_hu_ce047fe4cd684104.png","permalink":"https://jb-cao.github.io/Cao-blog/p/global-arg/","title":"全球尺度的抗生素耐药基因（ARG）研究"},{"content":"Introduction 次级代谢产物（Secondary Metabolites）是微生物在生长过程中产生的非必需化合物，尽管对微生物自身的生长发育并非不可或缺，却在生态和生理功能中扮演着重要角色。这些化合物在医药、生物技术和农业领域具有广泛的应用潜力。它们的合成由生物合成基因簇（Biosynthetic Gene Clusters, BGCs）编码，这些基因簇共同指导次级代谢产物的生物合成。随着宏基因组学技术的发展，研究人员能够直接从环境样本中研究BGCs，发现了许多编码全新化学结构的未知基因簇。\n上次介绍过一下生物合成基因簇家族（GCF）相关的Big-Fam数据库，但它的源数据来自培养的微生物基因组或存放在公共存储库中的MAG的数据。而且它不提供相应数据的下载，上传还是AntiSmash的id，想要跟自己宏基因组产生的大量BGCs比较不太可能。\n本文介绍一个比较新的名为BGC Atlas的网络资源（https://bgc-atlas.cs.uni-tuebingen.de），它为探索和分析宏基因组中的BGC多样性提供了便捷的工具。该工具最近发表在了NAR上：\nCaner Bağcı, et.al, BGC Atlas: a web resource for exploring the global chemical diversity encoded in bacterial genomes, Nucleic Acids Research, Volume 53, Issue D1, 6 January 2025, Pages D618–D624, https://doi.org/10.1093/nar/gkae953\nBGC Atlas从公开数据集中识别并聚类BGCs，提供了一个集中化的数据库和网络界面，支持基于元数据的BGC和基因簇家族（Gene Cluster Families, GCFs）的探索。通过对MGnify平台上超过35,000个数据集的分析，BGC Atlas识别了近180万个BGCs，并将其聚类为GCFs。分析结果显示，核糖体合成并经翻译后修饰的肽类（RiPPs）是最丰富的化合物类别，且大多数GCFs表现出高度的环境特异性。\nDatabase 数据收集与预处理 研究者从公共数据库MGnify收集了宏基因组数据集及其对应的元数据。这些数据集涵盖了海洋、土壤、人体相关及其他环境样本。对于每个样本，研究者获取了FASTA格式的组装contigs以及描述样本环境和生物学背景的元数据（上图）。\nBGC识别 使用antiSMASH（版本7.0.0）识别BGCs，参数设置为--clusterhmmer --tigrfam --asf --cc-mibig --cb-subclusters --cb-knownclusters --pfam2go --rre --tfbs --genefinding-tool prodigal-m --allow-long-headers。antiSMASH提供了全面的注释信息，包括次级代谢产物类型、预测的化学结构和功能域，并构建了antiSMASH-DB用于存储和比较BGCs。\nBGC聚类 使用BiG-SLiCE（版本2.0.0）将BGCs聚类为基因簇家族（GCFs），基于序列相似性和域结构进行分组，形成非冗余的GCFs集合（上图）。聚类过程分为两步：\n初始聚类：对antiSMASH标注为完整的BGCs进行聚类，距离阈值为0.4，确保核心簇定义明确。 部分BGCs分配：将antiSMASH标注为“on contig edge”的部分BGCs和MIBiG数据库中的已知化合物分配到预定义的簇中，距离阈值同样为0.4，保留最佳匹配结果。 数据库与网络界面 BGC识别和聚类结果存储在PostgreSQL数据库中，支持复杂查询和高效数据管理。研究者还开发了BGC Atlas的网络界面，基于node.js、express、pug、leaflet和bootstrap构建，提供以下功能：\nBGC和GCF探索：浏览BGCs、查看详细注释及其在不同环境中的分布。 元数据整合：将BGC数据与环境元数据结合，支持生态和进化分析。 查询功能：用户可输入BGC序列，使用BiG-SLiCE查询模式在数据库中搜索相似簇，结果以表格形式展示输入BGC与最接近GCF的距离。 BGC Atlas 提供了多种视图和功能，用于探索宏基因组样本、BGCs 和 GCFs。所有视图均支持基于自由文本或元数据特征的搜索和过滤。通过“Filter”菜单，用户可以使用布尔逻辑组合多个条件进行查询，例如搜索来自“Arctic”（地理位置特征）环境的“Marine”（生物群落特征）BGCs。\nSamples 视图：展示所有分析样本及其元数据特征，用户可通过antiSMASH界面进一步探索这些样本。 BGCs 视图：显示数据库中所有BGCs的表格，支持过滤功能以进行更具体的查询。 GCFs 视图：展示所有GCFs的表格，选择特定GCF后，“BGCs”视图将仅显示该GCF的成员BGCs。 这种设计使用户能够在不同视图之间切换，结合详细注释和分布信息，深入比较分析BGCs及其所属GCFs，并通过元数据探索其生态学意义（上图）。\nResult BGC结构类别的分布 研究者对MGnify的35,486个数据集进行了初步分析，发现了约185万个BGCs，分布于多种环境样本中。其中，绝大多数（88.7%）BGCs被antiSMASH标注为“on contig edge”，表明它们的不完整性，这主要是由于宏基因组测序通常产生较短的contigs。尽管如此，超过一半（51.7%）的BGCs长度仍超过5 kb，完整BGCs的中位长度约为21 kb。\n在分析的BGCs中，核糖体合成并经翻译后修饰的肽类（RiPPs）占比最高（52.3%），其中环内酯自诱导物是最常见的产物类型（16.5%）。RiPPs的高比例可能与数据库中宿主相关样本的过度代表性有关。多项研究表明，RiPPs是人类微生物组中最常见的BGC类别，特别是在乳酸菌基因组中，其占比可高达76%。其他显著的结构类别包括萜类、非核糖体肽和聚酮类，这些类别共同构成了宏基因组中观察到的化学多样性。研究者还发现，不同生物群落中产物类别的分布存在显著差异。例如，萜类主要存在于陆地环境样本中，而RiPPs在宿主相关样本中最为丰富。\n基因簇家族（GCFs）的栖息地特异性 聚类分析显示，GCFs表现出显著的栖息地特异性，表明某些BGCs适应了特定的环境条件。总体而言，76%的GCFs（至少包含5个BGC成员）仅存在于一种特定栖息地中，这强调了微生物次级代谢的生态专一性。\n在MGnify生物群落分类的第一层级（宿主相关、环境、工程和混合）中，几乎所有GCFs都局限于某一特定类别。这种高度特异性在第二层级（如宿主相关样本中的人类、哺乳动物和鸟类）中依然存在，表明大多数GCFs对特定宿主类型具有专一性。在第三层级（如人类样本中的消化系统与皮肤），这种趋势继续延续，表明GCF特异性甚至延伸到宿主体内的不同部位。然而，随着分类的细化，栖息地特异性逐渐减弱。例如，在第四层级（如人类消化系统中的大肠与后肠），GCFs的专一性下降，表明某些GCFs虽然适应了更广泛的环境（如人类消化系统），但也可能存在于更细分的生态位中。\n在环境样本中也观察到了类似的模式。这些样本在第一层级被广泛分类，而在第二层级（如水生与陆地）中，大多数GCFs仍然高度特异性于这些不同的环境类型。在第三层级（如水生样本中的淡水与海洋），GCFs仍然主要特异性于特定的水生栖息地。然而，到了第四层级（如淡水样本中的地下水、静水与流水），栖息地特异性开始减弱，表明某些GCFs虽然适应了更广泛的水生环境，但也可能存在于更狭窄的亚栖息地中。\n对某些GCFs的详细分析揭示了显著的栖息地特异性模式。例如，GCF2487（一种萜类生产簇）仅在全球的河口样本中发现，凸显了其对该特定环境的适应性。另一方面，GCF12495（一种长度约50 kb的非核糖体肽合成酶BGC家族）仅在来自欧洲、东南亚和北美的哺乳动物粪便样本中被发现。这些特异性BGCs的生态作用表明，微生物可能采用了特定的适应策略以在其各自环境中繁衍生息。\nReference Caner Bağcı, Matin Nuhamunada, Hemant Goyat, Casimir Ladanyi, Ludek Sehnal, Kai Blin, Satria A Kautsar, Azat Tagirdzhanov, Alexey Gurevich, Shrikant Mantri, Christian von Mering, Daniel Udwary, Marnix H Medema, Tilmann Weber, Nadine Ziemert, BGC Atlas: a web resource for exploring the global chemical diversity encoded in bacterial genomes, Nucleic Acids Research, Volume 53, Issue D1, 6 January 2025, Pages D618–D624, https://doi.org/10.1093/nar/gkae953\n","date":"2025-02-26T00:00:00Z","image":"https://jb-cao.github.io/Cao-blog/p/bgc-atlas/images/bgc_atlas_hu_e67fd961d5af35af.png","permalink":"https://jb-cao.github.io/Cao-blog/p/bgc-atlas/","title":"BGC Atlas助力宏基因组中生物合成基因簇的发现与分析"},{"content":"Introduction 在微生物组学研究中，基因组binning（分箱，即将测序数据中的reads或contigs分类到不同的基因组中）是一个关键步骤。发表于2018年的MetaWRAP一直没有重大更新，这篇文章将介绍一个较新的binning流程：BASALT及其具体使用方法。\nBASALT （Binning Across a Series of AssembLies Toolkit）是一个高效的基因组binning工具，旨在处理复杂的微生物组数据，特别是在多个组装（assemblies）之间进行binning时表现出色。它通过整合多个组装结果，提高了binning的准确性和完整性，尤其适用于处理高度复杂的微生物群落数据。\nBASALT的文章于2024年发表于Nature Communications，软件主页：https://github.com/EMBL-PKU/BASALT。以下是BASALT的主要工作流程模块：\n功能模块 BASALT由四个模块组成：自动分箱（Automated Binning）、分箱选择（Bin Selection）、优化（Refinement）和缺口填充（Gap Filling）。以下是各模块的详细工作流程：\n自动分箱模块\n首先，通过多个分箱工具（每个工具使用不同的阈值）将组装的contigs分类到不同的bin中，生成初始的binsets。接着，通过识别contig ID，将包含相似contig的bin合并为混合bin（hybrid bins）。然后，基于平均核苷酸一致性（ANI）对这些混合binsets进行分组，并通过覆盖度估计（coverage estimation）识别每组中的核心序列（Core sequence identification, CSI），用于比较组内每对bin中的内部序列（inliers）。随后，使用神经网络算法识别冗余bin，并保留非冗余bin用于后续的离群值去除（Outlier removal, OR）。\n分箱选择模块\n在优化模块中，结合四核苷酸频率（Tetranucleotide Frequency, TNF）和覆盖度相关系数（Coverage Correlation Coefficient, CCC），通过多维内部四分位距（Multidimensional Internal Quartile Range, IQR）检测来识别离群序列（outlier sequences）。接着，通过序列检索步骤（sequence retrieval），利用双端测序（Pair-End, PE）或长读长追踪（Long-Read Tracking）将未分箱的内部序列（un-binned inliers）从短读长（SR）和长读长（LR）contig池中连接并重新迭代，从而生成优化后的bin。成功映射到优化bin的reads会进一步进行抛光（polishing），生成抛光后的bin。\n优化模块\n在优化模块的最后一步，通过受限的重叠-布局-一致性程序（restrained Overlap–Layout–Consensus program, rOLC），将优化/抛光后的bin与相应的冗余bin进行重叠，然后在短读长（SRS）和长读长（LRS）数据的基础上进行重新组装。重新组装的bin会进一步抛光，并经过另一轮rOLC处理，最终生成最终的bin-set。\n缺口填充模块\n在缺口填充模块中，长读长测序数据（+LRS）可以用于补充和完善bin中的缺口区域，进一步提高bin的完整性和准确性。\n效果评估 利用CAMI数据集评估BASALT的性能 采用Critical Assessment of Metagenome Interpretation （CAMI）中的CAMI-high数据。使用二代+三代数据混装产生的组装文件，BASALT可以恢复其中的392个满足完整度 ≥ 50，污染度 ≤ 10的MAGs。经过基因组选择、优化和空缺填补每一个模块处理后，所产生的MAGs无论从完整度（Completeness）、污染度（Contamination）和总质量（完整度-5*污染度）上都有很大的提升。\n与其他主流软件的比较 在MAGs（宏基因组组装基因组）的评估中，采用了更为严格的质量标准，即质量值（完整度 - 5 × 污染度）≥ 50。通过对比VAMB、DASTool、metaWRAP和BASALT四个软件的处理结果，发现BASALT的表现显著优于其他工具。具体而言，BASALT比VAMB、DASTool和metaWRAP分别多获得了63.7%、61.5%和33.3%的MAGs，其中包括69个独有的MAGs（图a）。\n在四个软件共同获得的168个MAGs中，BASALT生成的基因组质量也显著高于其他软件（图b）。两两比较的结果进一步显示，BASALT生成的MAGs质量普遍优于其他工具。具体来说，BASALT生成的质量更好的MAGs数量分别是VAMB的9.6倍、DASTool的14.6倍和metaWRAP的6.1倍（图c）。\n此外，在高质量MAGs（质量值 \u0026gt; 90）的获取方面，BASALT的表现同样突出。与VAMB、DASTool和metaWRAP相比，BASALT获得的高质量MAGs数量分别是它们的2.28倍、3.59倍和2.02倍（图d）。\n真实数据集评估 除了测试数据集外，作者团队还选用了十个真实数据集，包括SRS（短读长测序）、SRS+LRS（短读长+长读长测序）以及LRS（HiFi长读长测序）数据，涵盖了盐湖沉积物、人类肠道、海水、南极土壤、活性污泥（AS）、鸡肠道、羊肠道、热泉、厌氧反应器（AD）等多种环境类型。以高度复杂的盐湖沉积物微生物群落样本为例（仅使用二代测序数据），BASALT比metaWRAP多获得了30%的MAGs，尤其在恢复低丰度MAGs方面表现出显著优势（图a）。在功能注释分析中，BASALT比metaWRAP多获得了47.6%的非冗余开放式阅读框（ORF）序列（图b），使得BASALT恢复的MAGs在功能模块上更加完整（图c）。\n从盐湖沉积物样品中，BASALT共获得了557个MAGs，涵盖了54个门；而metaWRAP仅识别了392个MAGs，涵盖45个门，且这些门均被BASALT检测到（图5）。此外，BASALT独特地识别出了metaWRAP未能发现的9个门，其中包括21个纲水平上的细菌分支和2个目水平上的古菌分支（红色高亮分支）。这些独特的分支为挖掘复杂环境中未被探索的微生物及其功能元件提供了重要线索，进一步拓展了对微生物多样性和功能潜力的理解。\n使用方法 安装 由于需要安装许多依赖项，推荐使用conda安装和管理BASALT，命令耗时较长，需要耐心等待：\n1 2 3 4 5 # 我这里安装到~/biosoft/目录 cd ~/biosoft/ git clone https://github.com/EMBL-PKU/BASALT.git cd BASALT conda env create -n BASALT --file basalt_env.yml 然后要授权BASALT脚本。一般来说conda BASALT环境位于conda安装的子目录envs中。\n1 chmod -R 777 ~/miniconda3/envs/BASALT/bin/* 然后下载神经网络训练模型，可以直接用1脚本下载，如果网络不好可以手动下载（或者在浏览器下载好再ftp上传到服务器）：\n1 2 3 4 5 6 7 8 9 # 1.脚本下载训练模型 python BASALT_models_download.py # 2.手动下载训练模型 wget https://figshare.com/ndownloader/files/41093033 mv 41093033 BASALT.zip mv BASALT.zip ~/.cache cd ~/.cache unzip BASALT.zip 后续一般会用到checkM，所以也最好按照上一篇文章下载配置一下相应数据库：\n1 2 # 设置CheckM数据存储位置 checkm data setRoot ~/db/checkm 除上述conda方法外，还可以使用脚本直接安装或是利用singularity运行等方法，可参考https://github.com/EMBL-PKU/BASALT。\n测试数据 作者团队准备了测试文件以测试BASALT是否成功安装并且可以顺利运行。从https://figshare.com/articles/dataset/BASALT_demo_files/22323424下载测试文件（共三个：Data.tar.gz、Final_bestbinset.tar.gz、basalt.sh），然后执行下面的命令运行程序（该过程耗时大约六小时）：\n1 2 3 4 unzip 22323424.zip tar zxvf Data.tar.gz cd Data/ BASALT -a assembly.fa -s sample1.R1.fq,sample1.R2.fq -l sample1.nanopore.fq -t 16 -m 300 命令参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 用法: BASALT [-h] [-a ASSEMBLIES] [-s SR_DATASETS] [-l LONG_DATASETS] [-hf HIFI_DATASETS] [-c HI_C_DATASET] [-t THREADS] [-m RAM] [-e EXTRA_BINNER] [-qc QUALITY_CHECK] [--min-cpn MIN_COMPLETENESS] [--max-ctn MAX_CONTAMINATION] [--mode RUNNING_MODE] [--module FUNCTIONAL_MODULE] [--autopara AUTOBINING_PARAMETERS] [--refinepara REFINEMENT_PARAMTER] -h, --help 显示帮助信息并退出。 -a ASSEMBLIES, --assemblies ASSEMBLIES 组装序列文件列表，例如：`as1.fa,as2.fa`。 -s SR_DATASETS, --shortreads SR_DATASETS 双端测序数据列表，例如： `r1_1.fq,r1_2.fq/r2_1.fq,r2_2.fq`（双端数据需使用`/`分隔）。 注意，这里不是随便什么路径，要求一定要在同一个文件夹下。 -l LONG_DATASETS, --longreads LONG_DATASETS 包含ONT和PacBio长读长数据（不包括HiFi数据）。 例如：`lr1.fq,lr2.fq`。 -hf HIFI_DATASETS, --hifi HIFI_DATASETS HiFi测序数据，例如：`hf1.fq,hf2.fq`。 -c HI_C_DATASET, --HIC HI_C_DATASET Hi-C测序数据列表，例如：`hc1.fq,hc2.fq`。 -t THREADS, --threads THREADS 线程数，例如：`64`。 -m RAM, --ram RAM 内存大小，最低建议`32G`。 -e EXTRA_BINNER, --extra_binner EXTRA_BINNER 额外的分箱工具： `m`：MetaBinner `v`：Vamb 例如：`-e m`表示在默认使用MetaBAT2、MaxBin2和CONCOCT的基础上，额外使用MetaBinner进行分箱。 -qc QUALITY_CHECK, --quality-check QUALITY_CHECK 选择CheckM版本，默认`checkm`，可指定`checkm2`，例如： `-qc checkm2`用于质量检查。 --min-cpn MIN_COMPLETENESS 过滤保留bin的最小完整度（默认`35`）。 --max-ctn MAX_CONTAMINATION 过滤保留bin的最大污染度（默认`20`）。 --mode RUNNING_MODE 运行模式： `new`：新建项目 `continue`：继续运行 例如：`--mode continue` / `--mode new`。 --module FUNCTIONAL_MODULE 运行的功能模块（默认运行所有模块）： `autobinning`：自动分箱 `refinement`：分箱优化 `reassembly`：重新组装 例如：`--module reassembly` 仅运行重新组装模块。 --autopara AUTOBINING_PARAMETERS 自动分箱模式： `more-sensitive`（默认） `sensitive` `quick` 例如：`--autopara sensitive`。 --refinepara REFINEMENT_PARAMTER 分箱优化参数： `deep`（默认） `quick` 例如：`--refinepara quick`。 BASALT支持单一组装文件或多组装文件进行binning；在样品的物种非常相似，但群落中物种丰度不同的情况下，如时间序列样品，多组装文件可大幅度提高binning的效果，但也可能会导致运算时间过长，但作者推荐用多组装文件模式进行分箱分析。如果运算资源不足，推荐使用多组数据进行合并组装的组装文件进行后续的分箱分析。\n单独使用二代测序数据进行 binning 及修正，比较常用 1 BASALT -a as1.fa,as2.fa,as3.fa -s ds1_r1.fq,d1_r2.fq/d2_r1.fq,d2_r2.fq -t 60 -m 250 使用二代测序数据及三代测序数据进行 binning 及修正 1 BASALT -a as1.fa,as2.fa,as3.fa -s ds1_r1.fq,d1_r2.fq/d2_r1.fq,d2_r2.fq -l lr1.fq,lr2.fq -t 60 -m 250 使用 HiFi 数据及二代测序数据进行 binning 及修正 1 BASALT -a as1.fa -hf hifi1.fq -s ds1_r1.fq,d1_r2.fq -t 60 -m 250 使用 BASALT 进行基因组的获取，并融合已有的基因组数据 1 BASALT -a as1.fa,as2.fa,as3.fa -s ds1_r1.fq,d1_r2.fq/d2_r1.fq,d2_r2.fq -d m_binset -t 60 -m 250 使用 BASALT 进行外源数据基因组的去冗余 (a) 数据输入（Data feeding）\n1 BASALT -s sample1.R1.fq,sample1.R2.fq/sample2.R1.fq,sample2.R2.fq -d mbin,dbin -t 60 -m 250 该命令会生成 Date_feeded 文件夹，其中包含：\n修改 index 后的组装文件，如 500_mbin.fa 基因组文件夹，如 500_mbin.fa_BestBinsSet 覆盖率文件，如 Coverage_matrix_for_binning_500_mbin.fa.txt 修改格式后的 reads 文件 (b) 基因组去冗余（De-replication）\n1 2 3 4 BASALT -b 500_mbin.fa_BestBinsSet,501_dbin.fa_BestBinsSet \\ -c Coverage_matrix_for_binning_500_mbin.fa.txt,Coverage_matrix_for_binning_501_mbin.fa.txt \\ -a 500_mbin.fa,501_mbin.fa \\ -s sample1.R1.fq,sample1.R2.fq/sample2.R1.fq,sample2.R2.fq -t 60 该命令输入多个基因组文件夹、组装文件、reads 和覆盖率文件，最终生成去冗余后的基因组文件夹 BestBinset。\n使用 BASALT 进行基因组的修正 1 2 3 4 BASALT -r BestBinset \\ -c Coverage_matrix_for_binning_500_mbin.fa.txt,Coverage_matrix_for_binning_501_mbin.fa.txt \\ -a 500_mbin.fa,501_mbin.fa \\ -s PE_r1_sample1.R1.fq,PE_r2_sample1.R2.fq/PE_r1_sample2.R1.fq,PE_r2_sample2.R2.fq -t 60 该命令会生成 BestBinset_outlier_refined 文件夹，存储优化后的基因组。\n具体示例 项目背景 在鸟类生长的不同阶段，采集了若干种鸟类的粪便样本，通过宏基因组二代测序分析它们的微生物组。每个样本根据鸟类不同的生长周期进行了采集，并使用 metaspades 软件对数据进行单个样本的组装。在得到单个样本的组装结果后，进一步对同种鸟类在同一生长周期的多个平行样本的数据进行合并组装，以便获取更丰富的群落信息，辅助后续的分箱处理。\n组装策略 单个样本组装：使用 metaspades 对每个鸟类在不同生长周期的粪便样本进行单样本组装。 多样本合并组装：将同一生长周期、同种鸟类的多个平行样本进行合并组装，以提高组装的完整性和准确性。 分箱处理：在完成组装后，进行基于二代测序数据的分箱，获取更准确的基因组信息。 以A鸟样本为例\n样本数据：\nA类鸟阶段1样本：\nsampleA_s1_1_R1.fq, sampleA_s1_1_R2.fq sampleA_s1_2_R1.fq, sampleA_s1_2_R2.fq sampleA_s1_3_R1.fq, sampleA_s1_3_R2.fq A类鸟阶段2样本：\nsampleA_s2_1_R1.fq, sampleA_s2_1_R2.fq sampleA_s2_2_R1.fq, sampleA_s2_2_R2.fq sampleA_s2_3_R1.fq, sampleA_s2_3_R2.fq A类鸟阶段3样本：\nsampleA_s3_1_R1.fq, sampleA_s3_1_R2.fq sampleA_s3_2_R1.fq, sampleA_s3_2_R2.fq sampleA_s3_3_R1.fq, sampleA_s3_3_R2.fq 组装结果：\n阶段1单样品组装结果： sampleA_s1_1_assembly.fa, sampleA_s1_2_assembly.fa, sampleA_s1_3_assembly.fa 阶段2单样品组装结果： sampleA_s2_1_assembly.fa, sampleA_s2_2_assembly.fa, sampleA_s2_3_assembly.fa 阶段3单样品组装结果： sampleA_s3_1_assembly.fa, sampleA_s3_2_assembly.fa, sampleA_s3_3_assembly.fa 阶段1多样品合并组装结果： sampleA_s1_assembly.fa 阶段2多样品合并组装结果： sampleA_s2_assembly.fa 阶段3多样品合并组装结果： sampleA_s3_assembly.fa 分箱命令：\n阶段1样品分箱命令： 1 2 3 BASALT -a sampleA_s1_assembly.fa, sampleA_s1_1_assembly.fa,sampleA_s1_2_assembly.fa,sampleA_s1_3_assembly.fa \\ -s sampleA_s1_1_R1.fq,sampleA_s1_1_R2.fq/sampleA_s1_2_R1.fq,sampleA_s1_2_R2.fq/sampleA_s1_3_R1.fq,sampleA_s1_3_R2.fq \\ -t 60 -m 250 注意事项 输入输出 BASALT的程序输入 -a,-s等参数不是任意文件的路径，而是要把这些文件放置到脚本运行同一文件夹下，因为\u0026rsquo;/\u0026lsquo;已经被用作文件之间的分隔符了。并且BASALT还不能设定输出路径，在输出时候自动将结果及重要过程文件输出至当前工作路径下，建议用户将需要分析的文件单独建立文件夹存放和运行BASALT，以免重复输出覆盖原有结果。用起来有点麻烦。\n运行速度 在使用单个组装文件时，BASALT的完整流程耗时通常比metaWRAP长，尤其随着样品复杂度的增加，耗时差异会更加显著。然而，文章中也提到，即便不运行gap filling模块，BASALT在基因组质量和数量上通常优于metaWRAP。实际上，在多个组装文件输入模式下，BASALT的效率反而高于metaWRAP，因为BASALT仅需运行一次，且其单独组装、合并组装和去冗余的流程有助于大大提高非冗余基因组的产出。如果用户对基因组的深度挖掘需求不高，且需要加速分箱过程，以下几种策略可能会有所帮助：\n使用MetaBAT2 + Semibin2作为初始Binners：这可以显著加快auto-binning的过程。 只运行auto-binning、bin selection和refinement模块：跳过gap filling模块可以有效减少运行时间。 仅使用合并组装文件：在同时输入多个样品时，使用单一的合并组装文件（例如：sampleA1A2A3_assembly.fa）可以减少auto-binning的计算时间，但也可能会减少基因组的产出量。 References Qiu, Z., Yuan, L., Lian, CA. et al. BASALT refines binning from metagenomic data and increases resolution of genome-resolved metagenomic analysis. Nat Commun 15, 2179 (2024). https://doi.org/10.1038/s41467-024-46539-7 https://github.com/EMBL-PKU/BASALT https://mp.weixin.qq.com/s/TlxaiQGjoiE3c0Onqatu8A ","date":"2025-02-18T00:00:00Z","image":"https://jb-cao.github.io/Cao-blog/p/binning3/images/workflow_hu_6cddfa5cd6ddc464.png","permalink":"https://jb-cao.github.io/Cao-blog/p/binning3/","title":"宏基因组分箱（binning）｜3. BASALT优化binning流程"},{"content":"Introduction 上次记录了一下qiime2的扩增子分析流程。但是实际使用时，在最后一步物种注释时卡住了，如果使用常用的feature-classifier方法，我尝试使用unite数据库鉴定了100条ITS序列，居然用了半个小时！尴尬的是，我有整整10万条ASV序列，这得跑到猴年马月。我想到做宏基因组时，千万级数量的reads用kraken做物种注释也不需要这么久，肯定有快的方法的。\n然后发现Kraken用于16S已经有文章了： Lu, J., Salzberg, S.L. Ultrafast and accurate 16S rRNA microbial community analysis using Kraken 2. Microbiome 8, 124 (2020). https://doi.org/10.1186/s40168-020-00900-2\nKraken 2现在支持16S rRNA数据库，可以直接与QIIME和类似系统进行比较。Kraken 2通过其独特的无对齐算法，能够在极短的时间内完成大量序列的分类，并且支持多线程处理，显著提升了分析效率。此外，Kraken 2还结合了Bracken工具，能够更精确地估计物种的相对丰度，尤其是在处理复杂微生物群落时表现出色。\n但是Kraken2要用在ITS上的话目前是官方没有支持的，需要手动构建相应数据库，这个折腾了一会，具体方法放在后面了。\nKraken效果 速度快 Kraken 2在速度上的表现非常突出。根据Lu和Salzberg的研究，Kraken 2在生成16S rRNA数据库时，比QIIME 2快得多。例如，使用单线程时，Kraken 2生成Greengenes数据库仅需9分钟，而QIIME 2则需要78分钟。对于更大的SILVA数据库，Kraken 2仅需34分钟，而QIIME 2则需要超过58小时。在分类速度上，Kraken 2同样表现出色，单线程下仅需1分钟即可完成一个样本的分类，而QIIME 2则需要35分钟（使用16线程时）。对于大规模数据分析，Kraken 2的速度优势尤为明显，能够显著缩短分析时间。\n更精确 Kraken 2不仅在速度上占优，其分类精度也优于QIIME 2。研究显示，Kraken 2在分类16S rRNA序列时，能够更准确地识别物种，尤其是在处理复杂微生物群落时。Bracken工具进一步提升了Kraken 2的精度，能够更准确地估计物种的相对丰度。通过重新分配Kraken 2在属或更高分类水平上的分类结果，Bracken能够将分类结果细化到种水平，从而提供更精确的物种丰度估计。此外，Kraken 2的每读长分类功能使其能够为每个读长提供详细的分类信息，进一步提高了分析的准确性。\n总的来说，Kraken 2和Bracken的组合为16S rRNA数据分析提供了一个快速、高效且精确的解决方案，特别适合处理大规模微生物群落数据。\nKraken-16S Kraken2是直接支持16S常用的三大数据库的(greengenes，rdp，silva)，用起来也非常简单：\n1 2 3 4 5 6 7 8 9 10 11 12 #直接构建数据库，TYPE可选greengenes，rdp，silva kraken2-build --db $DBNAME --special TYPE #构建完成后就可以鉴定了，内存够的话，1min内都有结果 kraken2 rep-seqs/dna-sequences.fasta --db $DBNAME --out kraken_output --threads 4 --report kraken_report.txt -c 0.05 #可以借助taxonkit得到类似qiime2标准注释文件 cut -f3 kraken_output \u0026gt;tmpid taxonkit lineage tmpid --data-dir $DBNAME/taxonomy/|taxonkit reformat --data-dir $DBNAME/taxonomy/ -P \u0026gt;tmpres paste kraken_output tmpres |cut -f2,8\u0026gt;kraken_taxonomy rm tmpid tmpres Kraken-ITS ITS一般用Unite数据库注释，但这个kraken2不支持，我尝试将Unite数据库整理为greengenes的格式，然后用build_gg_taxonomy.pl生成names.dmp, nodes.dmp, seqid2taxid并建立kraken数据库，最后进行ITS序列鉴定是可行的。\n具体步骤如下：\nUnite官网下载fasta文件，https://unite.ut.ee/repository.php ，点击General FASTA release下载解压，我用的是sh_general_release_dynamic_all_04.04.2024.fasta文件。\n运行以下命令建立数据库，注意split_fasta.py和build_gg_taxonomy.pl在后面，记得拷贝过去用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # 手动构建目录结构 mkdir ~/db/kraken_unite/ pushd ~/db/kraken_unite/ mkdir -p data taxonomy library pushd data # 用split_fasta.py把unite数据库提供的fasta格式整理为greengenes的 GG_VERSION=unite_all_04.04.2024 ./split_fasta.py -i ../sh_general_release_dynamic_all_04.04.2024.fasta -o ${GG_VERSION} # 用build_gg_taxonomy.pl进一步生成names.dmp, nodes.dmp, seqid2taxid perl ../build_gg_taxonomy.pl \u0026#34;${GG_VERSION}_taxonomy.txt\u0026#34; popd mv data/names.dmp data/nodes.dmp taxonomy/ mv data/seqid2taxid.map . mv \u0026#34;data/${GG_VERSION}.fa\u0026#34; library/unite.fna popd # 用kraken2-build构建用于注释的数据库 kraken2-build --db ~/db/kraken_unite --build --threads 4 鉴定获得output文件 1 2 #1秒出结果 kraken2 rep-seqs/dna-sequences.fasta --db ~/db/kraken_unite/ --out kraken_output --threads 4 --report kraken_report.txt -c 0.05 借助taxonkit获取标准注释文件，taxonkit这软件也很好用。 1 2 3 4 5 cut -f3 kraken_output \u0026gt;tmpid taxonkit lineage tmpid --data-dir ~/db/kraken_unite/taxonomy/|taxonkit reformat --data-dir ~/db/kraken_unite/taxonomy/ -P \u0026gt;tmpres paste kraken_output tmpres |cut -f2,8\u0026gt;kraken_taxonomy rm tmpid tmpres 最后的结果就是类似下面的形式：\n1 2 3 0229a5c7f887dad960b40a0505cf9776\tk__Fungi;p__Ascomycota;c__Saccharomycetes;o__Saccharomycetales;f__Saccharomycetales_fam_Incertae_sedis;g__Candida;s__Candida Candida_albicans f88d9001e10f6d37672514972e6a199e\tk__Fungi;p__Ascomycota;c__Saccharomycetes;o__Saccharomycetales;f__Saccharomycetales_fam_Incertae_sedis;g__Candida;s__Candida Candida_albicans c3519270e269b92d3577ed450032bbc4\tk__Fungi;p__Ascomycota;c__Eurotiomycetes;o__Eurotiales;f__Aspergillaceae;g__Penicillium;s__ 补充脚本信息：\n1.split_fasta.py：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #!/share/home/jianglab/pengchen/miniconda3/bin/python3.9 import argparse def process_fasta(input_file, unite_fa, unite_taxonomy): with open(input_file, \u0026#39;r\u0026#39;) as infile, open(unite_fa, \u0026#39;w\u0026#39;) as fa_out, open(unite_taxonomy, \u0026#39;w\u0026#39;) as tax_out: for line in infile: if line.startswith(\u0026#39;\u0026gt;\u0026#39;): # Extract information from the header header = line.strip() parts = header.split(\u0026#39;|\u0026#39;) accession = parts[1] taxonomy = parts[-1] formatted_taxonomy = taxonomy.replace(\u0026#39;;\u0026#39;, \u0026#39;; \u0026#39;).replace(\u0026#39; \u0026#39;, \u0026#39;\u0026#39;).replace(\u0026#39;;\u0026#39;, \u0026#39;; \u0026#39;) # Write to unite.fa fa_out.write(f\u0026#34;\u0026gt;{accession}\\n\u0026#34;) # Write to unite_taxonomy.txt tax_out.write(f\u0026#34;{accession}\\t{formatted_taxonomy}\\n\u0026#34;) else: # Write sequence lines to unite.fa fa_out.write(line) def main(): parser = argparse.ArgumentParser(description=\u0026#34;Process a fasta file to generate unite.fa and unite_taxonomy.txt.\u0026#34;) parser.add_argument(\u0026#34;-i\u0026#34;, required=True, help=\u0026#34;Input fasta file\u0026#34;) parser.add_argument(\u0026#34;-o\u0026#34;, required=True, help=\u0026#34;Output prefix for unite.fa and unite_taxonomy.txt\u0026#34;) args = parser.parse_args() input_file = args.i output_prefix = args.o unite_fa = f\u0026#34;{output_prefix}.fa\u0026#34; unite_taxonomy = f\u0026#34;{output_prefix}_taxonomy.txt\u0026#34; process_fasta(input_file, unite_fa, unite_taxonomy) if __name__ == \u0026#34;__main__\u0026#34;: main() 2.build_gg_taxonomy.pl : https://github.com/DerrickWood/kraken2/blob/master/scripts/build_gg_taxonomy.pl\n3.taxonkit: https://github.com/shenwei356/taxonkit\nReferences Lu, J., Salzberg, S.L. Ultrafast and accurate 16S rRNA microbial community analysis using Kraken 2. Microbiome 8, 124 (2020). https://doi.org/10.1186/s40168-020-00900-2 https://github.com/DerrickWood/kraken2/wiki/Manual#custom-databases https://github.com/DerrickWood/kraken2/issues/97 ","date":"2025-01-14T00:00:00Z","image":"https://jb-cao.github.io/Cao-blog/p/kraken-16s-its/images/k16s1_hu_268e43eaf6d0efdc.png","permalink":"https://jb-cao.github.io/Cao-blog/p/kraken-16s-its/","title":"使用Kraken进行16S/ITS物种注释（超快）"},{"content":"Introduction 生物合成基因簇 (BGC) 的计算分析通过快速研究微生物基因组序列内的次级代谢潜力，彻底改变了天然产物的发现。将同源 BGC 分组为基因簇家族 (GCF) 有助于绘制其结构和分类多样性，并通过对已知功能的 BGC 进行去重复，提供对假定 BGC 新颖性的见解。\n通过将从当前可用的基因组和 MAG 中鉴定出的大规模全球 BGC 集合作为数据源，BiG-FAM 提供了可探索的微生物次生代谢多样性“图集”，以浏览和搜索跨类群的生物合成多样性。 BiG-FAM 有助于查询假定的 BGC，以便根据公开数据与其他已知和预测的 BGC 的关系，快速找到它们在多样性图上的位置，并更好地了解它们的新颖性或（可能的）功能。\nBiG-FAM数据库（2020年）基于从多个公开可用来源获取的 1,225,071 个 BGC 的 GCF 聚类。这项大规模分析是使用 BiG-SLiCE 软件 和任意聚类阈值 (T=900.0) 进行的，结果构建了 29,955 个 GCF 模型，每个模型代表不同的蛋白质结构域和序列特征BGC。\n这个数据库一直没有更新，而最近几年又是宏基因组测序井喷的时候，里面的GCF数量肯定远低于现在已经发现的GCF，但稍微用一下做参考还是可以的（或者有想法可以自己跑一下更多公开数据说不定也是一篇NAR）\nBiG-FAM数据库在线访问：https://bigfam.bioinformatics.nl\n数据库特征 超过120万个BGC的GCF数据 BiG-FAM数据库包含29,955个通过BiG-SLiCE 1.0版本计算的GCF，这些数据源自1,225,071个BGC的集合。这些BGC通过antiSMASH v5.1.1从188,622个微生物基因组（包括细菌、真菌和古菌基因组）以及20,584个MAG中预测得到，并补充了来自MIBiG 2.0数据库的实验验证BGC。所有基因组的完整列表及其BGC计数和分类信息见补充表。这些BGC及其对应的GCF涵盖了广泛的生物合成类别和分类群，提供了对微生物次级代谢多样性的全面覆盖。\n数据库内容的无缝探索 基于BiG-SLiCE 1.0.0生成的核心SQLite3数据存储，作者使用Python Flask库构建了一个功能齐全的Web服务器。为了实现更流畅的浏览体验，特别是在计算密集型的网页中，作者额外实现了一层缓存存储，用于预取复杂SQL查询。此外，这种设置还实现了轻量级的“搜索和过滤”功能，使用户能够根据特定的分类群、来源数据集类型、生物合成类别或蛋白质域来查找BGC或GCF。\n用户提交BGC的快速GCF定位 使用BiG-SLiCE的一个主要优势在于，每个GCF的共享BGC特征被总结在与底层BGC相同的基于欧几里得距离的特征矩阵中，形成GCF模型。这使得BGC到GCF的线性匹配成为可能，从而可以在几秒钟内将新测序的BGC定位到预计算的生物合成多样性全球图谱中。为了便于使用这一功能，BiG-FAM集成了一个基于Web的“查询”提交系统，用户可以直接提交通过antiSMASH预测的BGC进行GCF分析。生成的BGC到GCF匹配结果将揭示查询BGC的近缘和远缘关系，帮助研究其新颖性、与其他BGC的关系，以及跨分类群的分布和进化。\n直接链接到BGC和基因组数据库 尽管BiG-FAM存储并展示了许多与BGC相关的有用信息，但它并非旨在成为一个BGC数据库，因此不包含与GCF无直接关联的信息。为了支持需要这些数据的用户，BiG-FAM存储了来自MIBiG和antiSMASH数据库的BGC元数据链接。这些交叉链接可用于获取更多信息，例如BGC产物的核心结构。此外，每个BGC的摘要页面还提供了原始基因组来源的链接，用户也可以从GCF页面下载合并的URL列表。\n应用示例 探索Ranthipeptide BGC的多样性 Ranthipeptides（曾被称为“SCIFF肽”）是一类核糖体合成并经翻译后修饰的肽（RiPPs），主要存在于梭菌纲（Clostridia）中，尽管GC含量分析表明其生物合成基因可能通过水平转移传播到其他分类群。近期研究表明，这些肽在群体水平调控中发挥重要作用，例如通过群体感应机制。在作者先前绘制120万个BGC全球多样性的研究中，作者捕获了6,800个推定的ranthipeptide BGC，这些BGC在前体肽侧翼的基因邻域表现出多样性。为了探索这种多样性，作者可以使用BiG-FAM的“GCF搜索”功能，并以该BGC类的两个标志性结构域（AS-TIGR03973和Radical_SAM）作为查询条件。搜索结果显示了79个GCF，每个GCF代表了不同的BGC分布模式及其分类学来源。通过点击每个GCF的详情页面链接，可以获取其分类来源、核苷酸长度、计算半径以及GCF内BGC共享的生物合成特征。此外，所有BGC的概览及其序列链接可以以TSV格式下载。多基因比较可视化功能还提供了ranthipeptide前体基因侧翼基因邻域多样性的整合视图。\n对新测序链霉菌株的GCF分析 最近，一株从突尼斯薰衣草根际土壤中分离的新链霉菌——Streptomyces tunisialbus的基因组草图被发布。为了展示BiG-FAM如何用于评估新测序BGC的生物合成新颖性并捕捉其远缘关系，作者从ENA下载了该基因组的组装数据，并将其上传至antiSMASH Web服务器，获得了一个唯一的任务ID。该ID可直接用于在BiG-FAM中进行GCF分析。对36个antiSMASH预测的BGC的完整分析在不到一分钟内完成，生成了最佳BGC-to-GCF匹配对的汇总表。其中一个有趣的BGC是来自“Region 15.1”的完整46.5 kb Type-I PKS基因簇，其在ClusterBlast和KnownClusterBlast结果中与公共数据库的基因簇匹配率较低。GCF分析结果显示，该BGC仅与一个单例GCF有显著匹配，进一步检查发现该GCF源自同一基因组的NCBI提交条目。这表明该PKS BGC代表了一种新型BGC，因为它与其他基因组中的GCF成员没有密切关系。通过“追踪”查询BGC的生物合成结构域，可以分析与数百至数千个远缘BGC的关系，展示基因之间的结构域架构相似性。\nReference Satria A Kautsar, Kai Blin, Simon Shaw, Tilmann Weber, Marnix H Medema, BiG-FAM: the biosynthetic gene cluster families database, Nucleic Acids Research, Volume 49, Issue D1, 8 January 2021, Pages D490–D497, https://doi.org/10.1093/nar/gkaa812\n","date":"2025-01-08T00:00:00Z","image":"https://jb-cao.github.io/Cao-blog/p/gcf-big-fam/images/Screenshot%202025-01-08%20at%2011.53.28_hu_a2ceb9aedcd0dcf0.png","permalink":"https://jb-cao.github.io/Cao-blog/p/gcf-big-fam/","title":"生物合成基因簇家族（GCF）数据库 BiG-FAM"}]